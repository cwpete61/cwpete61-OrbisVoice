
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantTwilioConfig
 * 
 */
export type TenantTwilioConfig = $Result.DefaultSelection<Prisma.$TenantTwilioConfigPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Transcript
 * 
 */
export type Transcript = $Result.DefaultSelection<Prisma.$TranscriptPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model RewardTransaction
 * 
 */
export type RewardTransaction = $Result.DefaultSelection<Prisma.$RewardTransactionPayload>
/**
 * Model ToolExecutionAudit
 * 
 */
export type ToolExecutionAudit = $Result.DefaultSelection<Prisma.$ToolExecutionAuditPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model GoogleAuthConfig
 * 
 */
export type GoogleAuthConfig = $Result.DefaultSelection<Prisma.$GoogleAuthConfigPayload>
/**
 * Model SystemEmailConfig
 * 
 */
export type SystemEmailConfig = $Result.DefaultSelection<Prisma.$SystemEmailConfigPayload>
/**
 * Model StripeConnectConfig
 * 
 */
export type StripeConnectConfig = $Result.DefaultSelection<Prisma.$StripeConnectConfigPayload>
/**
 * Model TenantGoogleConfig
 * 
 */
export type TenantGoogleConfig = $Result.DefaultSelection<Prisma.$TenantGoogleConfigPayload>
/**
 * Model CalendarCredentials
 * 
 */
export type CalendarCredentials = $Result.DefaultSelection<Prisma.$CalendarCredentialsPayload>
/**
 * Model GmailCredentials
 * 
 */
export type GmailCredentials = $Result.DefaultSelection<Prisma.$GmailCredentialsPayload>
/**
 * Model PlatformSettings
 * 
 */
export type PlatformSettings = $Result.DefaultSelection<Prisma.$PlatformSettingsPayload>
/**
 * Model Affiliate
 * 
 */
export type Affiliate = $Result.DefaultSelection<Prisma.$AffiliatePayload>
/**
 * Model AffiliateReferral
 * 
 */
export type AffiliateReferral = $Result.DefaultSelection<Prisma.$AffiliateReferralPayload>
/**
 * Model AffiliatePayout
 * 
 */
export type AffiliatePayout = $Result.DefaultSelection<Prisma.$AffiliatePayoutPayload>
/**
 * Model ConversationPackage
 * 
 */
export type ConversationPackage = $Result.DefaultSelection<Prisma.$ConversationPackagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CommissionLevel: {
  LOW: 'LOW',
  MED: 'MED',
  HIGH: 'HIGH'
};

export type CommissionLevel = (typeof CommissionLevel)[keyof typeof CommissionLevel]


export const AffiliateStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  REJECTED: 'REJECTED'
};

export type AffiliateStatus = (typeof AffiliateStatus)[keyof typeof AffiliateStatus]


export const AffiliateReferralStatus: {
  PENDING: 'PENDING',
  CONVERTED: 'CONVERTED',
  REJECTED: 'REJECTED'
};

export type AffiliateReferralStatus = (typeof AffiliateReferralStatus)[keyof typeof AffiliateReferralStatus]


export const PayoutStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED'
};

export type PayoutStatus = (typeof PayoutStatus)[keyof typeof PayoutStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CommissionLevel = $Enums.CommissionLevel

export const CommissionLevel: typeof $Enums.CommissionLevel

export type AffiliateStatus = $Enums.AffiliateStatus

export const AffiliateStatus: typeof $Enums.AffiliateStatus

export type AffiliateReferralStatus = $Enums.AffiliateReferralStatus

export const AffiliateReferralStatus: typeof $Enums.AffiliateReferralStatus

export type PayoutStatus = $Enums.PayoutStatus

export const PayoutStatus: typeof $Enums.PayoutStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.tenantTwilioConfig`: Exposes CRUD operations for the **TenantTwilioConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantTwilioConfigs
    * const tenantTwilioConfigs = await prisma.tenantTwilioConfig.findMany()
    * ```
    */
  get tenantTwilioConfig(): Prisma.TenantTwilioConfigDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.transcript`: Exposes CRUD operations for the **Transcript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transcripts
    * const transcripts = await prisma.transcript.findMany()
    * ```
    */
  get transcript(): Prisma.TranscriptDelegate<ExtArgs>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs>;

  /**
   * `prisma.rewardTransaction`: Exposes CRUD operations for the **RewardTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardTransactions
    * const rewardTransactions = await prisma.rewardTransaction.findMany()
    * ```
    */
  get rewardTransaction(): Prisma.RewardTransactionDelegate<ExtArgs>;

  /**
   * `prisma.toolExecutionAudit`: Exposes CRUD operations for the **ToolExecutionAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ToolExecutionAudits
    * const toolExecutionAudits = await prisma.toolExecutionAudit.findMany()
    * ```
    */
  get toolExecutionAudit(): Prisma.ToolExecutionAuditDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.googleAuthConfig`: Exposes CRUD operations for the **GoogleAuthConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoogleAuthConfigs
    * const googleAuthConfigs = await prisma.googleAuthConfig.findMany()
    * ```
    */
  get googleAuthConfig(): Prisma.GoogleAuthConfigDelegate<ExtArgs>;

  /**
   * `prisma.systemEmailConfig`: Exposes CRUD operations for the **SystemEmailConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemEmailConfigs
    * const systemEmailConfigs = await prisma.systemEmailConfig.findMany()
    * ```
    */
  get systemEmailConfig(): Prisma.SystemEmailConfigDelegate<ExtArgs>;

  /**
   * `prisma.stripeConnectConfig`: Exposes CRUD operations for the **StripeConnectConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeConnectConfigs
    * const stripeConnectConfigs = await prisma.stripeConnectConfig.findMany()
    * ```
    */
  get stripeConnectConfig(): Prisma.StripeConnectConfigDelegate<ExtArgs>;

  /**
   * `prisma.tenantGoogleConfig`: Exposes CRUD operations for the **TenantGoogleConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantGoogleConfigs
    * const tenantGoogleConfigs = await prisma.tenantGoogleConfig.findMany()
    * ```
    */
  get tenantGoogleConfig(): Prisma.TenantGoogleConfigDelegate<ExtArgs>;

  /**
   * `prisma.calendarCredentials`: Exposes CRUD operations for the **CalendarCredentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarCredentials
    * const calendarCredentials = await prisma.calendarCredentials.findMany()
    * ```
    */
  get calendarCredentials(): Prisma.CalendarCredentialsDelegate<ExtArgs>;

  /**
   * `prisma.gmailCredentials`: Exposes CRUD operations for the **GmailCredentials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GmailCredentials
    * const gmailCredentials = await prisma.gmailCredentials.findMany()
    * ```
    */
  get gmailCredentials(): Prisma.GmailCredentialsDelegate<ExtArgs>;

  /**
   * `prisma.platformSettings`: Exposes CRUD operations for the **PlatformSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformSettings
    * const platformSettings = await prisma.platformSettings.findMany()
    * ```
    */
  get platformSettings(): Prisma.PlatformSettingsDelegate<ExtArgs>;

  /**
   * `prisma.affiliate`: Exposes CRUD operations for the **Affiliate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliates
    * const affiliates = await prisma.affiliate.findMany()
    * ```
    */
  get affiliate(): Prisma.AffiliateDelegate<ExtArgs>;

  /**
   * `prisma.affiliateReferral`: Exposes CRUD operations for the **AffiliateReferral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateReferrals
    * const affiliateReferrals = await prisma.affiliateReferral.findMany()
    * ```
    */
  get affiliateReferral(): Prisma.AffiliateReferralDelegate<ExtArgs>;

  /**
   * `prisma.affiliatePayout`: Exposes CRUD operations for the **AffiliatePayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliatePayouts
    * const affiliatePayouts = await prisma.affiliatePayout.findMany()
    * ```
    */
  get affiliatePayout(): Prisma.AffiliatePayoutDelegate<ExtArgs>;

  /**
   * `prisma.conversationPackage`: Exposes CRUD operations for the **ConversationPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationPackages
    * const conversationPackages = await prisma.conversationPackage.findMany()
    * ```
    */
  get conversationPackage(): Prisma.ConversationPackageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    TenantTwilioConfig: 'TenantTwilioConfig',
    User: 'User',
    Agent: 'Agent',
    ApiKey: 'ApiKey',
    Transcript: 'Transcript',
    Referral: 'Referral',
    RewardTransaction: 'RewardTransaction',
    ToolExecutionAudit: 'ToolExecutionAudit',
    Lead: 'Lead',
    GoogleAuthConfig: 'GoogleAuthConfig',
    SystemEmailConfig: 'SystemEmailConfig',
    StripeConnectConfig: 'StripeConnectConfig',
    TenantGoogleConfig: 'TenantGoogleConfig',
    CalendarCredentials: 'CalendarCredentials',
    GmailCredentials: 'GmailCredentials',
    PlatformSettings: 'PlatformSettings',
    Affiliate: 'Affiliate',
    AffiliateReferral: 'AffiliateReferral',
    AffiliatePayout: 'AffiliatePayout',
    ConversationPackage: 'ConversationPackage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "tenantTwilioConfig" | "user" | "agent" | "apiKey" | "transcript" | "referral" | "rewardTransaction" | "toolExecutionAudit" | "lead" | "googleAuthConfig" | "systemEmailConfig" | "stripeConnectConfig" | "tenantGoogleConfig" | "calendarCredentials" | "gmailCredentials" | "platformSettings" | "affiliate" | "affiliateReferral" | "affiliatePayout" | "conversationPackage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantTwilioConfig: {
        payload: Prisma.$TenantTwilioConfigPayload<ExtArgs>
        fields: Prisma.TenantTwilioConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantTwilioConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantTwilioConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>
          }
          findFirst: {
            args: Prisma.TenantTwilioConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantTwilioConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>
          }
          findMany: {
            args: Prisma.TenantTwilioConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>[]
          }
          create: {
            args: Prisma.TenantTwilioConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>
          }
          createMany: {
            args: Prisma.TenantTwilioConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantTwilioConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>[]
          }
          delete: {
            args: Prisma.TenantTwilioConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>
          }
          update: {
            args: Prisma.TenantTwilioConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>
          }
          deleteMany: {
            args: Prisma.TenantTwilioConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantTwilioConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantTwilioConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantTwilioConfigPayload>
          }
          aggregate: {
            args: Prisma.TenantTwilioConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantTwilioConfig>
          }
          groupBy: {
            args: Prisma.TenantTwilioConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantTwilioConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantTwilioConfigCountArgs<ExtArgs>
            result: $Utils.Optional<TenantTwilioConfigCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Transcript: {
        payload: Prisma.$TranscriptPayload<ExtArgs>
        fields: Prisma.TranscriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findFirst: {
            args: Prisma.TranscriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findMany: {
            args: Prisma.TranscriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          create: {
            args: Prisma.TranscriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          createMany: {
            args: Prisma.TranscriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          delete: {
            args: Prisma.TranscriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          update: {
            args: Prisma.TranscriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranscriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          aggregate: {
            args: Prisma.TranscriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscript>
          }
          groupBy: {
            args: Prisma.TranscriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      RewardTransaction: {
        payload: Prisma.$RewardTransactionPayload<ExtArgs>
        fields: Prisma.RewardTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          findFirst: {
            args: Prisma.RewardTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          findMany: {
            args: Prisma.RewardTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>[]
          }
          create: {
            args: Prisma.RewardTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          createMany: {
            args: Prisma.RewardTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>[]
          }
          delete: {
            args: Prisma.RewardTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          update: {
            args: Prisma.RewardTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          deleteMany: {
            args: Prisma.RewardTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardTransactionPayload>
          }
          aggregate: {
            args: Prisma.RewardTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardTransaction>
          }
          groupBy: {
            args: Prisma.RewardTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<RewardTransactionCountAggregateOutputType> | number
          }
        }
      }
      ToolExecutionAudit: {
        payload: Prisma.$ToolExecutionAuditPayload<ExtArgs>
        fields: Prisma.ToolExecutionAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ToolExecutionAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ToolExecutionAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>
          }
          findFirst: {
            args: Prisma.ToolExecutionAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ToolExecutionAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>
          }
          findMany: {
            args: Prisma.ToolExecutionAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>[]
          }
          create: {
            args: Prisma.ToolExecutionAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>
          }
          createMany: {
            args: Prisma.ToolExecutionAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ToolExecutionAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>[]
          }
          delete: {
            args: Prisma.ToolExecutionAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>
          }
          update: {
            args: Prisma.ToolExecutionAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>
          }
          deleteMany: {
            args: Prisma.ToolExecutionAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ToolExecutionAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ToolExecutionAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionAuditPayload>
          }
          aggregate: {
            args: Prisma.ToolExecutionAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToolExecutionAudit>
          }
          groupBy: {
            args: Prisma.ToolExecutionAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<ToolExecutionAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.ToolExecutionAuditCountArgs<ExtArgs>
            result: $Utils.Optional<ToolExecutionAuditCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      GoogleAuthConfig: {
        payload: Prisma.$GoogleAuthConfigPayload<ExtArgs>
        fields: Prisma.GoogleAuthConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoogleAuthConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoogleAuthConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>
          }
          findFirst: {
            args: Prisma.GoogleAuthConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoogleAuthConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>
          }
          findMany: {
            args: Prisma.GoogleAuthConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>[]
          }
          create: {
            args: Prisma.GoogleAuthConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>
          }
          createMany: {
            args: Prisma.GoogleAuthConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoogleAuthConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>[]
          }
          delete: {
            args: Prisma.GoogleAuthConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>
          }
          update: {
            args: Prisma.GoogleAuthConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>
          }
          deleteMany: {
            args: Prisma.GoogleAuthConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoogleAuthConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoogleAuthConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthConfigPayload>
          }
          aggregate: {
            args: Prisma.GoogleAuthConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoogleAuthConfig>
          }
          groupBy: {
            args: Prisma.GoogleAuthConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoogleAuthConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoogleAuthConfigCountArgs<ExtArgs>
            result: $Utils.Optional<GoogleAuthConfigCountAggregateOutputType> | number
          }
        }
      }
      SystemEmailConfig: {
        payload: Prisma.$SystemEmailConfigPayload<ExtArgs>
        fields: Prisma.SystemEmailConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemEmailConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemEmailConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemEmailConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemEmailConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>
          }
          findMany: {
            args: Prisma.SystemEmailConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>[]
          }
          create: {
            args: Prisma.SystemEmailConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>
          }
          createMany: {
            args: Prisma.SystemEmailConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemEmailConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemEmailConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>
          }
          update: {
            args: Prisma.SystemEmailConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemEmailConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemEmailConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemEmailConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemEmailConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemEmailConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemEmailConfig>
          }
          groupBy: {
            args: Prisma.SystemEmailConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemEmailConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemEmailConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemEmailConfigCountAggregateOutputType> | number
          }
        }
      }
      StripeConnectConfig: {
        payload: Prisma.$StripeConnectConfigPayload<ExtArgs>
        fields: Prisma.StripeConnectConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeConnectConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeConnectConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>
          }
          findFirst: {
            args: Prisma.StripeConnectConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeConnectConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>
          }
          findMany: {
            args: Prisma.StripeConnectConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>[]
          }
          create: {
            args: Prisma.StripeConnectConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>
          }
          createMany: {
            args: Prisma.StripeConnectConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StripeConnectConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>[]
          }
          delete: {
            args: Prisma.StripeConnectConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>
          }
          update: {
            args: Prisma.StripeConnectConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>
          }
          deleteMany: {
            args: Prisma.StripeConnectConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StripeConnectConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StripeConnectConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConnectConfigPayload>
          }
          aggregate: {
            args: Prisma.StripeConnectConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStripeConnectConfig>
          }
          groupBy: {
            args: Prisma.StripeConnectConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StripeConnectConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripeConnectConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StripeConnectConfigCountAggregateOutputType> | number
          }
        }
      }
      TenantGoogleConfig: {
        payload: Prisma.$TenantGoogleConfigPayload<ExtArgs>
        fields: Prisma.TenantGoogleConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantGoogleConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantGoogleConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>
          }
          findFirst: {
            args: Prisma.TenantGoogleConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantGoogleConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>
          }
          findMany: {
            args: Prisma.TenantGoogleConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>[]
          }
          create: {
            args: Prisma.TenantGoogleConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>
          }
          createMany: {
            args: Prisma.TenantGoogleConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantGoogleConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>[]
          }
          delete: {
            args: Prisma.TenantGoogleConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>
          }
          update: {
            args: Prisma.TenantGoogleConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>
          }
          deleteMany: {
            args: Prisma.TenantGoogleConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantGoogleConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantGoogleConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantGoogleConfigPayload>
          }
          aggregate: {
            args: Prisma.TenantGoogleConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantGoogleConfig>
          }
          groupBy: {
            args: Prisma.TenantGoogleConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGoogleConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantGoogleConfigCountArgs<ExtArgs>
            result: $Utils.Optional<TenantGoogleConfigCountAggregateOutputType> | number
          }
        }
      }
      CalendarCredentials: {
        payload: Prisma.$CalendarCredentialsPayload<ExtArgs>
        fields: Prisma.CalendarCredentialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarCredentialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarCredentialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>
          }
          findFirst: {
            args: Prisma.CalendarCredentialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarCredentialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>
          }
          findMany: {
            args: Prisma.CalendarCredentialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>[]
          }
          create: {
            args: Prisma.CalendarCredentialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>
          }
          createMany: {
            args: Prisma.CalendarCredentialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarCredentialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>[]
          }
          delete: {
            args: Prisma.CalendarCredentialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>
          }
          update: {
            args: Prisma.CalendarCredentialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>
          }
          deleteMany: {
            args: Prisma.CalendarCredentialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarCredentialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarCredentialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarCredentialsPayload>
          }
          aggregate: {
            args: Prisma.CalendarCredentialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarCredentials>
          }
          groupBy: {
            args: Prisma.CalendarCredentialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarCredentialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarCredentialsCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarCredentialsCountAggregateOutputType> | number
          }
        }
      }
      GmailCredentials: {
        payload: Prisma.$GmailCredentialsPayload<ExtArgs>
        fields: Prisma.GmailCredentialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GmailCredentialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GmailCredentialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>
          }
          findFirst: {
            args: Prisma.GmailCredentialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GmailCredentialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>
          }
          findMany: {
            args: Prisma.GmailCredentialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>[]
          }
          create: {
            args: Prisma.GmailCredentialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>
          }
          createMany: {
            args: Prisma.GmailCredentialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GmailCredentialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>[]
          }
          delete: {
            args: Prisma.GmailCredentialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>
          }
          update: {
            args: Prisma.GmailCredentialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>
          }
          deleteMany: {
            args: Prisma.GmailCredentialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GmailCredentialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GmailCredentialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailCredentialsPayload>
          }
          aggregate: {
            args: Prisma.GmailCredentialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGmailCredentials>
          }
          groupBy: {
            args: Prisma.GmailCredentialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GmailCredentialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GmailCredentialsCountArgs<ExtArgs>
            result: $Utils.Optional<GmailCredentialsCountAggregateOutputType> | number
          }
        }
      }
      PlatformSettings: {
        payload: Prisma.$PlatformSettingsPayload<ExtArgs>
        fields: Prisma.PlatformSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          findFirst: {
            args: Prisma.PlatformSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          findMany: {
            args: Prisma.PlatformSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>[]
          }
          create: {
            args: Prisma.PlatformSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          createMany: {
            args: Prisma.PlatformSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>[]
          }
          delete: {
            args: Prisma.PlatformSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          update: {
            args: Prisma.PlatformSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          deleteMany: {
            args: Prisma.PlatformSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlatformSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSettingsPayload>
          }
          aggregate: {
            args: Prisma.PlatformSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformSettings>
          }
          groupBy: {
            args: Prisma.PlatformSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformSettingsCountAggregateOutputType> | number
          }
        }
      }
      Affiliate: {
        payload: Prisma.$AffiliatePayload<ExtArgs>
        fields: Prisma.AffiliateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          findFirst: {
            args: Prisma.AffiliateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          findMany: {
            args: Prisma.AffiliateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>[]
          }
          create: {
            args: Prisma.AffiliateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          createMany: {
            args: Prisma.AffiliateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>[]
          }
          delete: {
            args: Prisma.AffiliateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          update: {
            args: Prisma.AffiliateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          deleteMany: {
            args: Prisma.AffiliateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          aggregate: {
            args: Prisma.AffiliateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliate>
          }
          groupBy: {
            args: Prisma.AffiliateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateCountAggregateOutputType> | number
          }
        }
      }
      AffiliateReferral: {
        payload: Prisma.$AffiliateReferralPayload<ExtArgs>
        fields: Prisma.AffiliateReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>
          }
          findFirst: {
            args: Prisma.AffiliateReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>
          }
          findMany: {
            args: Prisma.AffiliateReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>[]
          }
          create: {
            args: Prisma.AffiliateReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>
          }
          createMany: {
            args: Prisma.AffiliateReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>[]
          }
          delete: {
            args: Prisma.AffiliateReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>
          }
          update: {
            args: Prisma.AffiliateReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateReferralPayload>
          }
          aggregate: {
            args: Prisma.AffiliateReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateReferral>
          }
          groupBy: {
            args: Prisma.AffiliateReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateReferralCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateReferralCountAggregateOutputType> | number
          }
        }
      }
      AffiliatePayout: {
        payload: Prisma.$AffiliatePayoutPayload<ExtArgs>
        fields: Prisma.AffiliatePayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliatePayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliatePayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>
          }
          findFirst: {
            args: Prisma.AffiliatePayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliatePayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>
          }
          findMany: {
            args: Prisma.AffiliatePayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>[]
          }
          create: {
            args: Prisma.AffiliatePayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>
          }
          createMany: {
            args: Prisma.AffiliatePayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliatePayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>[]
          }
          delete: {
            args: Prisma.AffiliatePayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>
          }
          update: {
            args: Prisma.AffiliatePayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>
          }
          deleteMany: {
            args: Prisma.AffiliatePayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliatePayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliatePayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayoutPayload>
          }
          aggregate: {
            args: Prisma.AffiliatePayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliatePayout>
          }
          groupBy: {
            args: Prisma.AffiliatePayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliatePayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliatePayoutCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliatePayoutCountAggregateOutputType> | number
          }
        }
      }
      ConversationPackage: {
        payload: Prisma.$ConversationPackagePayload<ExtArgs>
        fields: Prisma.ConversationPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>
          }
          findFirst: {
            args: Prisma.ConversationPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>
          }
          findMany: {
            args: Prisma.ConversationPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>[]
          }
          create: {
            args: Prisma.ConversationPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>
          }
          createMany: {
            args: Prisma.ConversationPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>[]
          }
          delete: {
            args: Prisma.ConversationPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>
          }
          update: {
            args: Prisma.ConversationPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>
          }
          deleteMany: {
            args: Prisma.ConversationPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPackagePayload>
          }
          aggregate: {
            args: Prisma.ConversationPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationPackage>
          }
          groupBy: {
            args: Prisma.ConversationPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationPackageCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationPackageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    agents: number
    apiKeys: number
    leads: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    agents?: boolean | TenantCountOutputTypeCountAgentsArgs
    apiKeys?: boolean | TenantCountOutputTypeCountApiKeysArgs
    leads?: boolean | TenantCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    referralsCreated: number
    rewards: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referralsCreated?: boolean | UserCountOutputTypeCountReferralsCreatedArgs
    rewards?: boolean | UserCountOutputTypeCountRewardsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardTransactionWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    transcripts: number
    toolAudits: number
    leads: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transcripts?: boolean | AgentCountOutputTypeCountTranscriptsArgs
    toolAudits?: boolean | AgentCountOutputTypeCountToolAuditsArgs
    leads?: boolean | AgentCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTranscriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountToolAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToolExecutionAuditWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Count Type AffiliateCountOutputType
   */

  export type AffiliateCountOutputType = {
    referrals: number
    payouts: number
  }

  export type AffiliateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrals?: boolean | AffiliateCountOutputTypeCountReferralsArgs
    payouts?: boolean | AffiliateCountOutputTypeCountPayoutsArgs
  }

  // Custom InputTypes
  /**
   * AffiliateCountOutputType without action
   */
  export type AffiliateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateCountOutputType
     */
    select?: AffiliateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliateCountOutputType without action
   */
  export type AffiliateCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateReferralWhereInput
  }

  /**
   * AffiliateCountOutputType without action
   */
  export type AffiliateCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliatePayoutWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    usageLimit: number | null
    usageCount: number | null
    creditBalance: number | null
  }

  export type TenantSumAggregateOutputType = {
    usageLimit: number | null
    usageCount: number | null
    creditBalance: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    subscriptionTier: string | null
    subscriptionEnds: Date | null
    usageLimit: number | null
    usageCount: number | null
    usageResetAt: Date | null
    billingEmail: string | null
    creditBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    subscriptionTier: string | null
    subscriptionEnds: Date | null
    usageLimit: number | null
    usageCount: number | null
    usageResetAt: Date | null
    billingEmail: string | null
    creditBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    subscriptionStatus: number
    subscriptionTier: number
    subscriptionEnds: number
    usageLimit: number
    usageCount: number
    usageResetAt: number
    billingEmail: number
    creditBalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    usageLimit?: true
    usageCount?: true
    creditBalance?: true
  }

  export type TenantSumAggregateInputType = {
    usageLimit?: true
    usageCount?: true
    creditBalance?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    subscriptionTier?: true
    subscriptionEnds?: true
    usageLimit?: true
    usageCount?: true
    usageResetAt?: true
    billingEmail?: true
    creditBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    subscriptionTier?: true
    subscriptionEnds?: true
    usageLimit?: true
    usageCount?: true
    usageResetAt?: true
    billingEmail?: true
    creditBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    subscriptionStatus?: true
    subscriptionTier?: true
    subscriptionEnds?: true
    usageLimit?: true
    usageCount?: true
    usageResetAt?: true
    billingEmail?: true
    creditBalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    subscriptionStatus: string | null
    subscriptionTier: string
    subscriptionEnds: Date | null
    usageLimit: number
    usageCount: number
    usageResetAt: Date
    billingEmail: string | null
    creditBalance: number
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionTier?: boolean
    subscriptionEnds?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    usageResetAt?: boolean
    billingEmail?: boolean
    creditBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    agents?: boolean | Tenant$agentsArgs<ExtArgs>
    apiKeys?: boolean | Tenant$apiKeysArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    googleConfig?: boolean | Tenant$googleConfigArgs<ExtArgs>
    twilioConfig?: boolean | Tenant$twilioConfigArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionTier?: boolean
    subscriptionEnds?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    usageResetAt?: boolean
    billingEmail?: boolean
    creditBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    subscriptionStatus?: boolean
    subscriptionTier?: boolean
    subscriptionEnds?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    usageResetAt?: boolean
    billingEmail?: boolean
    creditBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    agents?: boolean | Tenant$agentsArgs<ExtArgs>
    apiKeys?: boolean | Tenant$apiKeysArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    googleConfig?: boolean | Tenant$googleConfigArgs<ExtArgs>
    twilioConfig?: boolean | Tenant$twilioConfigArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      googleConfig: Prisma.$TenantGoogleConfigPayload<ExtArgs> | null
      twilioConfig: Prisma.$TenantTwilioConfigPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      subscriptionStatus: string | null
      subscriptionTier: string
      subscriptionEnds: Date | null
      usageLimit: number
      usageCount: number
      usageResetAt: Date
      billingEmail: string | null
      creditBalance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    agents<T extends Tenant$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends Tenant$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends Tenant$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    googleConfig<T extends Tenant$googleConfigArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$googleConfigArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    twilioConfig<T extends Tenant$twilioConfigArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$twilioConfigArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly stripeCustomerId: FieldRef<"Tenant", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Tenant", 'String'>
    readonly subscriptionStatus: FieldRef<"Tenant", 'String'>
    readonly subscriptionTier: FieldRef<"Tenant", 'String'>
    readonly subscriptionEnds: FieldRef<"Tenant", 'DateTime'>
    readonly usageLimit: FieldRef<"Tenant", 'Int'>
    readonly usageCount: FieldRef<"Tenant", 'Int'>
    readonly usageResetAt: FieldRef<"Tenant", 'DateTime'>
    readonly billingEmail: FieldRef<"Tenant", 'String'>
    readonly creditBalance: FieldRef<"Tenant", 'Int'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.agents
   */
  export type Tenant$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Tenant.apiKeys
   */
  export type Tenant$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Tenant.leads
   */
  export type Tenant$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Tenant.googleConfig
   */
  export type Tenant$googleConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    where?: TenantGoogleConfigWhereInput
  }

  /**
   * Tenant.twilioConfig
   */
  export type Tenant$twilioConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    where?: TenantTwilioConfigWhereInput
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantTwilioConfig
   */

  export type AggregateTenantTwilioConfig = {
    _count: TenantTwilioConfigCountAggregateOutputType | null
    _min: TenantTwilioConfigMinAggregateOutputType | null
    _max: TenantTwilioConfigMaxAggregateOutputType | null
  }

  export type TenantTwilioConfigMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountSid: string | null
    authToken: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantTwilioConfigMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountSid: string | null
    authToken: string | null
    phoneNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantTwilioConfigCountAggregateOutputType = {
    id: number
    tenantId: number
    accountSid: number
    authToken: number
    phoneNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantTwilioConfigMinAggregateInputType = {
    id?: true
    tenantId?: true
    accountSid?: true
    authToken?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantTwilioConfigMaxAggregateInputType = {
    id?: true
    tenantId?: true
    accountSid?: true
    authToken?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantTwilioConfigCountAggregateInputType = {
    id?: true
    tenantId?: true
    accountSid?: true
    authToken?: true
    phoneNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantTwilioConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantTwilioConfig to aggregate.
     */
    where?: TenantTwilioConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantTwilioConfigs to fetch.
     */
    orderBy?: TenantTwilioConfigOrderByWithRelationInput | TenantTwilioConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantTwilioConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantTwilioConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantTwilioConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantTwilioConfigs
    **/
    _count?: true | TenantTwilioConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantTwilioConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantTwilioConfigMaxAggregateInputType
  }

  export type GetTenantTwilioConfigAggregateType<T extends TenantTwilioConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantTwilioConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantTwilioConfig[P]>
      : GetScalarType<T[P], AggregateTenantTwilioConfig[P]>
  }




  export type TenantTwilioConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantTwilioConfigWhereInput
    orderBy?: TenantTwilioConfigOrderByWithAggregationInput | TenantTwilioConfigOrderByWithAggregationInput[]
    by: TenantTwilioConfigScalarFieldEnum[] | TenantTwilioConfigScalarFieldEnum
    having?: TenantTwilioConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantTwilioConfigCountAggregateInputType | true
    _min?: TenantTwilioConfigMinAggregateInputType
    _max?: TenantTwilioConfigMaxAggregateInputType
  }

  export type TenantTwilioConfigGroupByOutputType = {
    id: string
    tenantId: string
    accountSid: string
    authToken: string
    phoneNumber: string
    createdAt: Date
    updatedAt: Date
    _count: TenantTwilioConfigCountAggregateOutputType | null
    _min: TenantTwilioConfigMinAggregateOutputType | null
    _max: TenantTwilioConfigMaxAggregateOutputType | null
  }

  type GetTenantTwilioConfigGroupByPayload<T extends TenantTwilioConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantTwilioConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantTwilioConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantTwilioConfigGroupByOutputType[P]>
            : GetScalarType<T[P], TenantTwilioConfigGroupByOutputType[P]>
        }
      >
    >


  export type TenantTwilioConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountSid?: boolean
    authToken?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantTwilioConfig"]>

  export type TenantTwilioConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountSid?: boolean
    authToken?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantTwilioConfig"]>

  export type TenantTwilioConfigSelectScalar = {
    id?: boolean
    tenantId?: boolean
    accountSid?: boolean
    authToken?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantTwilioConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantTwilioConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantTwilioConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantTwilioConfig"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      accountSid: string
      authToken: string
      phoneNumber: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantTwilioConfig"]>
    composites: {}
  }

  type TenantTwilioConfigGetPayload<S extends boolean | null | undefined | TenantTwilioConfigDefaultArgs> = $Result.GetResult<Prisma.$TenantTwilioConfigPayload, S>

  type TenantTwilioConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantTwilioConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantTwilioConfigCountAggregateInputType | true
    }

  export interface TenantTwilioConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantTwilioConfig'], meta: { name: 'TenantTwilioConfig' } }
    /**
     * Find zero or one TenantTwilioConfig that matches the filter.
     * @param {TenantTwilioConfigFindUniqueArgs} args - Arguments to find a TenantTwilioConfig
     * @example
     * // Get one TenantTwilioConfig
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantTwilioConfigFindUniqueArgs>(args: SelectSubset<T, TenantTwilioConfigFindUniqueArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenantTwilioConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantTwilioConfigFindUniqueOrThrowArgs} args - Arguments to find a TenantTwilioConfig
     * @example
     * // Get one TenantTwilioConfig
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantTwilioConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantTwilioConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenantTwilioConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantTwilioConfigFindFirstArgs} args - Arguments to find a TenantTwilioConfig
     * @example
     * // Get one TenantTwilioConfig
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantTwilioConfigFindFirstArgs>(args?: SelectSubset<T, TenantTwilioConfigFindFirstArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenantTwilioConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantTwilioConfigFindFirstOrThrowArgs} args - Arguments to find a TenantTwilioConfig
     * @example
     * // Get one TenantTwilioConfig
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantTwilioConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantTwilioConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenantTwilioConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantTwilioConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantTwilioConfigs
     * const tenantTwilioConfigs = await prisma.tenantTwilioConfig.findMany()
     * 
     * // Get first 10 TenantTwilioConfigs
     * const tenantTwilioConfigs = await prisma.tenantTwilioConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantTwilioConfigWithIdOnly = await prisma.tenantTwilioConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantTwilioConfigFindManyArgs>(args?: SelectSubset<T, TenantTwilioConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenantTwilioConfig.
     * @param {TenantTwilioConfigCreateArgs} args - Arguments to create a TenantTwilioConfig.
     * @example
     * // Create one TenantTwilioConfig
     * const TenantTwilioConfig = await prisma.tenantTwilioConfig.create({
     *   data: {
     *     // ... data to create a TenantTwilioConfig
     *   }
     * })
     * 
     */
    create<T extends TenantTwilioConfigCreateArgs>(args: SelectSubset<T, TenantTwilioConfigCreateArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenantTwilioConfigs.
     * @param {TenantTwilioConfigCreateManyArgs} args - Arguments to create many TenantTwilioConfigs.
     * @example
     * // Create many TenantTwilioConfigs
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantTwilioConfigCreateManyArgs>(args?: SelectSubset<T, TenantTwilioConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantTwilioConfigs and returns the data saved in the database.
     * @param {TenantTwilioConfigCreateManyAndReturnArgs} args - Arguments to create many TenantTwilioConfigs.
     * @example
     * // Create many TenantTwilioConfigs
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantTwilioConfigs and only return the `id`
     * const tenantTwilioConfigWithIdOnly = await prisma.tenantTwilioConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantTwilioConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantTwilioConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenantTwilioConfig.
     * @param {TenantTwilioConfigDeleteArgs} args - Arguments to delete one TenantTwilioConfig.
     * @example
     * // Delete one TenantTwilioConfig
     * const TenantTwilioConfig = await prisma.tenantTwilioConfig.delete({
     *   where: {
     *     // ... filter to delete one TenantTwilioConfig
     *   }
     * })
     * 
     */
    delete<T extends TenantTwilioConfigDeleteArgs>(args: SelectSubset<T, TenantTwilioConfigDeleteArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenantTwilioConfig.
     * @param {TenantTwilioConfigUpdateArgs} args - Arguments to update one TenantTwilioConfig.
     * @example
     * // Update one TenantTwilioConfig
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantTwilioConfigUpdateArgs>(args: SelectSubset<T, TenantTwilioConfigUpdateArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenantTwilioConfigs.
     * @param {TenantTwilioConfigDeleteManyArgs} args - Arguments to filter TenantTwilioConfigs to delete.
     * @example
     * // Delete a few TenantTwilioConfigs
     * const { count } = await prisma.tenantTwilioConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantTwilioConfigDeleteManyArgs>(args?: SelectSubset<T, TenantTwilioConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantTwilioConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantTwilioConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantTwilioConfigs
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantTwilioConfigUpdateManyArgs>(args: SelectSubset<T, TenantTwilioConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenantTwilioConfig.
     * @param {TenantTwilioConfigUpsertArgs} args - Arguments to update or create a TenantTwilioConfig.
     * @example
     * // Update or create a TenantTwilioConfig
     * const tenantTwilioConfig = await prisma.tenantTwilioConfig.upsert({
     *   create: {
     *     // ... data to create a TenantTwilioConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantTwilioConfig we want to update
     *   }
     * })
     */
    upsert<T extends TenantTwilioConfigUpsertArgs>(args: SelectSubset<T, TenantTwilioConfigUpsertArgs<ExtArgs>>): Prisma__TenantTwilioConfigClient<$Result.GetResult<Prisma.$TenantTwilioConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenantTwilioConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantTwilioConfigCountArgs} args - Arguments to filter TenantTwilioConfigs to count.
     * @example
     * // Count the number of TenantTwilioConfigs
     * const count = await prisma.tenantTwilioConfig.count({
     *   where: {
     *     // ... the filter for the TenantTwilioConfigs we want to count
     *   }
     * })
    **/
    count<T extends TenantTwilioConfigCountArgs>(
      args?: Subset<T, TenantTwilioConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantTwilioConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantTwilioConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantTwilioConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantTwilioConfigAggregateArgs>(args: Subset<T, TenantTwilioConfigAggregateArgs>): Prisma.PrismaPromise<GetTenantTwilioConfigAggregateType<T>>

    /**
     * Group by TenantTwilioConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantTwilioConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantTwilioConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantTwilioConfigGroupByArgs['orderBy'] }
        : { orderBy?: TenantTwilioConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantTwilioConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantTwilioConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantTwilioConfig model
   */
  readonly fields: TenantTwilioConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantTwilioConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantTwilioConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantTwilioConfig model
   */ 
  interface TenantTwilioConfigFieldRefs {
    readonly id: FieldRef<"TenantTwilioConfig", 'String'>
    readonly tenantId: FieldRef<"TenantTwilioConfig", 'String'>
    readonly accountSid: FieldRef<"TenantTwilioConfig", 'String'>
    readonly authToken: FieldRef<"TenantTwilioConfig", 'String'>
    readonly phoneNumber: FieldRef<"TenantTwilioConfig", 'String'>
    readonly createdAt: FieldRef<"TenantTwilioConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantTwilioConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantTwilioConfig findUnique
   */
  export type TenantTwilioConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantTwilioConfig to fetch.
     */
    where: TenantTwilioConfigWhereUniqueInput
  }

  /**
   * TenantTwilioConfig findUniqueOrThrow
   */
  export type TenantTwilioConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantTwilioConfig to fetch.
     */
    where: TenantTwilioConfigWhereUniqueInput
  }

  /**
   * TenantTwilioConfig findFirst
   */
  export type TenantTwilioConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantTwilioConfig to fetch.
     */
    where?: TenantTwilioConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantTwilioConfigs to fetch.
     */
    orderBy?: TenantTwilioConfigOrderByWithRelationInput | TenantTwilioConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantTwilioConfigs.
     */
    cursor?: TenantTwilioConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantTwilioConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantTwilioConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantTwilioConfigs.
     */
    distinct?: TenantTwilioConfigScalarFieldEnum | TenantTwilioConfigScalarFieldEnum[]
  }

  /**
   * TenantTwilioConfig findFirstOrThrow
   */
  export type TenantTwilioConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantTwilioConfig to fetch.
     */
    where?: TenantTwilioConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantTwilioConfigs to fetch.
     */
    orderBy?: TenantTwilioConfigOrderByWithRelationInput | TenantTwilioConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantTwilioConfigs.
     */
    cursor?: TenantTwilioConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantTwilioConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantTwilioConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantTwilioConfigs.
     */
    distinct?: TenantTwilioConfigScalarFieldEnum | TenantTwilioConfigScalarFieldEnum[]
  }

  /**
   * TenantTwilioConfig findMany
   */
  export type TenantTwilioConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantTwilioConfigs to fetch.
     */
    where?: TenantTwilioConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantTwilioConfigs to fetch.
     */
    orderBy?: TenantTwilioConfigOrderByWithRelationInput | TenantTwilioConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantTwilioConfigs.
     */
    cursor?: TenantTwilioConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantTwilioConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantTwilioConfigs.
     */
    skip?: number
    distinct?: TenantTwilioConfigScalarFieldEnum | TenantTwilioConfigScalarFieldEnum[]
  }

  /**
   * TenantTwilioConfig create
   */
  export type TenantTwilioConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantTwilioConfig.
     */
    data: XOR<TenantTwilioConfigCreateInput, TenantTwilioConfigUncheckedCreateInput>
  }

  /**
   * TenantTwilioConfig createMany
   */
  export type TenantTwilioConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantTwilioConfigs.
     */
    data: TenantTwilioConfigCreateManyInput | TenantTwilioConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantTwilioConfig createManyAndReturn
   */
  export type TenantTwilioConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenantTwilioConfigs.
     */
    data: TenantTwilioConfigCreateManyInput | TenantTwilioConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantTwilioConfig update
   */
  export type TenantTwilioConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantTwilioConfig.
     */
    data: XOR<TenantTwilioConfigUpdateInput, TenantTwilioConfigUncheckedUpdateInput>
    /**
     * Choose, which TenantTwilioConfig to update.
     */
    where: TenantTwilioConfigWhereUniqueInput
  }

  /**
   * TenantTwilioConfig updateMany
   */
  export type TenantTwilioConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantTwilioConfigs.
     */
    data: XOR<TenantTwilioConfigUpdateManyMutationInput, TenantTwilioConfigUncheckedUpdateManyInput>
    /**
     * Filter which TenantTwilioConfigs to update
     */
    where?: TenantTwilioConfigWhereInput
  }

  /**
   * TenantTwilioConfig upsert
   */
  export type TenantTwilioConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantTwilioConfig to update in case it exists.
     */
    where: TenantTwilioConfigWhereUniqueInput
    /**
     * In case the TenantTwilioConfig found by the `where` argument doesn't exist, create a new TenantTwilioConfig with this data.
     */
    create: XOR<TenantTwilioConfigCreateInput, TenantTwilioConfigUncheckedCreateInput>
    /**
     * In case the TenantTwilioConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantTwilioConfigUpdateInput, TenantTwilioConfigUncheckedUpdateInput>
  }

  /**
   * TenantTwilioConfig delete
   */
  export type TenantTwilioConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
    /**
     * Filter which TenantTwilioConfig to delete.
     */
    where: TenantTwilioConfigWhereUniqueInput
  }

  /**
   * TenantTwilioConfig deleteMany
   */
  export type TenantTwilioConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantTwilioConfigs to delete
     */
    where?: TenantTwilioConfigWhereInput
  }

  /**
   * TenantTwilioConfig without action
   */
  export type TenantTwilioConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantTwilioConfig
     */
    select?: TenantTwilioConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantTwilioConfigInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    referralRewardTotal: number | null
  }

  export type UserSumAggregateOutputType = {
    referralRewardTotal: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    username: string | null
    passwordHash: string | null
    isAdmin: boolean | null
    role: $Enums.UserRole | null
    isBlocked: boolean | null
    avatar: string | null
    commissionLevel: $Enums.CommissionLevel | null
    googleId: string | null
    googleEmail: string | null
    googleName: string | null
    googleProfilePicture: string | null
    googleAuthProvider: string | null
    referralCodeUsed: string | null
    referralRewardTotal: number | null
    isAffiliate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    businessName: string | null
    phone: string | null
    address: string | null
    unit: string | null
    city: string | null
    state: string | null
    zip: string | null
    tinSsn: string | null
    taxFormUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    username: string | null
    passwordHash: string | null
    isAdmin: boolean | null
    role: $Enums.UserRole | null
    isBlocked: boolean | null
    avatar: string | null
    commissionLevel: $Enums.CommissionLevel | null
    googleId: string | null
    googleEmail: string | null
    googleName: string | null
    googleProfilePicture: string | null
    googleAuthProvider: string | null
    referralCodeUsed: string | null
    referralRewardTotal: number | null
    isAffiliate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    businessName: string | null
    phone: string | null
    address: string | null
    unit: string | null
    city: string | null
    state: string | null
    zip: string | null
    tinSsn: string | null
    taxFormUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    name: number
    username: number
    passwordHash: number
    isAdmin: number
    role: number
    isBlocked: number
    avatar: number
    commissionLevel: number
    googleId: number
    googleEmail: number
    googleName: number
    googleProfilePicture: number
    googleAuthProvider: number
    referralCodeUsed: number
    referralRewardTotal: number
    isAffiliate: number
    createdAt: number
    updatedAt: number
    firstName: number
    lastName: number
    businessName: number
    phone: number
    address: number
    unit: number
    city: number
    state: number
    zip: number
    tinSsn: number
    taxFormUrl: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    referralRewardTotal?: true
  }

  export type UserSumAggregateInputType = {
    referralRewardTotal?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    username?: true
    passwordHash?: true
    isAdmin?: true
    role?: true
    isBlocked?: true
    avatar?: true
    commissionLevel?: true
    googleId?: true
    googleEmail?: true
    googleName?: true
    googleProfilePicture?: true
    googleAuthProvider?: true
    referralCodeUsed?: true
    referralRewardTotal?: true
    isAffiliate?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    businessName?: true
    phone?: true
    address?: true
    unit?: true
    city?: true
    state?: true
    zip?: true
    tinSsn?: true
    taxFormUrl?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    username?: true
    passwordHash?: true
    isAdmin?: true
    role?: true
    isBlocked?: true
    avatar?: true
    commissionLevel?: true
    googleId?: true
    googleEmail?: true
    googleName?: true
    googleProfilePicture?: true
    googleAuthProvider?: true
    referralCodeUsed?: true
    referralRewardTotal?: true
    isAffiliate?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    businessName?: true
    phone?: true
    address?: true
    unit?: true
    city?: true
    state?: true
    zip?: true
    tinSsn?: true
    taxFormUrl?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    username?: true
    passwordHash?: true
    isAdmin?: true
    role?: true
    isBlocked?: true
    avatar?: true
    commissionLevel?: true
    googleId?: true
    googleEmail?: true
    googleName?: true
    googleProfilePicture?: true
    googleAuthProvider?: true
    referralCodeUsed?: true
    referralRewardTotal?: true
    isAffiliate?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    businessName?: true
    phone?: true
    address?: true
    unit?: true
    city?: true
    state?: true
    zip?: true
    tinSsn?: true
    taxFormUrl?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    name: string
    username: string | null
    passwordHash: string | null
    isAdmin: boolean
    role: $Enums.UserRole
    isBlocked: boolean
    avatar: string | null
    commissionLevel: $Enums.CommissionLevel
    googleId: string | null
    googleEmail: string | null
    googleName: string | null
    googleProfilePicture: string | null
    googleAuthProvider: string | null
    referralCodeUsed: string | null
    referralRewardTotal: number
    isAffiliate: boolean
    createdAt: Date
    updatedAt: Date
    firstName: string | null
    lastName: string | null
    businessName: string | null
    phone: string | null
    address: string | null
    unit: string | null
    city: string | null
    state: string | null
    zip: string | null
    tinSsn: string | null
    taxFormUrl: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    passwordHash?: boolean
    isAdmin?: boolean
    role?: boolean
    isBlocked?: boolean
    avatar?: boolean
    commissionLevel?: boolean
    googleId?: boolean
    googleEmail?: boolean
    googleName?: boolean
    googleProfilePicture?: boolean
    googleAuthProvider?: boolean
    referralCodeUsed?: boolean
    referralRewardTotal?: boolean
    isAffiliate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    businessName?: boolean
    phone?: boolean
    address?: boolean
    unit?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    tinSsn?: boolean
    taxFormUrl?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    referralsCreated?: boolean | User$referralsCreatedArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
    rewards?: boolean | User$rewardsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    passwordHash?: boolean
    isAdmin?: boolean
    role?: boolean
    isBlocked?: boolean
    avatar?: boolean
    commissionLevel?: boolean
    googleId?: boolean
    googleEmail?: boolean
    googleName?: boolean
    googleProfilePicture?: boolean
    googleAuthProvider?: boolean
    referralCodeUsed?: boolean
    referralRewardTotal?: boolean
    isAffiliate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    businessName?: boolean
    phone?: boolean
    address?: boolean
    unit?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    tinSsn?: boolean
    taxFormUrl?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    passwordHash?: boolean
    isAdmin?: boolean
    role?: boolean
    isBlocked?: boolean
    avatar?: boolean
    commissionLevel?: boolean
    googleId?: boolean
    googleEmail?: boolean
    googleName?: boolean
    googleProfilePicture?: boolean
    googleAuthProvider?: boolean
    referralCodeUsed?: boolean
    referralRewardTotal?: boolean
    isAffiliate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    businessName?: boolean
    phone?: boolean
    address?: boolean
    unit?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    tinSsn?: boolean
    taxFormUrl?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    referralsCreated?: boolean | User$referralsCreatedArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
    rewards?: boolean | User$rewardsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      referralsCreated: Prisma.$ReferralPayload<ExtArgs>[]
      affiliate: Prisma.$AffiliatePayload<ExtArgs> | null
      rewards: Prisma.$RewardTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      name: string
      username: string | null
      passwordHash: string | null
      isAdmin: boolean
      role: $Enums.UserRole
      isBlocked: boolean
      avatar: string | null
      commissionLevel: $Enums.CommissionLevel
      googleId: string | null
      googleEmail: string | null
      googleName: string | null
      googleProfilePicture: string | null
      googleAuthProvider: string | null
      referralCodeUsed: string | null
      referralRewardTotal: number
      isAffiliate: boolean
      createdAt: Date
      updatedAt: Date
      firstName: string | null
      lastName: string | null
      businessName: string | null
      phone: string | null
      address: string | null
      unit: string | null
      city: string | null
      state: string | null
      zip: string | null
      tinSsn: string | null
      taxFormUrl: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referralsCreated<T extends User$referralsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate<T extends User$affiliateArgs<ExtArgs> = {}>(args?: Subset<T, User$affiliateArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rewards<T extends User$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isBlocked: FieldRef<"User", 'Boolean'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly commissionLevel: FieldRef<"User", 'CommissionLevel'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly googleEmail: FieldRef<"User", 'String'>
    readonly googleName: FieldRef<"User", 'String'>
    readonly googleProfilePicture: FieldRef<"User", 'String'>
    readonly googleAuthProvider: FieldRef<"User", 'String'>
    readonly referralCodeUsed: FieldRef<"User", 'String'>
    readonly referralRewardTotal: FieldRef<"User", 'Float'>
    readonly isAffiliate: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly businessName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly unit: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly zip: FieldRef<"User", 'String'>
    readonly tinSsn: FieldRef<"User", 'String'>
    readonly taxFormUrl: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.referralsCreated
   */
  export type User$referralsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.affiliate
   */
  export type User$affiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    where?: AffiliateWhereInput
  }

  /**
   * User.rewards
   */
  export type User$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    where?: RewardTransactionWhereInput
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    cursor?: RewardTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    systemPrompt: string | null
    voiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    systemPrompt: string | null
    voiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    systemPrompt: number
    voiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    systemPrompt?: true
    voiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    systemPrompt?: true
    voiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    systemPrompt?: true
    voiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    systemPrompt: string
    voiceId: string
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    systemPrompt?: boolean
    voiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transcripts?: boolean | Agent$transcriptsArgs<ExtArgs>
    toolAudits?: boolean | Agent$toolAuditsArgs<ExtArgs>
    leads?: boolean | Agent$leadsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    systemPrompt?: boolean
    voiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    systemPrompt?: boolean
    voiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transcripts?: boolean | Agent$transcriptsArgs<ExtArgs>
    toolAudits?: boolean | Agent$toolAuditsArgs<ExtArgs>
    leads?: boolean | Agent$leadsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      transcripts: Prisma.$TranscriptPayload<ExtArgs>[]
      toolAudits: Prisma.$ToolExecutionAuditPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      systemPrompt: string
      voiceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transcripts<T extends Agent$transcriptsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$transcriptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany"> | Null>
    toolAudits<T extends Agent$toolAuditsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$toolAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends Agent$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */ 
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly tenantId: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly systemPrompt: FieldRef<"Agent", 'String'>
    readonly voiceId: FieldRef<"Agent", 'String'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
  }

  /**
   * Agent.transcripts
   */
  export type Agent$transcriptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    cursor?: TranscriptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Agent.toolAudits
   */
  export type Agent$toolAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    where?: ToolExecutionAuditWhereInput
    orderBy?: ToolExecutionAuditOrderByWithRelationInput | ToolExecutionAuditOrderByWithRelationInput[]
    cursor?: ToolExecutionAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToolExecutionAuditScalarFieldEnum | ToolExecutionAuditScalarFieldEnum[]
  }

  /**
   * Agent.leads
   */
  export type Agent$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    key: string | null
    name: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    key: string | null
    name: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    tenantId: number
    key: number
    name: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    tenantId?: true
    key?: true
    name?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    tenantId?: true
    key?: true
    name?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    tenantId?: true
    key?: true
    name?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    tenantId: string
    key: string
    name: string
    createdAt: Date
    expiresAt: Date | null
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    key?: boolean
    name?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    key?: boolean
    name?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    tenantId?: boolean
    key?: boolean
    name?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      key: string
      name: string
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly tenantId: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Transcript
   */

  export type AggregateTranscript = {
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  export type TranscriptAvgAggregateOutputType = {
    duration: number | null
  }

  export type TranscriptSumAggregateOutputType = {
    duration: number | null
  }

  export type TranscriptMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    content: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type TranscriptMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    content: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type TranscriptCountAggregateOutputType = {
    id: number
    agentId: number
    userId: number
    content: number
    duration: number
    createdAt: number
    _all: number
  }


  export type TranscriptAvgAggregateInputType = {
    duration?: true
  }

  export type TranscriptSumAggregateInputType = {
    duration?: true
  }

  export type TranscriptMinAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    content?: true
    duration?: true
    createdAt?: true
  }

  export type TranscriptMaxAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    content?: true
    duration?: true
    createdAt?: true
  }

  export type TranscriptCountAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    content?: true
    duration?: true
    createdAt?: true
    _all?: true
  }

  export type TranscriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcript to aggregate.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transcripts
    **/
    _count?: true | TranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMaxAggregateInputType
  }

  export type GetTranscriptAggregateType<T extends TranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscript[P]>
      : GetScalarType<T[P], AggregateTranscript[P]>
  }




  export type TranscriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithAggregationInput | TranscriptOrderByWithAggregationInput[]
    by: TranscriptScalarFieldEnum[] | TranscriptScalarFieldEnum
    having?: TranscriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptCountAggregateInputType | true
    _avg?: TranscriptAvgAggregateInputType
    _sum?: TranscriptSumAggregateInputType
    _min?: TranscriptMinAggregateInputType
    _max?: TranscriptMaxAggregateInputType
  }

  export type TranscriptGroupByOutputType = {
    id: string
    agentId: string
    userId: string | null
    content: string
    duration: number
    createdAt: Date
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  type GetTranscriptGroupByPayload<T extends TranscriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    content?: boolean
    duration?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    content?: boolean
    duration?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>

  export type TranscriptSelectScalar = {
    id?: boolean
    agentId?: boolean
    userId?: boolean
    content?: boolean
    duration?: boolean
    createdAt?: boolean
  }

  export type TranscriptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type TranscriptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $TranscriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transcript"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      userId: string | null
      content: string
      duration: number
      createdAt: Date
    }, ExtArgs["result"]["transcript"]>
    composites: {}
  }

  type TranscriptGetPayload<S extends boolean | null | undefined | TranscriptDefaultArgs> = $Result.GetResult<Prisma.$TranscriptPayload, S>

  type TranscriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranscriptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranscriptCountAggregateInputType | true
    }

  export interface TranscriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transcript'], meta: { name: 'Transcript' } }
    /**
     * Find zero or one Transcript that matches the filter.
     * @param {TranscriptFindUniqueArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptFindUniqueArgs>(args: SelectSubset<T, TranscriptFindUniqueArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transcript that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranscriptFindUniqueOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transcript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptFindFirstArgs>(args?: SelectSubset<T, TranscriptFindFirstArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transcript that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transcripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transcripts
     * const transcripts = await prisma.transcript.findMany()
     * 
     * // Get first 10 Transcripts
     * const transcripts = await prisma.transcript.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptWithIdOnly = await prisma.transcript.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptFindManyArgs>(args?: SelectSubset<T, TranscriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transcript.
     * @param {TranscriptCreateArgs} args - Arguments to create a Transcript.
     * @example
     * // Create one Transcript
     * const Transcript = await prisma.transcript.create({
     *   data: {
     *     // ... data to create a Transcript
     *   }
     * })
     * 
     */
    create<T extends TranscriptCreateArgs>(args: SelectSubset<T, TranscriptCreateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transcripts.
     * @param {TranscriptCreateManyArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptCreateManyArgs>(args?: SelectSubset<T, TranscriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transcripts and returns the data saved in the database.
     * @param {TranscriptCreateManyAndReturnArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transcripts and only return the `id`
     * const transcriptWithIdOnly = await prisma.transcript.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transcript.
     * @param {TranscriptDeleteArgs} args - Arguments to delete one Transcript.
     * @example
     * // Delete one Transcript
     * const Transcript = await prisma.transcript.delete({
     *   where: {
     *     // ... filter to delete one Transcript
     *   }
     * })
     * 
     */
    delete<T extends TranscriptDeleteArgs>(args: SelectSubset<T, TranscriptDeleteArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transcript.
     * @param {TranscriptUpdateArgs} args - Arguments to update one Transcript.
     * @example
     * // Update one Transcript
     * const transcript = await prisma.transcript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptUpdateArgs>(args: SelectSubset<T, TranscriptUpdateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transcripts.
     * @param {TranscriptDeleteManyArgs} args - Arguments to filter Transcripts to delete.
     * @example
     * // Delete a few Transcripts
     * const { count } = await prisma.transcript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptDeleteManyArgs>(args?: SelectSubset<T, TranscriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptUpdateManyArgs>(args: SelectSubset<T, TranscriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transcript.
     * @param {TranscriptUpsertArgs} args - Arguments to update or create a Transcript.
     * @example
     * // Update or create a Transcript
     * const transcript = await prisma.transcript.upsert({
     *   create: {
     *     // ... data to create a Transcript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transcript we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptUpsertArgs>(args: SelectSubset<T, TranscriptUpsertArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCountArgs} args - Arguments to filter Transcripts to count.
     * @example
     * // Count the number of Transcripts
     * const count = await prisma.transcript.count({
     *   where: {
     *     // ... the filter for the Transcripts we want to count
     *   }
     * })
    **/
    count<T extends TranscriptCountArgs>(
      args?: Subset<T, TranscriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptAggregateArgs>(args: Subset<T, TranscriptAggregateArgs>): Prisma.PrismaPromise<GetTranscriptAggregateType<T>>

    /**
     * Group by Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transcript model
   */
  readonly fields: TranscriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transcript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transcript model
   */ 
  interface TranscriptFieldRefs {
    readonly id: FieldRef<"Transcript", 'String'>
    readonly agentId: FieldRef<"Transcript", 'String'>
    readonly userId: FieldRef<"Transcript", 'String'>
    readonly content: FieldRef<"Transcript", 'String'>
    readonly duration: FieldRef<"Transcript", 'Int'>
    readonly createdAt: FieldRef<"Transcript", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transcript findUnique
   */
  export type TranscriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findUniqueOrThrow
   */
  export type TranscriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findFirst
   */
  export type TranscriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findFirstOrThrow
   */
  export type TranscriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findMany
   */
  export type TranscriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcripts to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript create
   */
  export type TranscriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to create a Transcript.
     */
    data: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
  }

  /**
   * Transcript createMany
   */
  export type TranscriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transcript createManyAndReturn
   */
  export type TranscriptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transcript update
   */
  export type TranscriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to update a Transcript.
     */
    data: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
    /**
     * Choose, which Transcript to update.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript updateMany
   */
  export type TranscriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
  }

  /**
   * Transcript upsert
   */
  export type TranscriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The filter to search for the Transcript to update in case it exists.
     */
    where: TranscriptWhereUniqueInput
    /**
     * In case the Transcript found by the `where` argument doesn't exist, create a new Transcript with this data.
     */
    create: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
    /**
     * In case the Transcript was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
  }

  /**
   * Transcript delete
   */
  export type TranscriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter which Transcript to delete.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript deleteMany
   */
  export type TranscriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcripts to delete
     */
    where?: TranscriptWhereInput
  }

  /**
   * Transcript without action
   */
  export type TranscriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    rewardAmount: number | null
  }

  export type ReferralSumAggregateOutputType = {
    rewardAmount: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    code: string | null
    status: string | null
    rewardAmount: number | null
    rewardCurrency: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    code: string | null
    status: string | null
    rewardAmount: number | null
    rewardCurrency: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    refereeId: number
    code: number
    status: number
    rewardAmount: number
    rewardCurrency: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    rewardAmount?: true
  }

  export type ReferralSumAggregateInputType = {
    rewardAmount?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    code?: true
    status?: true
    rewardAmount?: true
    rewardCurrency?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    code?: true
    status?: true
    rewardAmount?: true
    rewardCurrency?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    code?: true
    status?: true
    rewardAmount?: true
    rewardCurrency?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerId: string
    refereeId: string | null
    code: string
    status: string
    rewardAmount: number
    rewardCurrency: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    code?: boolean
    status?: boolean
    rewardAmount?: boolean
    rewardCurrency?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    code?: boolean
    status?: boolean
    rewardAmount?: boolean
    rewardCurrency?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    code?: boolean
    status?: boolean
    rewardAmount?: boolean
    rewardCurrency?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      refereeId: string | null
      code: string
      status: string
      rewardAmount: number
      rewardCurrency: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly refereeId: FieldRef<"Referral", 'String'>
    readonly code: FieldRef<"Referral", 'String'>
    readonly status: FieldRef<"Referral", 'String'>
    readonly rewardAmount: FieldRef<"Referral", 'Float'>
    readonly rewardCurrency: FieldRef<"Referral", 'String'>
    readonly expiresAt: FieldRef<"Referral", 'DateTime'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
    readonly updatedAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model RewardTransaction
   */

  export type AggregateRewardTransaction = {
    _count: RewardTransactionCountAggregateOutputType | null
    _avg: RewardTransactionAvgAggregateOutputType | null
    _sum: RewardTransactionSumAggregateOutputType | null
    _min: RewardTransactionMinAggregateOutputType | null
    _max: RewardTransactionMaxAggregateOutputType | null
  }

  export type RewardTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type RewardTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type RewardTransactionMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    amount: number | null
    status: string | null
    sourcePaymentId: string | null
    holdEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardTransactionMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    amount: number | null
    status: string | null
    sourcePaymentId: string | null
    holdEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardTransactionCountAggregateOutputType = {
    id: number
    referrerId: number
    refereeId: number
    amount: number
    status: number
    sourcePaymentId: number
    holdEndsAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type RewardTransactionSumAggregateInputType = {
    amount?: true
  }

  export type RewardTransactionMinAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    amount?: true
    status?: true
    sourcePaymentId?: true
    holdEndsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardTransactionMaxAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    amount?: true
    status?: true
    sourcePaymentId?: true
    holdEndsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardTransactionCountAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    amount?: true
    status?: true
    sourcePaymentId?: true
    holdEndsAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardTransaction to aggregate.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardTransactions
    **/
    _count?: true | RewardTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardTransactionMaxAggregateInputType
  }

  export type GetRewardTransactionAggregateType<T extends RewardTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardTransaction[P]>
      : GetScalarType<T[P], AggregateRewardTransaction[P]>
  }




  export type RewardTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardTransactionWhereInput
    orderBy?: RewardTransactionOrderByWithAggregationInput | RewardTransactionOrderByWithAggregationInput[]
    by: RewardTransactionScalarFieldEnum[] | RewardTransactionScalarFieldEnum
    having?: RewardTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardTransactionCountAggregateInputType | true
    _avg?: RewardTransactionAvgAggregateInputType
    _sum?: RewardTransactionSumAggregateInputType
    _min?: RewardTransactionMinAggregateInputType
    _max?: RewardTransactionMaxAggregateInputType
  }

  export type RewardTransactionGroupByOutputType = {
    id: string
    referrerId: string
    refereeId: string | null
    amount: number
    status: string
    sourcePaymentId: string | null
    holdEndsAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RewardTransactionCountAggregateOutputType | null
    _avg: RewardTransactionAvgAggregateOutputType | null
    _sum: RewardTransactionSumAggregateOutputType | null
    _min: RewardTransactionMinAggregateOutputType | null
    _max: RewardTransactionMaxAggregateOutputType | null
  }

  type GetRewardTransactionGroupByPayload<T extends RewardTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], RewardTransactionGroupByOutputType[P]>
        }
      >
    >


  export type RewardTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    amount?: boolean
    status?: boolean
    sourcePaymentId?: boolean
    holdEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardTransaction"]>

  export type RewardTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    amount?: boolean
    status?: boolean
    sourcePaymentId?: boolean
    holdEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardTransaction"]>

  export type RewardTransactionSelectScalar = {
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    amount?: boolean
    status?: boolean
    sourcePaymentId?: boolean
    holdEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RewardTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RewardTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RewardTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardTransaction"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      refereeId: string | null
      amount: number
      status: string
      sourcePaymentId: string | null
      holdEndsAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rewardTransaction"]>
    composites: {}
  }

  type RewardTransactionGetPayload<S extends boolean | null | undefined | RewardTransactionDefaultArgs> = $Result.GetResult<Prisma.$RewardTransactionPayload, S>

  type RewardTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RewardTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RewardTransactionCountAggregateInputType | true
    }

  export interface RewardTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardTransaction'], meta: { name: 'RewardTransaction' } }
    /**
     * Find zero or one RewardTransaction that matches the filter.
     * @param {RewardTransactionFindUniqueArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardTransactionFindUniqueArgs>(args: SelectSubset<T, RewardTransactionFindUniqueArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RewardTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RewardTransactionFindUniqueOrThrowArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RewardTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionFindFirstArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardTransactionFindFirstArgs>(args?: SelectSubset<T, RewardTransactionFindFirstArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RewardTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionFindFirstOrThrowArgs} args - Arguments to find a RewardTransaction
     * @example
     * // Get one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RewardTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardTransactions
     * const rewardTransactions = await prisma.rewardTransaction.findMany()
     * 
     * // Get first 10 RewardTransactions
     * const rewardTransactions = await prisma.rewardTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardTransactionWithIdOnly = await prisma.rewardTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardTransactionFindManyArgs>(args?: SelectSubset<T, RewardTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RewardTransaction.
     * @param {RewardTransactionCreateArgs} args - Arguments to create a RewardTransaction.
     * @example
     * // Create one RewardTransaction
     * const RewardTransaction = await prisma.rewardTransaction.create({
     *   data: {
     *     // ... data to create a RewardTransaction
     *   }
     * })
     * 
     */
    create<T extends RewardTransactionCreateArgs>(args: SelectSubset<T, RewardTransactionCreateArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RewardTransactions.
     * @param {RewardTransactionCreateManyArgs} args - Arguments to create many RewardTransactions.
     * @example
     * // Create many RewardTransactions
     * const rewardTransaction = await prisma.rewardTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardTransactionCreateManyArgs>(args?: SelectSubset<T, RewardTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardTransactions and returns the data saved in the database.
     * @param {RewardTransactionCreateManyAndReturnArgs} args - Arguments to create many RewardTransactions.
     * @example
     * // Create many RewardTransactions
     * const rewardTransaction = await prisma.rewardTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardTransactions and only return the `id`
     * const rewardTransactionWithIdOnly = await prisma.rewardTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RewardTransaction.
     * @param {RewardTransactionDeleteArgs} args - Arguments to delete one RewardTransaction.
     * @example
     * // Delete one RewardTransaction
     * const RewardTransaction = await prisma.rewardTransaction.delete({
     *   where: {
     *     // ... filter to delete one RewardTransaction
     *   }
     * })
     * 
     */
    delete<T extends RewardTransactionDeleteArgs>(args: SelectSubset<T, RewardTransactionDeleteArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RewardTransaction.
     * @param {RewardTransactionUpdateArgs} args - Arguments to update one RewardTransaction.
     * @example
     * // Update one RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardTransactionUpdateArgs>(args: SelectSubset<T, RewardTransactionUpdateArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RewardTransactions.
     * @param {RewardTransactionDeleteManyArgs} args - Arguments to filter RewardTransactions to delete.
     * @example
     * // Delete a few RewardTransactions
     * const { count } = await prisma.rewardTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardTransactionDeleteManyArgs>(args?: SelectSubset<T, RewardTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardTransactions
     * const rewardTransaction = await prisma.rewardTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardTransactionUpdateManyArgs>(args: SelectSubset<T, RewardTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RewardTransaction.
     * @param {RewardTransactionUpsertArgs} args - Arguments to update or create a RewardTransaction.
     * @example
     * // Update or create a RewardTransaction
     * const rewardTransaction = await prisma.rewardTransaction.upsert({
     *   create: {
     *     // ... data to create a RewardTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardTransaction we want to update
     *   }
     * })
     */
    upsert<T extends RewardTransactionUpsertArgs>(args: SelectSubset<T, RewardTransactionUpsertArgs<ExtArgs>>): Prisma__RewardTransactionClient<$Result.GetResult<Prisma.$RewardTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RewardTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionCountArgs} args - Arguments to filter RewardTransactions to count.
     * @example
     * // Count the number of RewardTransactions
     * const count = await prisma.rewardTransaction.count({
     *   where: {
     *     // ... the filter for the RewardTransactions we want to count
     *   }
     * })
    **/
    count<T extends RewardTransactionCountArgs>(
      args?: Subset<T, RewardTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardTransactionAggregateArgs>(args: Subset<T, RewardTransactionAggregateArgs>): Prisma.PrismaPromise<GetRewardTransactionAggregateType<T>>

    /**
     * Group by RewardTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardTransactionGroupByArgs['orderBy'] }
        : { orderBy?: RewardTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardTransaction model
   */
  readonly fields: RewardTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardTransaction model
   */ 
  interface RewardTransactionFieldRefs {
    readonly id: FieldRef<"RewardTransaction", 'String'>
    readonly referrerId: FieldRef<"RewardTransaction", 'String'>
    readonly refereeId: FieldRef<"RewardTransaction", 'String'>
    readonly amount: FieldRef<"RewardTransaction", 'Float'>
    readonly status: FieldRef<"RewardTransaction", 'String'>
    readonly sourcePaymentId: FieldRef<"RewardTransaction", 'String'>
    readonly holdEndsAt: FieldRef<"RewardTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"RewardTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"RewardTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardTransaction findUnique
   */
  export type RewardTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction findUniqueOrThrow
   */
  export type RewardTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction findFirst
   */
  export type RewardTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardTransactions.
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardTransactions.
     */
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * RewardTransaction findFirstOrThrow
   */
  export type RewardTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransaction to fetch.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardTransactions.
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardTransactions.
     */
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * RewardTransaction findMany
   */
  export type RewardTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which RewardTransactions to fetch.
     */
    where?: RewardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardTransactions to fetch.
     */
    orderBy?: RewardTransactionOrderByWithRelationInput | RewardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardTransactions.
     */
    cursor?: RewardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardTransactions.
     */
    skip?: number
    distinct?: RewardTransactionScalarFieldEnum | RewardTransactionScalarFieldEnum[]
  }

  /**
   * RewardTransaction create
   */
  export type RewardTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardTransaction.
     */
    data: XOR<RewardTransactionCreateInput, RewardTransactionUncheckedCreateInput>
  }

  /**
   * RewardTransaction createMany
   */
  export type RewardTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardTransactions.
     */
    data: RewardTransactionCreateManyInput | RewardTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardTransaction createManyAndReturn
   */
  export type RewardTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RewardTransactions.
     */
    data: RewardTransactionCreateManyInput | RewardTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardTransaction update
   */
  export type RewardTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardTransaction.
     */
    data: XOR<RewardTransactionUpdateInput, RewardTransactionUncheckedUpdateInput>
    /**
     * Choose, which RewardTransaction to update.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction updateMany
   */
  export type RewardTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardTransactions.
     */
    data: XOR<RewardTransactionUpdateManyMutationInput, RewardTransactionUncheckedUpdateManyInput>
    /**
     * Filter which RewardTransactions to update
     */
    where?: RewardTransactionWhereInput
  }

  /**
   * RewardTransaction upsert
   */
  export type RewardTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardTransaction to update in case it exists.
     */
    where: RewardTransactionWhereUniqueInput
    /**
     * In case the RewardTransaction found by the `where` argument doesn't exist, create a new RewardTransaction with this data.
     */
    create: XOR<RewardTransactionCreateInput, RewardTransactionUncheckedCreateInput>
    /**
     * In case the RewardTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardTransactionUpdateInput, RewardTransactionUncheckedUpdateInput>
  }

  /**
   * RewardTransaction delete
   */
  export type RewardTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
    /**
     * Filter which RewardTransaction to delete.
     */
    where: RewardTransactionWhereUniqueInput
  }

  /**
   * RewardTransaction deleteMany
   */
  export type RewardTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardTransactions to delete
     */
    where?: RewardTransactionWhereInput
  }

  /**
   * RewardTransaction without action
   */
  export type RewardTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardTransaction
     */
    select?: RewardTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardTransactionInclude<ExtArgs> | null
  }


  /**
   * Model ToolExecutionAudit
   */

  export type AggregateToolExecutionAudit = {
    _count: ToolExecutionAuditCountAggregateOutputType | null
    _avg: ToolExecutionAuditAvgAggregateOutputType | null
    _sum: ToolExecutionAuditSumAggregateOutputType | null
    _min: ToolExecutionAuditMinAggregateOutputType | null
    _max: ToolExecutionAuditMaxAggregateOutputType | null
  }

  export type ToolExecutionAuditAvgAggregateOutputType = {
    executionTimeMs: number | null
  }

  export type ToolExecutionAuditSumAggregateOutputType = {
    executionTimeMs: number | null
  }

  export type ToolExecutionAuditMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    toolName: string | null
    toolInput: string | null
    toolOutput: string | null
    status: string | null
    errorMessage: string | null
    executionTimeMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ToolExecutionAuditMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    userId: string | null
    toolName: string | null
    toolInput: string | null
    toolOutput: string | null
    status: string | null
    errorMessage: string | null
    executionTimeMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ToolExecutionAuditCountAggregateOutputType = {
    id: number
    agentId: number
    userId: number
    toolName: number
    toolInput: number
    toolOutput: number
    status: number
    errorMessage: number
    executionTimeMs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ToolExecutionAuditAvgAggregateInputType = {
    executionTimeMs?: true
  }

  export type ToolExecutionAuditSumAggregateInputType = {
    executionTimeMs?: true
  }

  export type ToolExecutionAuditMinAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    toolName?: true
    toolInput?: true
    toolOutput?: true
    status?: true
    errorMessage?: true
    executionTimeMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ToolExecutionAuditMaxAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    toolName?: true
    toolInput?: true
    toolOutput?: true
    status?: true
    errorMessage?: true
    executionTimeMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ToolExecutionAuditCountAggregateInputType = {
    id?: true
    agentId?: true
    userId?: true
    toolName?: true
    toolInput?: true
    toolOutput?: true
    status?: true
    errorMessage?: true
    executionTimeMs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ToolExecutionAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToolExecutionAudit to aggregate.
     */
    where?: ToolExecutionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutionAudits to fetch.
     */
    orderBy?: ToolExecutionAuditOrderByWithRelationInput | ToolExecutionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ToolExecutionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutionAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ToolExecutionAudits
    **/
    _count?: true | ToolExecutionAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ToolExecutionAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ToolExecutionAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToolExecutionAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToolExecutionAuditMaxAggregateInputType
  }

  export type GetToolExecutionAuditAggregateType<T extends ToolExecutionAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateToolExecutionAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToolExecutionAudit[P]>
      : GetScalarType<T[P], AggregateToolExecutionAudit[P]>
  }




  export type ToolExecutionAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToolExecutionAuditWhereInput
    orderBy?: ToolExecutionAuditOrderByWithAggregationInput | ToolExecutionAuditOrderByWithAggregationInput[]
    by: ToolExecutionAuditScalarFieldEnum[] | ToolExecutionAuditScalarFieldEnum
    having?: ToolExecutionAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToolExecutionAuditCountAggregateInputType | true
    _avg?: ToolExecutionAuditAvgAggregateInputType
    _sum?: ToolExecutionAuditSumAggregateInputType
    _min?: ToolExecutionAuditMinAggregateInputType
    _max?: ToolExecutionAuditMaxAggregateInputType
  }

  export type ToolExecutionAuditGroupByOutputType = {
    id: string
    agentId: string
    userId: string | null
    toolName: string
    toolInput: string
    toolOutput: string | null
    status: string
    errorMessage: string | null
    executionTimeMs: number
    createdAt: Date
    updatedAt: Date
    _count: ToolExecutionAuditCountAggregateOutputType | null
    _avg: ToolExecutionAuditAvgAggregateOutputType | null
    _sum: ToolExecutionAuditSumAggregateOutputType | null
    _min: ToolExecutionAuditMinAggregateOutputType | null
    _max: ToolExecutionAuditMaxAggregateOutputType | null
  }

  type GetToolExecutionAuditGroupByPayload<T extends ToolExecutionAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ToolExecutionAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ToolExecutionAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ToolExecutionAuditGroupByOutputType[P]>
            : GetScalarType<T[P], ToolExecutionAuditGroupByOutputType[P]>
        }
      >
    >


  export type ToolExecutionAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    status?: boolean
    errorMessage?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toolExecutionAudit"]>

  export type ToolExecutionAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    userId?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    status?: boolean
    errorMessage?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toolExecutionAudit"]>

  export type ToolExecutionAuditSelectScalar = {
    id?: boolean
    agentId?: boolean
    userId?: boolean
    toolName?: boolean
    toolInput?: boolean
    toolOutput?: boolean
    status?: boolean
    errorMessage?: boolean
    executionTimeMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ToolExecutionAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type ToolExecutionAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $ToolExecutionAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ToolExecutionAudit"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      userId: string | null
      toolName: string
      toolInput: string
      toolOutput: string | null
      status: string
      errorMessage: string | null
      executionTimeMs: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["toolExecutionAudit"]>
    composites: {}
  }

  type ToolExecutionAuditGetPayload<S extends boolean | null | undefined | ToolExecutionAuditDefaultArgs> = $Result.GetResult<Prisma.$ToolExecutionAuditPayload, S>

  type ToolExecutionAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ToolExecutionAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ToolExecutionAuditCountAggregateInputType | true
    }

  export interface ToolExecutionAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ToolExecutionAudit'], meta: { name: 'ToolExecutionAudit' } }
    /**
     * Find zero or one ToolExecutionAudit that matches the filter.
     * @param {ToolExecutionAuditFindUniqueArgs} args - Arguments to find a ToolExecutionAudit
     * @example
     * // Get one ToolExecutionAudit
     * const toolExecutionAudit = await prisma.toolExecutionAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ToolExecutionAuditFindUniqueArgs>(args: SelectSubset<T, ToolExecutionAuditFindUniqueArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ToolExecutionAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ToolExecutionAuditFindUniqueOrThrowArgs} args - Arguments to find a ToolExecutionAudit
     * @example
     * // Get one ToolExecutionAudit
     * const toolExecutionAudit = await prisma.toolExecutionAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ToolExecutionAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, ToolExecutionAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ToolExecutionAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAuditFindFirstArgs} args - Arguments to find a ToolExecutionAudit
     * @example
     * // Get one ToolExecutionAudit
     * const toolExecutionAudit = await prisma.toolExecutionAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ToolExecutionAuditFindFirstArgs>(args?: SelectSubset<T, ToolExecutionAuditFindFirstArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ToolExecutionAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAuditFindFirstOrThrowArgs} args - Arguments to find a ToolExecutionAudit
     * @example
     * // Get one ToolExecutionAudit
     * const toolExecutionAudit = await prisma.toolExecutionAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ToolExecutionAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, ToolExecutionAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ToolExecutionAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ToolExecutionAudits
     * const toolExecutionAudits = await prisma.toolExecutionAudit.findMany()
     * 
     * // Get first 10 ToolExecutionAudits
     * const toolExecutionAudits = await prisma.toolExecutionAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const toolExecutionAuditWithIdOnly = await prisma.toolExecutionAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ToolExecutionAuditFindManyArgs>(args?: SelectSubset<T, ToolExecutionAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ToolExecutionAudit.
     * @param {ToolExecutionAuditCreateArgs} args - Arguments to create a ToolExecutionAudit.
     * @example
     * // Create one ToolExecutionAudit
     * const ToolExecutionAudit = await prisma.toolExecutionAudit.create({
     *   data: {
     *     // ... data to create a ToolExecutionAudit
     *   }
     * })
     * 
     */
    create<T extends ToolExecutionAuditCreateArgs>(args: SelectSubset<T, ToolExecutionAuditCreateArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ToolExecutionAudits.
     * @param {ToolExecutionAuditCreateManyArgs} args - Arguments to create many ToolExecutionAudits.
     * @example
     * // Create many ToolExecutionAudits
     * const toolExecutionAudit = await prisma.toolExecutionAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ToolExecutionAuditCreateManyArgs>(args?: SelectSubset<T, ToolExecutionAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ToolExecutionAudits and returns the data saved in the database.
     * @param {ToolExecutionAuditCreateManyAndReturnArgs} args - Arguments to create many ToolExecutionAudits.
     * @example
     * // Create many ToolExecutionAudits
     * const toolExecutionAudit = await prisma.toolExecutionAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ToolExecutionAudits and only return the `id`
     * const toolExecutionAuditWithIdOnly = await prisma.toolExecutionAudit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ToolExecutionAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, ToolExecutionAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ToolExecutionAudit.
     * @param {ToolExecutionAuditDeleteArgs} args - Arguments to delete one ToolExecutionAudit.
     * @example
     * // Delete one ToolExecutionAudit
     * const ToolExecutionAudit = await prisma.toolExecutionAudit.delete({
     *   where: {
     *     // ... filter to delete one ToolExecutionAudit
     *   }
     * })
     * 
     */
    delete<T extends ToolExecutionAuditDeleteArgs>(args: SelectSubset<T, ToolExecutionAuditDeleteArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ToolExecutionAudit.
     * @param {ToolExecutionAuditUpdateArgs} args - Arguments to update one ToolExecutionAudit.
     * @example
     * // Update one ToolExecutionAudit
     * const toolExecutionAudit = await prisma.toolExecutionAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ToolExecutionAuditUpdateArgs>(args: SelectSubset<T, ToolExecutionAuditUpdateArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ToolExecutionAudits.
     * @param {ToolExecutionAuditDeleteManyArgs} args - Arguments to filter ToolExecutionAudits to delete.
     * @example
     * // Delete a few ToolExecutionAudits
     * const { count } = await prisma.toolExecutionAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ToolExecutionAuditDeleteManyArgs>(args?: SelectSubset<T, ToolExecutionAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ToolExecutionAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ToolExecutionAudits
     * const toolExecutionAudit = await prisma.toolExecutionAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ToolExecutionAuditUpdateManyArgs>(args: SelectSubset<T, ToolExecutionAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ToolExecutionAudit.
     * @param {ToolExecutionAuditUpsertArgs} args - Arguments to update or create a ToolExecutionAudit.
     * @example
     * // Update or create a ToolExecutionAudit
     * const toolExecutionAudit = await prisma.toolExecutionAudit.upsert({
     *   create: {
     *     // ... data to create a ToolExecutionAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ToolExecutionAudit we want to update
     *   }
     * })
     */
    upsert<T extends ToolExecutionAuditUpsertArgs>(args: SelectSubset<T, ToolExecutionAuditUpsertArgs<ExtArgs>>): Prisma__ToolExecutionAuditClient<$Result.GetResult<Prisma.$ToolExecutionAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ToolExecutionAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAuditCountArgs} args - Arguments to filter ToolExecutionAudits to count.
     * @example
     * // Count the number of ToolExecutionAudits
     * const count = await prisma.toolExecutionAudit.count({
     *   where: {
     *     // ... the filter for the ToolExecutionAudits we want to count
     *   }
     * })
    **/
    count<T extends ToolExecutionAuditCountArgs>(
      args?: Subset<T, ToolExecutionAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToolExecutionAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ToolExecutionAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToolExecutionAuditAggregateArgs>(args: Subset<T, ToolExecutionAuditAggregateArgs>): Prisma.PrismaPromise<GetToolExecutionAuditAggregateType<T>>

    /**
     * Group by ToolExecutionAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToolExecutionAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToolExecutionAuditGroupByArgs['orderBy'] }
        : { orderBy?: ToolExecutionAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToolExecutionAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToolExecutionAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ToolExecutionAudit model
   */
  readonly fields: ToolExecutionAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ToolExecutionAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ToolExecutionAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ToolExecutionAudit model
   */ 
  interface ToolExecutionAuditFieldRefs {
    readonly id: FieldRef<"ToolExecutionAudit", 'String'>
    readonly agentId: FieldRef<"ToolExecutionAudit", 'String'>
    readonly userId: FieldRef<"ToolExecutionAudit", 'String'>
    readonly toolName: FieldRef<"ToolExecutionAudit", 'String'>
    readonly toolInput: FieldRef<"ToolExecutionAudit", 'String'>
    readonly toolOutput: FieldRef<"ToolExecutionAudit", 'String'>
    readonly status: FieldRef<"ToolExecutionAudit", 'String'>
    readonly errorMessage: FieldRef<"ToolExecutionAudit", 'String'>
    readonly executionTimeMs: FieldRef<"ToolExecutionAudit", 'Int'>
    readonly createdAt: FieldRef<"ToolExecutionAudit", 'DateTime'>
    readonly updatedAt: FieldRef<"ToolExecutionAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ToolExecutionAudit findUnique
   */
  export type ToolExecutionAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecutionAudit to fetch.
     */
    where: ToolExecutionAuditWhereUniqueInput
  }

  /**
   * ToolExecutionAudit findUniqueOrThrow
   */
  export type ToolExecutionAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecutionAudit to fetch.
     */
    where: ToolExecutionAuditWhereUniqueInput
  }

  /**
   * ToolExecutionAudit findFirst
   */
  export type ToolExecutionAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecutionAudit to fetch.
     */
    where?: ToolExecutionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutionAudits to fetch.
     */
    orderBy?: ToolExecutionAuditOrderByWithRelationInput | ToolExecutionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToolExecutionAudits.
     */
    cursor?: ToolExecutionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutionAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToolExecutionAudits.
     */
    distinct?: ToolExecutionAuditScalarFieldEnum | ToolExecutionAuditScalarFieldEnum[]
  }

  /**
   * ToolExecutionAudit findFirstOrThrow
   */
  export type ToolExecutionAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecutionAudit to fetch.
     */
    where?: ToolExecutionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutionAudits to fetch.
     */
    orderBy?: ToolExecutionAuditOrderByWithRelationInput | ToolExecutionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToolExecutionAudits.
     */
    cursor?: ToolExecutionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutionAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToolExecutionAudits.
     */
    distinct?: ToolExecutionAuditScalarFieldEnum | ToolExecutionAuditScalarFieldEnum[]
  }

  /**
   * ToolExecutionAudit findMany
   */
  export type ToolExecutionAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecutionAudits to fetch.
     */
    where?: ToolExecutionAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutionAudits to fetch.
     */
    orderBy?: ToolExecutionAuditOrderByWithRelationInput | ToolExecutionAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ToolExecutionAudits.
     */
    cursor?: ToolExecutionAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutionAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutionAudits.
     */
    skip?: number
    distinct?: ToolExecutionAuditScalarFieldEnum | ToolExecutionAuditScalarFieldEnum[]
  }

  /**
   * ToolExecutionAudit create
   */
  export type ToolExecutionAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a ToolExecutionAudit.
     */
    data: XOR<ToolExecutionAuditCreateInput, ToolExecutionAuditUncheckedCreateInput>
  }

  /**
   * ToolExecutionAudit createMany
   */
  export type ToolExecutionAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ToolExecutionAudits.
     */
    data: ToolExecutionAuditCreateManyInput | ToolExecutionAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ToolExecutionAudit createManyAndReturn
   */
  export type ToolExecutionAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ToolExecutionAudits.
     */
    data: ToolExecutionAuditCreateManyInput | ToolExecutionAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ToolExecutionAudit update
   */
  export type ToolExecutionAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a ToolExecutionAudit.
     */
    data: XOR<ToolExecutionAuditUpdateInput, ToolExecutionAuditUncheckedUpdateInput>
    /**
     * Choose, which ToolExecutionAudit to update.
     */
    where: ToolExecutionAuditWhereUniqueInput
  }

  /**
   * ToolExecutionAudit updateMany
   */
  export type ToolExecutionAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ToolExecutionAudits.
     */
    data: XOR<ToolExecutionAuditUpdateManyMutationInput, ToolExecutionAuditUncheckedUpdateManyInput>
    /**
     * Filter which ToolExecutionAudits to update
     */
    where?: ToolExecutionAuditWhereInput
  }

  /**
   * ToolExecutionAudit upsert
   */
  export type ToolExecutionAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the ToolExecutionAudit to update in case it exists.
     */
    where: ToolExecutionAuditWhereUniqueInput
    /**
     * In case the ToolExecutionAudit found by the `where` argument doesn't exist, create a new ToolExecutionAudit with this data.
     */
    create: XOR<ToolExecutionAuditCreateInput, ToolExecutionAuditUncheckedCreateInput>
    /**
     * In case the ToolExecutionAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ToolExecutionAuditUpdateInput, ToolExecutionAuditUncheckedUpdateInput>
  }

  /**
   * ToolExecutionAudit delete
   */
  export type ToolExecutionAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
    /**
     * Filter which ToolExecutionAudit to delete.
     */
    where: ToolExecutionAuditWhereUniqueInput
  }

  /**
   * ToolExecutionAudit deleteMany
   */
  export type ToolExecutionAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToolExecutionAudits to delete
     */
    where?: ToolExecutionAuditWhereInput
  }

  /**
   * ToolExecutionAudit without action
   */
  export type ToolExecutionAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionAudit
     */
    select?: ToolExecutionAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionAuditInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    agentId: string | null
    name: string | null
    phone: string | null
    email: string | null
    summary: string | null
    isBooked: boolean | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    agentId: string | null
    name: string | null
    phone: string | null
    email: string | null
    summary: string | null
    isBooked: boolean | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    tenantId: number
    agentId: number
    name: number
    phone: number
    email: number
    summary: number
    isBooked: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    tenantId?: true
    agentId?: true
    name?: true
    phone?: true
    email?: true
    summary?: true
    isBooked?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    tenantId?: true
    agentId?: true
    name?: true
    phone?: true
    email?: true
    summary?: true
    isBooked?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    tenantId?: true
    agentId?: true
    name?: true
    phone?: true
    email?: true
    summary?: true
    isBooked?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    tenantId: string
    agentId: string
    name: string
    phone: string
    email: string | null
    summary: string | null
    isBooked: boolean
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    agentId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    summary?: boolean
    isBooked?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    agentId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    summary?: boolean
    isBooked?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    tenantId?: boolean
    agentId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    summary?: boolean
    isBooked?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      agentId: string
      name: string
      phone: string
      email: string | null
      summary: string | null
      isBooked: boolean
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly tenantId: FieldRef<"Lead", 'String'>
    readonly agentId: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly summary: FieldRef<"Lead", 'String'>
    readonly isBooked: FieldRef<"Lead", 'Boolean'>
    readonly metadata: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model GoogleAuthConfig
   */

  export type AggregateGoogleAuthConfig = {
    _count: GoogleAuthConfigCountAggregateOutputType | null
    _min: GoogleAuthConfigMinAggregateOutputType | null
    _max: GoogleAuthConfigMaxAggregateOutputType | null
  }

  export type GoogleAuthConfigMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    clientSecret: string | null
    redirectUri: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoogleAuthConfigMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    clientSecret: string | null
    redirectUri: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoogleAuthConfigCountAggregateOutputType = {
    id: number
    clientId: number
    clientSecret: number
    redirectUri: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoogleAuthConfigMinAggregateInputType = {
    id?: true
    clientId?: true
    clientSecret?: true
    redirectUri?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoogleAuthConfigMaxAggregateInputType = {
    id?: true
    clientId?: true
    clientSecret?: true
    redirectUri?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoogleAuthConfigCountAggregateInputType = {
    id?: true
    clientId?: true
    clientSecret?: true
    redirectUri?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoogleAuthConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAuthConfig to aggregate.
     */
    where?: GoogleAuthConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuthConfigs to fetch.
     */
    orderBy?: GoogleAuthConfigOrderByWithRelationInput | GoogleAuthConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoogleAuthConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAuthConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuthConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoogleAuthConfigs
    **/
    _count?: true | GoogleAuthConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoogleAuthConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoogleAuthConfigMaxAggregateInputType
  }

  export type GetGoogleAuthConfigAggregateType<T extends GoogleAuthConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogleAuthConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogleAuthConfig[P]>
      : GetScalarType<T[P], AggregateGoogleAuthConfig[P]>
  }




  export type GoogleAuthConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoogleAuthConfigWhereInput
    orderBy?: GoogleAuthConfigOrderByWithAggregationInput | GoogleAuthConfigOrderByWithAggregationInput[]
    by: GoogleAuthConfigScalarFieldEnum[] | GoogleAuthConfigScalarFieldEnum
    having?: GoogleAuthConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoogleAuthConfigCountAggregateInputType | true
    _min?: GoogleAuthConfigMinAggregateInputType
    _max?: GoogleAuthConfigMaxAggregateInputType
  }

  export type GoogleAuthConfigGroupByOutputType = {
    id: string
    clientId: string | null
    clientSecret: string | null
    redirectUri: string | null
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: GoogleAuthConfigCountAggregateOutputType | null
    _min: GoogleAuthConfigMinAggregateOutputType | null
    _max: GoogleAuthConfigMaxAggregateOutputType | null
  }

  type GetGoogleAuthConfigGroupByPayload<T extends GoogleAuthConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoogleAuthConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoogleAuthConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoogleAuthConfigGroupByOutputType[P]>
            : GetScalarType<T[P], GoogleAuthConfigGroupByOutputType[P]>
        }
      >
    >


  export type GoogleAuthConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUri?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["googleAuthConfig"]>

  export type GoogleAuthConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUri?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["googleAuthConfig"]>

  export type GoogleAuthConfigSelectScalar = {
    id?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUri?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $GoogleAuthConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoogleAuthConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string | null
      clientSecret: string | null
      redirectUri: string | null
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["googleAuthConfig"]>
    composites: {}
  }

  type GoogleAuthConfigGetPayload<S extends boolean | null | undefined | GoogleAuthConfigDefaultArgs> = $Result.GetResult<Prisma.$GoogleAuthConfigPayload, S>

  type GoogleAuthConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoogleAuthConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoogleAuthConfigCountAggregateInputType | true
    }

  export interface GoogleAuthConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoogleAuthConfig'], meta: { name: 'GoogleAuthConfig' } }
    /**
     * Find zero or one GoogleAuthConfig that matches the filter.
     * @param {GoogleAuthConfigFindUniqueArgs} args - Arguments to find a GoogleAuthConfig
     * @example
     * // Get one GoogleAuthConfig
     * const googleAuthConfig = await prisma.googleAuthConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoogleAuthConfigFindUniqueArgs>(args: SelectSubset<T, GoogleAuthConfigFindUniqueArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoogleAuthConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoogleAuthConfigFindUniqueOrThrowArgs} args - Arguments to find a GoogleAuthConfig
     * @example
     * // Get one GoogleAuthConfig
     * const googleAuthConfig = await prisma.googleAuthConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoogleAuthConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, GoogleAuthConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoogleAuthConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthConfigFindFirstArgs} args - Arguments to find a GoogleAuthConfig
     * @example
     * // Get one GoogleAuthConfig
     * const googleAuthConfig = await prisma.googleAuthConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoogleAuthConfigFindFirstArgs>(args?: SelectSubset<T, GoogleAuthConfigFindFirstArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoogleAuthConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthConfigFindFirstOrThrowArgs} args - Arguments to find a GoogleAuthConfig
     * @example
     * // Get one GoogleAuthConfig
     * const googleAuthConfig = await prisma.googleAuthConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoogleAuthConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, GoogleAuthConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoogleAuthConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoogleAuthConfigs
     * const googleAuthConfigs = await prisma.googleAuthConfig.findMany()
     * 
     * // Get first 10 GoogleAuthConfigs
     * const googleAuthConfigs = await prisma.googleAuthConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const googleAuthConfigWithIdOnly = await prisma.googleAuthConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoogleAuthConfigFindManyArgs>(args?: SelectSubset<T, GoogleAuthConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoogleAuthConfig.
     * @param {GoogleAuthConfigCreateArgs} args - Arguments to create a GoogleAuthConfig.
     * @example
     * // Create one GoogleAuthConfig
     * const GoogleAuthConfig = await prisma.googleAuthConfig.create({
     *   data: {
     *     // ... data to create a GoogleAuthConfig
     *   }
     * })
     * 
     */
    create<T extends GoogleAuthConfigCreateArgs>(args: SelectSubset<T, GoogleAuthConfigCreateArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoogleAuthConfigs.
     * @param {GoogleAuthConfigCreateManyArgs} args - Arguments to create many GoogleAuthConfigs.
     * @example
     * // Create many GoogleAuthConfigs
     * const googleAuthConfig = await prisma.googleAuthConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoogleAuthConfigCreateManyArgs>(args?: SelectSubset<T, GoogleAuthConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoogleAuthConfigs and returns the data saved in the database.
     * @param {GoogleAuthConfigCreateManyAndReturnArgs} args - Arguments to create many GoogleAuthConfigs.
     * @example
     * // Create many GoogleAuthConfigs
     * const googleAuthConfig = await prisma.googleAuthConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoogleAuthConfigs and only return the `id`
     * const googleAuthConfigWithIdOnly = await prisma.googleAuthConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoogleAuthConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, GoogleAuthConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoogleAuthConfig.
     * @param {GoogleAuthConfigDeleteArgs} args - Arguments to delete one GoogleAuthConfig.
     * @example
     * // Delete one GoogleAuthConfig
     * const GoogleAuthConfig = await prisma.googleAuthConfig.delete({
     *   where: {
     *     // ... filter to delete one GoogleAuthConfig
     *   }
     * })
     * 
     */
    delete<T extends GoogleAuthConfigDeleteArgs>(args: SelectSubset<T, GoogleAuthConfigDeleteArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoogleAuthConfig.
     * @param {GoogleAuthConfigUpdateArgs} args - Arguments to update one GoogleAuthConfig.
     * @example
     * // Update one GoogleAuthConfig
     * const googleAuthConfig = await prisma.googleAuthConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoogleAuthConfigUpdateArgs>(args: SelectSubset<T, GoogleAuthConfigUpdateArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoogleAuthConfigs.
     * @param {GoogleAuthConfigDeleteManyArgs} args - Arguments to filter GoogleAuthConfigs to delete.
     * @example
     * // Delete a few GoogleAuthConfigs
     * const { count } = await prisma.googleAuthConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoogleAuthConfigDeleteManyArgs>(args?: SelectSubset<T, GoogleAuthConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleAuthConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoogleAuthConfigs
     * const googleAuthConfig = await prisma.googleAuthConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoogleAuthConfigUpdateManyArgs>(args: SelectSubset<T, GoogleAuthConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoogleAuthConfig.
     * @param {GoogleAuthConfigUpsertArgs} args - Arguments to update or create a GoogleAuthConfig.
     * @example
     * // Update or create a GoogleAuthConfig
     * const googleAuthConfig = await prisma.googleAuthConfig.upsert({
     *   create: {
     *     // ... data to create a GoogleAuthConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoogleAuthConfig we want to update
     *   }
     * })
     */
    upsert<T extends GoogleAuthConfigUpsertArgs>(args: SelectSubset<T, GoogleAuthConfigUpsertArgs<ExtArgs>>): Prisma__GoogleAuthConfigClient<$Result.GetResult<Prisma.$GoogleAuthConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoogleAuthConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthConfigCountArgs} args - Arguments to filter GoogleAuthConfigs to count.
     * @example
     * // Count the number of GoogleAuthConfigs
     * const count = await prisma.googleAuthConfig.count({
     *   where: {
     *     // ... the filter for the GoogleAuthConfigs we want to count
     *   }
     * })
    **/
    count<T extends GoogleAuthConfigCountArgs>(
      args?: Subset<T, GoogleAuthConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoogleAuthConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoogleAuthConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoogleAuthConfigAggregateArgs>(args: Subset<T, GoogleAuthConfigAggregateArgs>): Prisma.PrismaPromise<GetGoogleAuthConfigAggregateType<T>>

    /**
     * Group by GoogleAuthConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoogleAuthConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoogleAuthConfigGroupByArgs['orderBy'] }
        : { orderBy?: GoogleAuthConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoogleAuthConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogleAuthConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoogleAuthConfig model
   */
  readonly fields: GoogleAuthConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoogleAuthConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoogleAuthConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoogleAuthConfig model
   */ 
  interface GoogleAuthConfigFieldRefs {
    readonly id: FieldRef<"GoogleAuthConfig", 'String'>
    readonly clientId: FieldRef<"GoogleAuthConfig", 'String'>
    readonly clientSecret: FieldRef<"GoogleAuthConfig", 'String'>
    readonly redirectUri: FieldRef<"GoogleAuthConfig", 'String'>
    readonly enabled: FieldRef<"GoogleAuthConfig", 'Boolean'>
    readonly createdAt: FieldRef<"GoogleAuthConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"GoogleAuthConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoogleAuthConfig findUnique
   */
  export type GoogleAuthConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * Filter, which GoogleAuthConfig to fetch.
     */
    where: GoogleAuthConfigWhereUniqueInput
  }

  /**
   * GoogleAuthConfig findUniqueOrThrow
   */
  export type GoogleAuthConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * Filter, which GoogleAuthConfig to fetch.
     */
    where: GoogleAuthConfigWhereUniqueInput
  }

  /**
   * GoogleAuthConfig findFirst
   */
  export type GoogleAuthConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * Filter, which GoogleAuthConfig to fetch.
     */
    where?: GoogleAuthConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuthConfigs to fetch.
     */
    orderBy?: GoogleAuthConfigOrderByWithRelationInput | GoogleAuthConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAuthConfigs.
     */
    cursor?: GoogleAuthConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAuthConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuthConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAuthConfigs.
     */
    distinct?: GoogleAuthConfigScalarFieldEnum | GoogleAuthConfigScalarFieldEnum[]
  }

  /**
   * GoogleAuthConfig findFirstOrThrow
   */
  export type GoogleAuthConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * Filter, which GoogleAuthConfig to fetch.
     */
    where?: GoogleAuthConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuthConfigs to fetch.
     */
    orderBy?: GoogleAuthConfigOrderByWithRelationInput | GoogleAuthConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAuthConfigs.
     */
    cursor?: GoogleAuthConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAuthConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuthConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAuthConfigs.
     */
    distinct?: GoogleAuthConfigScalarFieldEnum | GoogleAuthConfigScalarFieldEnum[]
  }

  /**
   * GoogleAuthConfig findMany
   */
  export type GoogleAuthConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * Filter, which GoogleAuthConfigs to fetch.
     */
    where?: GoogleAuthConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuthConfigs to fetch.
     */
    orderBy?: GoogleAuthConfigOrderByWithRelationInput | GoogleAuthConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoogleAuthConfigs.
     */
    cursor?: GoogleAuthConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleAuthConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuthConfigs.
     */
    skip?: number
    distinct?: GoogleAuthConfigScalarFieldEnum | GoogleAuthConfigScalarFieldEnum[]
  }

  /**
   * GoogleAuthConfig create
   */
  export type GoogleAuthConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a GoogleAuthConfig.
     */
    data: XOR<GoogleAuthConfigCreateInput, GoogleAuthConfigUncheckedCreateInput>
  }

  /**
   * GoogleAuthConfig createMany
   */
  export type GoogleAuthConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoogleAuthConfigs.
     */
    data: GoogleAuthConfigCreateManyInput | GoogleAuthConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoogleAuthConfig createManyAndReturn
   */
  export type GoogleAuthConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoogleAuthConfigs.
     */
    data: GoogleAuthConfigCreateManyInput | GoogleAuthConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoogleAuthConfig update
   */
  export type GoogleAuthConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a GoogleAuthConfig.
     */
    data: XOR<GoogleAuthConfigUpdateInput, GoogleAuthConfigUncheckedUpdateInput>
    /**
     * Choose, which GoogleAuthConfig to update.
     */
    where: GoogleAuthConfigWhereUniqueInput
  }

  /**
   * GoogleAuthConfig updateMany
   */
  export type GoogleAuthConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoogleAuthConfigs.
     */
    data: XOR<GoogleAuthConfigUpdateManyMutationInput, GoogleAuthConfigUncheckedUpdateManyInput>
    /**
     * Filter which GoogleAuthConfigs to update
     */
    where?: GoogleAuthConfigWhereInput
  }

  /**
   * GoogleAuthConfig upsert
   */
  export type GoogleAuthConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the GoogleAuthConfig to update in case it exists.
     */
    where: GoogleAuthConfigWhereUniqueInput
    /**
     * In case the GoogleAuthConfig found by the `where` argument doesn't exist, create a new GoogleAuthConfig with this data.
     */
    create: XOR<GoogleAuthConfigCreateInput, GoogleAuthConfigUncheckedCreateInput>
    /**
     * In case the GoogleAuthConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoogleAuthConfigUpdateInput, GoogleAuthConfigUncheckedUpdateInput>
  }

  /**
   * GoogleAuthConfig delete
   */
  export type GoogleAuthConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
    /**
     * Filter which GoogleAuthConfig to delete.
     */
    where: GoogleAuthConfigWhereUniqueInput
  }

  /**
   * GoogleAuthConfig deleteMany
   */
  export type GoogleAuthConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAuthConfigs to delete
     */
    where?: GoogleAuthConfigWhereInput
  }

  /**
   * GoogleAuthConfig without action
   */
  export type GoogleAuthConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuthConfig
     */
    select?: GoogleAuthConfigSelect<ExtArgs> | null
  }


  /**
   * Model SystemEmailConfig
   */

  export type AggregateSystemEmailConfig = {
    _count: SystemEmailConfigCountAggregateOutputType | null
    _min: SystemEmailConfigMinAggregateOutputType | null
    _max: SystemEmailConfigMaxAggregateOutputType | null
  }

  export type SystemEmailConfigMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    imapServer: string | null
    imapPort: string | null
    imapSecurity: string | null
    smtpServer: string | null
    smtpPort: string | null
    smtpSecurity: string | null
    pop3Server: string | null
    pop3Port: string | null
    pop3Security: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemEmailConfigMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    imapServer: string | null
    imapPort: string | null
    imapSecurity: string | null
    smtpServer: string | null
    smtpPort: string | null
    smtpSecurity: string | null
    pop3Server: string | null
    pop3Port: string | null
    pop3Security: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemEmailConfigCountAggregateOutputType = {
    id: number
    username: number
    password: number
    imapServer: number
    imapPort: number
    imapSecurity: number
    smtpServer: number
    smtpPort: number
    smtpSecurity: number
    pop3Server: number
    pop3Port: number
    pop3Security: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemEmailConfigMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    imapServer?: true
    imapPort?: true
    imapSecurity?: true
    smtpServer?: true
    smtpPort?: true
    smtpSecurity?: true
    pop3Server?: true
    pop3Port?: true
    pop3Security?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemEmailConfigMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    imapServer?: true
    imapPort?: true
    imapSecurity?: true
    smtpServer?: true
    smtpPort?: true
    smtpSecurity?: true
    pop3Server?: true
    pop3Port?: true
    pop3Security?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemEmailConfigCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    imapServer?: true
    imapPort?: true
    imapSecurity?: true
    smtpServer?: true
    smtpPort?: true
    smtpSecurity?: true
    pop3Server?: true
    pop3Port?: true
    pop3Security?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemEmailConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemEmailConfig to aggregate.
     */
    where?: SystemEmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemEmailConfigs to fetch.
     */
    orderBy?: SystemEmailConfigOrderByWithRelationInput | SystemEmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemEmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemEmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemEmailConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemEmailConfigs
    **/
    _count?: true | SystemEmailConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemEmailConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemEmailConfigMaxAggregateInputType
  }

  export type GetSystemEmailConfigAggregateType<T extends SystemEmailConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemEmailConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemEmailConfig[P]>
      : GetScalarType<T[P], AggregateSystemEmailConfig[P]>
  }




  export type SystemEmailConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemEmailConfigWhereInput
    orderBy?: SystemEmailConfigOrderByWithAggregationInput | SystemEmailConfigOrderByWithAggregationInput[]
    by: SystemEmailConfigScalarFieldEnum[] | SystemEmailConfigScalarFieldEnum
    having?: SystemEmailConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemEmailConfigCountAggregateInputType | true
    _min?: SystemEmailConfigMinAggregateInputType
    _max?: SystemEmailConfigMaxAggregateInputType
  }

  export type SystemEmailConfigGroupByOutputType = {
    id: string
    username: string | null
    password: string | null
    imapServer: string | null
    imapPort: string | null
    imapSecurity: string | null
    smtpServer: string | null
    smtpPort: string | null
    smtpSecurity: string | null
    pop3Server: string | null
    pop3Port: string | null
    pop3Security: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemEmailConfigCountAggregateOutputType | null
    _min: SystemEmailConfigMinAggregateOutputType | null
    _max: SystemEmailConfigMaxAggregateOutputType | null
  }

  type GetSystemEmailConfigGroupByPayload<T extends SystemEmailConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemEmailConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemEmailConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemEmailConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemEmailConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemEmailConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    imapServer?: boolean
    imapPort?: boolean
    imapSecurity?: boolean
    smtpServer?: boolean
    smtpPort?: boolean
    smtpSecurity?: boolean
    pop3Server?: boolean
    pop3Port?: boolean
    pop3Security?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemEmailConfig"]>

  export type SystemEmailConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    imapServer?: boolean
    imapPort?: boolean
    imapSecurity?: boolean
    smtpServer?: boolean
    smtpPort?: boolean
    smtpSecurity?: boolean
    pop3Server?: boolean
    pop3Port?: boolean
    pop3Security?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemEmailConfig"]>

  export type SystemEmailConfigSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    imapServer?: boolean
    imapPort?: boolean
    imapSecurity?: boolean
    smtpServer?: boolean
    smtpPort?: boolean
    smtpSecurity?: boolean
    pop3Server?: boolean
    pop3Port?: boolean
    pop3Security?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemEmailConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemEmailConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string | null
      password: string | null
      imapServer: string | null
      imapPort: string | null
      imapSecurity: string | null
      smtpServer: string | null
      smtpPort: string | null
      smtpSecurity: string | null
      pop3Server: string | null
      pop3Port: string | null
      pop3Security: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemEmailConfig"]>
    composites: {}
  }

  type SystemEmailConfigGetPayload<S extends boolean | null | undefined | SystemEmailConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemEmailConfigPayload, S>

  type SystemEmailConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemEmailConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemEmailConfigCountAggregateInputType | true
    }

  export interface SystemEmailConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemEmailConfig'], meta: { name: 'SystemEmailConfig' } }
    /**
     * Find zero or one SystemEmailConfig that matches the filter.
     * @param {SystemEmailConfigFindUniqueArgs} args - Arguments to find a SystemEmailConfig
     * @example
     * // Get one SystemEmailConfig
     * const systemEmailConfig = await prisma.systemEmailConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemEmailConfigFindUniqueArgs>(args: SelectSubset<T, SystemEmailConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemEmailConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemEmailConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemEmailConfig
     * @example
     * // Get one SystemEmailConfig
     * const systemEmailConfig = await prisma.systemEmailConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemEmailConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemEmailConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemEmailConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemEmailConfigFindFirstArgs} args - Arguments to find a SystemEmailConfig
     * @example
     * // Get one SystemEmailConfig
     * const systemEmailConfig = await prisma.systemEmailConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemEmailConfigFindFirstArgs>(args?: SelectSubset<T, SystemEmailConfigFindFirstArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemEmailConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemEmailConfigFindFirstOrThrowArgs} args - Arguments to find a SystemEmailConfig
     * @example
     * // Get one SystemEmailConfig
     * const systemEmailConfig = await prisma.systemEmailConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemEmailConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemEmailConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemEmailConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemEmailConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemEmailConfigs
     * const systemEmailConfigs = await prisma.systemEmailConfig.findMany()
     * 
     * // Get first 10 SystemEmailConfigs
     * const systemEmailConfigs = await prisma.systemEmailConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemEmailConfigWithIdOnly = await prisma.systemEmailConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemEmailConfigFindManyArgs>(args?: SelectSubset<T, SystemEmailConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemEmailConfig.
     * @param {SystemEmailConfigCreateArgs} args - Arguments to create a SystemEmailConfig.
     * @example
     * // Create one SystemEmailConfig
     * const SystemEmailConfig = await prisma.systemEmailConfig.create({
     *   data: {
     *     // ... data to create a SystemEmailConfig
     *   }
     * })
     * 
     */
    create<T extends SystemEmailConfigCreateArgs>(args: SelectSubset<T, SystemEmailConfigCreateArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemEmailConfigs.
     * @param {SystemEmailConfigCreateManyArgs} args - Arguments to create many SystemEmailConfigs.
     * @example
     * // Create many SystemEmailConfigs
     * const systemEmailConfig = await prisma.systemEmailConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemEmailConfigCreateManyArgs>(args?: SelectSubset<T, SystemEmailConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemEmailConfigs and returns the data saved in the database.
     * @param {SystemEmailConfigCreateManyAndReturnArgs} args - Arguments to create many SystemEmailConfigs.
     * @example
     * // Create many SystemEmailConfigs
     * const systemEmailConfig = await prisma.systemEmailConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemEmailConfigs and only return the `id`
     * const systemEmailConfigWithIdOnly = await prisma.systemEmailConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemEmailConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemEmailConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemEmailConfig.
     * @param {SystemEmailConfigDeleteArgs} args - Arguments to delete one SystemEmailConfig.
     * @example
     * // Delete one SystemEmailConfig
     * const SystemEmailConfig = await prisma.systemEmailConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemEmailConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemEmailConfigDeleteArgs>(args: SelectSubset<T, SystemEmailConfigDeleteArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemEmailConfig.
     * @param {SystemEmailConfigUpdateArgs} args - Arguments to update one SystemEmailConfig.
     * @example
     * // Update one SystemEmailConfig
     * const systemEmailConfig = await prisma.systemEmailConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemEmailConfigUpdateArgs>(args: SelectSubset<T, SystemEmailConfigUpdateArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemEmailConfigs.
     * @param {SystemEmailConfigDeleteManyArgs} args - Arguments to filter SystemEmailConfigs to delete.
     * @example
     * // Delete a few SystemEmailConfigs
     * const { count } = await prisma.systemEmailConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemEmailConfigDeleteManyArgs>(args?: SelectSubset<T, SystemEmailConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemEmailConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemEmailConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemEmailConfigs
     * const systemEmailConfig = await prisma.systemEmailConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemEmailConfigUpdateManyArgs>(args: SelectSubset<T, SystemEmailConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemEmailConfig.
     * @param {SystemEmailConfigUpsertArgs} args - Arguments to update or create a SystemEmailConfig.
     * @example
     * // Update or create a SystemEmailConfig
     * const systemEmailConfig = await prisma.systemEmailConfig.upsert({
     *   create: {
     *     // ... data to create a SystemEmailConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemEmailConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemEmailConfigUpsertArgs>(args: SelectSubset<T, SystemEmailConfigUpsertArgs<ExtArgs>>): Prisma__SystemEmailConfigClient<$Result.GetResult<Prisma.$SystemEmailConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemEmailConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemEmailConfigCountArgs} args - Arguments to filter SystemEmailConfigs to count.
     * @example
     * // Count the number of SystemEmailConfigs
     * const count = await prisma.systemEmailConfig.count({
     *   where: {
     *     // ... the filter for the SystemEmailConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemEmailConfigCountArgs>(
      args?: Subset<T, SystemEmailConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemEmailConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemEmailConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemEmailConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemEmailConfigAggregateArgs>(args: Subset<T, SystemEmailConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemEmailConfigAggregateType<T>>

    /**
     * Group by SystemEmailConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemEmailConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemEmailConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemEmailConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemEmailConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemEmailConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemEmailConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemEmailConfig model
   */
  readonly fields: SystemEmailConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemEmailConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemEmailConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemEmailConfig model
   */ 
  interface SystemEmailConfigFieldRefs {
    readonly id: FieldRef<"SystemEmailConfig", 'String'>
    readonly username: FieldRef<"SystemEmailConfig", 'String'>
    readonly password: FieldRef<"SystemEmailConfig", 'String'>
    readonly imapServer: FieldRef<"SystemEmailConfig", 'String'>
    readonly imapPort: FieldRef<"SystemEmailConfig", 'String'>
    readonly imapSecurity: FieldRef<"SystemEmailConfig", 'String'>
    readonly smtpServer: FieldRef<"SystemEmailConfig", 'String'>
    readonly smtpPort: FieldRef<"SystemEmailConfig", 'String'>
    readonly smtpSecurity: FieldRef<"SystemEmailConfig", 'String'>
    readonly pop3Server: FieldRef<"SystemEmailConfig", 'String'>
    readonly pop3Port: FieldRef<"SystemEmailConfig", 'String'>
    readonly pop3Security: FieldRef<"SystemEmailConfig", 'String'>
    readonly createdAt: FieldRef<"SystemEmailConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemEmailConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemEmailConfig findUnique
   */
  export type SystemEmailConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemEmailConfig to fetch.
     */
    where: SystemEmailConfigWhereUniqueInput
  }

  /**
   * SystemEmailConfig findUniqueOrThrow
   */
  export type SystemEmailConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemEmailConfig to fetch.
     */
    where: SystemEmailConfigWhereUniqueInput
  }

  /**
   * SystemEmailConfig findFirst
   */
  export type SystemEmailConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemEmailConfig to fetch.
     */
    where?: SystemEmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemEmailConfigs to fetch.
     */
    orderBy?: SystemEmailConfigOrderByWithRelationInput | SystemEmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemEmailConfigs.
     */
    cursor?: SystemEmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemEmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemEmailConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemEmailConfigs.
     */
    distinct?: SystemEmailConfigScalarFieldEnum | SystemEmailConfigScalarFieldEnum[]
  }

  /**
   * SystemEmailConfig findFirstOrThrow
   */
  export type SystemEmailConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemEmailConfig to fetch.
     */
    where?: SystemEmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemEmailConfigs to fetch.
     */
    orderBy?: SystemEmailConfigOrderByWithRelationInput | SystemEmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemEmailConfigs.
     */
    cursor?: SystemEmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemEmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemEmailConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemEmailConfigs.
     */
    distinct?: SystemEmailConfigScalarFieldEnum | SystemEmailConfigScalarFieldEnum[]
  }

  /**
   * SystemEmailConfig findMany
   */
  export type SystemEmailConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemEmailConfigs to fetch.
     */
    where?: SystemEmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemEmailConfigs to fetch.
     */
    orderBy?: SystemEmailConfigOrderByWithRelationInput | SystemEmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemEmailConfigs.
     */
    cursor?: SystemEmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemEmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemEmailConfigs.
     */
    skip?: number
    distinct?: SystemEmailConfigScalarFieldEnum | SystemEmailConfigScalarFieldEnum[]
  }

  /**
   * SystemEmailConfig create
   */
  export type SystemEmailConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemEmailConfig.
     */
    data: XOR<SystemEmailConfigCreateInput, SystemEmailConfigUncheckedCreateInput>
  }

  /**
   * SystemEmailConfig createMany
   */
  export type SystemEmailConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemEmailConfigs.
     */
    data: SystemEmailConfigCreateManyInput | SystemEmailConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemEmailConfig createManyAndReturn
   */
  export type SystemEmailConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemEmailConfigs.
     */
    data: SystemEmailConfigCreateManyInput | SystemEmailConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemEmailConfig update
   */
  export type SystemEmailConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemEmailConfig.
     */
    data: XOR<SystemEmailConfigUpdateInput, SystemEmailConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemEmailConfig to update.
     */
    where: SystemEmailConfigWhereUniqueInput
  }

  /**
   * SystemEmailConfig updateMany
   */
  export type SystemEmailConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemEmailConfigs.
     */
    data: XOR<SystemEmailConfigUpdateManyMutationInput, SystemEmailConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemEmailConfigs to update
     */
    where?: SystemEmailConfigWhereInput
  }

  /**
   * SystemEmailConfig upsert
   */
  export type SystemEmailConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemEmailConfig to update in case it exists.
     */
    where: SystemEmailConfigWhereUniqueInput
    /**
     * In case the SystemEmailConfig found by the `where` argument doesn't exist, create a new SystemEmailConfig with this data.
     */
    create: XOR<SystemEmailConfigCreateInput, SystemEmailConfigUncheckedCreateInput>
    /**
     * In case the SystemEmailConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemEmailConfigUpdateInput, SystemEmailConfigUncheckedUpdateInput>
  }

  /**
   * SystemEmailConfig delete
   */
  export type SystemEmailConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
    /**
     * Filter which SystemEmailConfig to delete.
     */
    where: SystemEmailConfigWhereUniqueInput
  }

  /**
   * SystemEmailConfig deleteMany
   */
  export type SystemEmailConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemEmailConfigs to delete
     */
    where?: SystemEmailConfigWhereInput
  }

  /**
   * SystemEmailConfig without action
   */
  export type SystemEmailConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemEmailConfig
     */
    select?: SystemEmailConfigSelect<ExtArgs> | null
  }


  /**
   * Model StripeConnectConfig
   */

  export type AggregateStripeConnectConfig = {
    _count: StripeConnectConfigCountAggregateOutputType | null
    _avg: StripeConnectConfigAvgAggregateOutputType | null
    _sum: StripeConnectConfigSumAggregateOutputType | null
    _min: StripeConnectConfigMinAggregateOutputType | null
    _max: StripeConnectConfigMaxAggregateOutputType | null
  }

  export type StripeConnectConfigAvgAggregateOutputType = {
    minimumPayout: number | null
  }

  export type StripeConnectConfigSumAggregateOutputType = {
    minimumPayout: number | null
  }

  export type StripeConnectConfigMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    enabled: boolean | null
    minimumPayout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeConnectConfigMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    enabled: boolean | null
    minimumPayout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeConnectConfigCountAggregateOutputType = {
    id: number
    clientId: number
    enabled: number
    minimumPayout: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StripeConnectConfigAvgAggregateInputType = {
    minimumPayout?: true
  }

  export type StripeConnectConfigSumAggregateInputType = {
    minimumPayout?: true
  }

  export type StripeConnectConfigMinAggregateInputType = {
    id?: true
    clientId?: true
    enabled?: true
    minimumPayout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeConnectConfigMaxAggregateInputType = {
    id?: true
    clientId?: true
    enabled?: true
    minimumPayout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeConnectConfigCountAggregateInputType = {
    id?: true
    clientId?: true
    enabled?: true
    minimumPayout?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StripeConnectConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeConnectConfig to aggregate.
     */
    where?: StripeConnectConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConnectConfigs to fetch.
     */
    orderBy?: StripeConnectConfigOrderByWithRelationInput | StripeConnectConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeConnectConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConnectConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConnectConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeConnectConfigs
    **/
    _count?: true | StripeConnectConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StripeConnectConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StripeConnectConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeConnectConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeConnectConfigMaxAggregateInputType
  }

  export type GetStripeConnectConfigAggregateType<T extends StripeConnectConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeConnectConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeConnectConfig[P]>
      : GetScalarType<T[P], AggregateStripeConnectConfig[P]>
  }




  export type StripeConnectConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeConnectConfigWhereInput
    orderBy?: StripeConnectConfigOrderByWithAggregationInput | StripeConnectConfigOrderByWithAggregationInput[]
    by: StripeConnectConfigScalarFieldEnum[] | StripeConnectConfigScalarFieldEnum
    having?: StripeConnectConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeConnectConfigCountAggregateInputType | true
    _avg?: StripeConnectConfigAvgAggregateInputType
    _sum?: StripeConnectConfigSumAggregateInputType
    _min?: StripeConnectConfigMinAggregateInputType
    _max?: StripeConnectConfigMaxAggregateInputType
  }

  export type StripeConnectConfigGroupByOutputType = {
    id: string
    clientId: string | null
    enabled: boolean
    minimumPayout: number
    createdAt: Date
    updatedAt: Date
    _count: StripeConnectConfigCountAggregateOutputType | null
    _avg: StripeConnectConfigAvgAggregateOutputType | null
    _sum: StripeConnectConfigSumAggregateOutputType | null
    _min: StripeConnectConfigMinAggregateOutputType | null
    _max: StripeConnectConfigMaxAggregateOutputType | null
  }

  type GetStripeConnectConfigGroupByPayload<T extends StripeConnectConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeConnectConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeConnectConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeConnectConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StripeConnectConfigGroupByOutputType[P]>
        }
      >
    >


  export type StripeConnectConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    enabled?: boolean
    minimumPayout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stripeConnectConfig"]>

  export type StripeConnectConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    enabled?: boolean
    minimumPayout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stripeConnectConfig"]>

  export type StripeConnectConfigSelectScalar = {
    id?: boolean
    clientId?: boolean
    enabled?: boolean
    minimumPayout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StripeConnectConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeConnectConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string | null
      enabled: boolean
      minimumPayout: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stripeConnectConfig"]>
    composites: {}
  }

  type StripeConnectConfigGetPayload<S extends boolean | null | undefined | StripeConnectConfigDefaultArgs> = $Result.GetResult<Prisma.$StripeConnectConfigPayload, S>

  type StripeConnectConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StripeConnectConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StripeConnectConfigCountAggregateInputType | true
    }

  export interface StripeConnectConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeConnectConfig'], meta: { name: 'StripeConnectConfig' } }
    /**
     * Find zero or one StripeConnectConfig that matches the filter.
     * @param {StripeConnectConfigFindUniqueArgs} args - Arguments to find a StripeConnectConfig
     * @example
     * // Get one StripeConnectConfig
     * const stripeConnectConfig = await prisma.stripeConnectConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StripeConnectConfigFindUniqueArgs>(args: SelectSubset<T, StripeConnectConfigFindUniqueArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StripeConnectConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StripeConnectConfigFindUniqueOrThrowArgs} args - Arguments to find a StripeConnectConfig
     * @example
     * // Get one StripeConnectConfig
     * const stripeConnectConfig = await prisma.stripeConnectConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StripeConnectConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StripeConnectConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StripeConnectConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConnectConfigFindFirstArgs} args - Arguments to find a StripeConnectConfig
     * @example
     * // Get one StripeConnectConfig
     * const stripeConnectConfig = await prisma.stripeConnectConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StripeConnectConfigFindFirstArgs>(args?: SelectSubset<T, StripeConnectConfigFindFirstArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StripeConnectConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConnectConfigFindFirstOrThrowArgs} args - Arguments to find a StripeConnectConfig
     * @example
     * // Get one StripeConnectConfig
     * const stripeConnectConfig = await prisma.stripeConnectConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StripeConnectConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StripeConnectConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StripeConnectConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConnectConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeConnectConfigs
     * const stripeConnectConfigs = await prisma.stripeConnectConfig.findMany()
     * 
     * // Get first 10 StripeConnectConfigs
     * const stripeConnectConfigs = await prisma.stripeConnectConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeConnectConfigWithIdOnly = await prisma.stripeConnectConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StripeConnectConfigFindManyArgs>(args?: SelectSubset<T, StripeConnectConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StripeConnectConfig.
     * @param {StripeConnectConfigCreateArgs} args - Arguments to create a StripeConnectConfig.
     * @example
     * // Create one StripeConnectConfig
     * const StripeConnectConfig = await prisma.stripeConnectConfig.create({
     *   data: {
     *     // ... data to create a StripeConnectConfig
     *   }
     * })
     * 
     */
    create<T extends StripeConnectConfigCreateArgs>(args: SelectSubset<T, StripeConnectConfigCreateArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StripeConnectConfigs.
     * @param {StripeConnectConfigCreateManyArgs} args - Arguments to create many StripeConnectConfigs.
     * @example
     * // Create many StripeConnectConfigs
     * const stripeConnectConfig = await prisma.stripeConnectConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StripeConnectConfigCreateManyArgs>(args?: SelectSubset<T, StripeConnectConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StripeConnectConfigs and returns the data saved in the database.
     * @param {StripeConnectConfigCreateManyAndReturnArgs} args - Arguments to create many StripeConnectConfigs.
     * @example
     * // Create many StripeConnectConfigs
     * const stripeConnectConfig = await prisma.stripeConnectConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StripeConnectConfigs and only return the `id`
     * const stripeConnectConfigWithIdOnly = await prisma.stripeConnectConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StripeConnectConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, StripeConnectConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StripeConnectConfig.
     * @param {StripeConnectConfigDeleteArgs} args - Arguments to delete one StripeConnectConfig.
     * @example
     * // Delete one StripeConnectConfig
     * const StripeConnectConfig = await prisma.stripeConnectConfig.delete({
     *   where: {
     *     // ... filter to delete one StripeConnectConfig
     *   }
     * })
     * 
     */
    delete<T extends StripeConnectConfigDeleteArgs>(args: SelectSubset<T, StripeConnectConfigDeleteArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StripeConnectConfig.
     * @param {StripeConnectConfigUpdateArgs} args - Arguments to update one StripeConnectConfig.
     * @example
     * // Update one StripeConnectConfig
     * const stripeConnectConfig = await prisma.stripeConnectConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StripeConnectConfigUpdateArgs>(args: SelectSubset<T, StripeConnectConfigUpdateArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StripeConnectConfigs.
     * @param {StripeConnectConfigDeleteManyArgs} args - Arguments to filter StripeConnectConfigs to delete.
     * @example
     * // Delete a few StripeConnectConfigs
     * const { count } = await prisma.stripeConnectConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StripeConnectConfigDeleteManyArgs>(args?: SelectSubset<T, StripeConnectConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeConnectConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConnectConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeConnectConfigs
     * const stripeConnectConfig = await prisma.stripeConnectConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StripeConnectConfigUpdateManyArgs>(args: SelectSubset<T, StripeConnectConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StripeConnectConfig.
     * @param {StripeConnectConfigUpsertArgs} args - Arguments to update or create a StripeConnectConfig.
     * @example
     * // Update or create a StripeConnectConfig
     * const stripeConnectConfig = await prisma.stripeConnectConfig.upsert({
     *   create: {
     *     // ... data to create a StripeConnectConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeConnectConfig we want to update
     *   }
     * })
     */
    upsert<T extends StripeConnectConfigUpsertArgs>(args: SelectSubset<T, StripeConnectConfigUpsertArgs<ExtArgs>>): Prisma__StripeConnectConfigClient<$Result.GetResult<Prisma.$StripeConnectConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StripeConnectConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConnectConfigCountArgs} args - Arguments to filter StripeConnectConfigs to count.
     * @example
     * // Count the number of StripeConnectConfigs
     * const count = await prisma.stripeConnectConfig.count({
     *   where: {
     *     // ... the filter for the StripeConnectConfigs we want to count
     *   }
     * })
    **/
    count<T extends StripeConnectConfigCountArgs>(
      args?: Subset<T, StripeConnectConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeConnectConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeConnectConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConnectConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeConnectConfigAggregateArgs>(args: Subset<T, StripeConnectConfigAggregateArgs>): Prisma.PrismaPromise<GetStripeConnectConfigAggregateType<T>>

    /**
     * Group by StripeConnectConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConnectConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeConnectConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeConnectConfigGroupByArgs['orderBy'] }
        : { orderBy?: StripeConnectConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeConnectConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeConnectConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeConnectConfig model
   */
  readonly fields: StripeConnectConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeConnectConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeConnectConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StripeConnectConfig model
   */ 
  interface StripeConnectConfigFieldRefs {
    readonly id: FieldRef<"StripeConnectConfig", 'String'>
    readonly clientId: FieldRef<"StripeConnectConfig", 'String'>
    readonly enabled: FieldRef<"StripeConnectConfig", 'Boolean'>
    readonly minimumPayout: FieldRef<"StripeConnectConfig", 'Float'>
    readonly createdAt: FieldRef<"StripeConnectConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"StripeConnectConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StripeConnectConfig findUnique
   */
  export type StripeConnectConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * Filter, which StripeConnectConfig to fetch.
     */
    where: StripeConnectConfigWhereUniqueInput
  }

  /**
   * StripeConnectConfig findUniqueOrThrow
   */
  export type StripeConnectConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * Filter, which StripeConnectConfig to fetch.
     */
    where: StripeConnectConfigWhereUniqueInput
  }

  /**
   * StripeConnectConfig findFirst
   */
  export type StripeConnectConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * Filter, which StripeConnectConfig to fetch.
     */
    where?: StripeConnectConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConnectConfigs to fetch.
     */
    orderBy?: StripeConnectConfigOrderByWithRelationInput | StripeConnectConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeConnectConfigs.
     */
    cursor?: StripeConnectConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConnectConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConnectConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeConnectConfigs.
     */
    distinct?: StripeConnectConfigScalarFieldEnum | StripeConnectConfigScalarFieldEnum[]
  }

  /**
   * StripeConnectConfig findFirstOrThrow
   */
  export type StripeConnectConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * Filter, which StripeConnectConfig to fetch.
     */
    where?: StripeConnectConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConnectConfigs to fetch.
     */
    orderBy?: StripeConnectConfigOrderByWithRelationInput | StripeConnectConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeConnectConfigs.
     */
    cursor?: StripeConnectConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConnectConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConnectConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeConnectConfigs.
     */
    distinct?: StripeConnectConfigScalarFieldEnum | StripeConnectConfigScalarFieldEnum[]
  }

  /**
   * StripeConnectConfig findMany
   */
  export type StripeConnectConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * Filter, which StripeConnectConfigs to fetch.
     */
    where?: StripeConnectConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConnectConfigs to fetch.
     */
    orderBy?: StripeConnectConfigOrderByWithRelationInput | StripeConnectConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeConnectConfigs.
     */
    cursor?: StripeConnectConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConnectConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConnectConfigs.
     */
    skip?: number
    distinct?: StripeConnectConfigScalarFieldEnum | StripeConnectConfigScalarFieldEnum[]
  }

  /**
   * StripeConnectConfig create
   */
  export type StripeConnectConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a StripeConnectConfig.
     */
    data: XOR<StripeConnectConfigCreateInput, StripeConnectConfigUncheckedCreateInput>
  }

  /**
   * StripeConnectConfig createMany
   */
  export type StripeConnectConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeConnectConfigs.
     */
    data: StripeConnectConfigCreateManyInput | StripeConnectConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeConnectConfig createManyAndReturn
   */
  export type StripeConnectConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StripeConnectConfigs.
     */
    data: StripeConnectConfigCreateManyInput | StripeConnectConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeConnectConfig update
   */
  export type StripeConnectConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a StripeConnectConfig.
     */
    data: XOR<StripeConnectConfigUpdateInput, StripeConnectConfigUncheckedUpdateInput>
    /**
     * Choose, which StripeConnectConfig to update.
     */
    where: StripeConnectConfigWhereUniqueInput
  }

  /**
   * StripeConnectConfig updateMany
   */
  export type StripeConnectConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeConnectConfigs.
     */
    data: XOR<StripeConnectConfigUpdateManyMutationInput, StripeConnectConfigUncheckedUpdateManyInput>
    /**
     * Filter which StripeConnectConfigs to update
     */
    where?: StripeConnectConfigWhereInput
  }

  /**
   * StripeConnectConfig upsert
   */
  export type StripeConnectConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the StripeConnectConfig to update in case it exists.
     */
    where: StripeConnectConfigWhereUniqueInput
    /**
     * In case the StripeConnectConfig found by the `where` argument doesn't exist, create a new StripeConnectConfig with this data.
     */
    create: XOR<StripeConnectConfigCreateInput, StripeConnectConfigUncheckedCreateInput>
    /**
     * In case the StripeConnectConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeConnectConfigUpdateInput, StripeConnectConfigUncheckedUpdateInput>
  }

  /**
   * StripeConnectConfig delete
   */
  export type StripeConnectConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
    /**
     * Filter which StripeConnectConfig to delete.
     */
    where: StripeConnectConfigWhereUniqueInput
  }

  /**
   * StripeConnectConfig deleteMany
   */
  export type StripeConnectConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeConnectConfigs to delete
     */
    where?: StripeConnectConfigWhereInput
  }

  /**
   * StripeConnectConfig without action
   */
  export type StripeConnectConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConnectConfig
     */
    select?: StripeConnectConfigSelect<ExtArgs> | null
  }


  /**
   * Model TenantGoogleConfig
   */

  export type AggregateTenantGoogleConfig = {
    _count: TenantGoogleConfigCountAggregateOutputType | null
    _min: TenantGoogleConfigMinAggregateOutputType | null
    _max: TenantGoogleConfigMaxAggregateOutputType | null
  }

  export type TenantGoogleConfigMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    clientSecret: string | null
    geminiApiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantGoogleConfigMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    clientSecret: string | null
    geminiApiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantGoogleConfigCountAggregateOutputType = {
    id: number
    tenantId: number
    clientId: number
    clientSecret: number
    geminiApiKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantGoogleConfigMinAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    clientSecret?: true
    geminiApiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantGoogleConfigMaxAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    clientSecret?: true
    geminiApiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantGoogleConfigCountAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    clientSecret?: true
    geminiApiKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantGoogleConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantGoogleConfig to aggregate.
     */
    where?: TenantGoogleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantGoogleConfigs to fetch.
     */
    orderBy?: TenantGoogleConfigOrderByWithRelationInput | TenantGoogleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantGoogleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantGoogleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantGoogleConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantGoogleConfigs
    **/
    _count?: true | TenantGoogleConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantGoogleConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantGoogleConfigMaxAggregateInputType
  }

  export type GetTenantGoogleConfigAggregateType<T extends TenantGoogleConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantGoogleConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantGoogleConfig[P]>
      : GetScalarType<T[P], AggregateTenantGoogleConfig[P]>
  }




  export type TenantGoogleConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantGoogleConfigWhereInput
    orderBy?: TenantGoogleConfigOrderByWithAggregationInput | TenantGoogleConfigOrderByWithAggregationInput[]
    by: TenantGoogleConfigScalarFieldEnum[] | TenantGoogleConfigScalarFieldEnum
    having?: TenantGoogleConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantGoogleConfigCountAggregateInputType | true
    _min?: TenantGoogleConfigMinAggregateInputType
    _max?: TenantGoogleConfigMaxAggregateInputType
  }

  export type TenantGoogleConfigGroupByOutputType = {
    id: string
    tenantId: string
    clientId: string
    clientSecret: string
    geminiApiKey: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantGoogleConfigCountAggregateOutputType | null
    _min: TenantGoogleConfigMinAggregateOutputType | null
    _max: TenantGoogleConfigMaxAggregateOutputType | null
  }

  type GetTenantGoogleConfigGroupByPayload<T extends TenantGoogleConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGoogleConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGoogleConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGoogleConfigGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGoogleConfigGroupByOutputType[P]>
        }
      >
    >


  export type TenantGoogleConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    clientSecret?: boolean
    geminiApiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantGoogleConfig"]>

  export type TenantGoogleConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    clientSecret?: boolean
    geminiApiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantGoogleConfig"]>

  export type TenantGoogleConfigSelectScalar = {
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    clientSecret?: boolean
    geminiApiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantGoogleConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantGoogleConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantGoogleConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantGoogleConfig"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      clientId: string
      clientSecret: string
      geminiApiKey: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantGoogleConfig"]>
    composites: {}
  }

  type TenantGoogleConfigGetPayload<S extends boolean | null | undefined | TenantGoogleConfigDefaultArgs> = $Result.GetResult<Prisma.$TenantGoogleConfigPayload, S>

  type TenantGoogleConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantGoogleConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantGoogleConfigCountAggregateInputType | true
    }

  export interface TenantGoogleConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantGoogleConfig'], meta: { name: 'TenantGoogleConfig' } }
    /**
     * Find zero or one TenantGoogleConfig that matches the filter.
     * @param {TenantGoogleConfigFindUniqueArgs} args - Arguments to find a TenantGoogleConfig
     * @example
     * // Get one TenantGoogleConfig
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantGoogleConfigFindUniqueArgs>(args: SelectSubset<T, TenantGoogleConfigFindUniqueArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenantGoogleConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantGoogleConfigFindUniqueOrThrowArgs} args - Arguments to find a TenantGoogleConfig
     * @example
     * // Get one TenantGoogleConfig
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantGoogleConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantGoogleConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenantGoogleConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGoogleConfigFindFirstArgs} args - Arguments to find a TenantGoogleConfig
     * @example
     * // Get one TenantGoogleConfig
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantGoogleConfigFindFirstArgs>(args?: SelectSubset<T, TenantGoogleConfigFindFirstArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenantGoogleConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGoogleConfigFindFirstOrThrowArgs} args - Arguments to find a TenantGoogleConfig
     * @example
     * // Get one TenantGoogleConfig
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantGoogleConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantGoogleConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenantGoogleConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGoogleConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantGoogleConfigs
     * const tenantGoogleConfigs = await prisma.tenantGoogleConfig.findMany()
     * 
     * // Get first 10 TenantGoogleConfigs
     * const tenantGoogleConfigs = await prisma.tenantGoogleConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantGoogleConfigWithIdOnly = await prisma.tenantGoogleConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantGoogleConfigFindManyArgs>(args?: SelectSubset<T, TenantGoogleConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenantGoogleConfig.
     * @param {TenantGoogleConfigCreateArgs} args - Arguments to create a TenantGoogleConfig.
     * @example
     * // Create one TenantGoogleConfig
     * const TenantGoogleConfig = await prisma.tenantGoogleConfig.create({
     *   data: {
     *     // ... data to create a TenantGoogleConfig
     *   }
     * })
     * 
     */
    create<T extends TenantGoogleConfigCreateArgs>(args: SelectSubset<T, TenantGoogleConfigCreateArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenantGoogleConfigs.
     * @param {TenantGoogleConfigCreateManyArgs} args - Arguments to create many TenantGoogleConfigs.
     * @example
     * // Create many TenantGoogleConfigs
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantGoogleConfigCreateManyArgs>(args?: SelectSubset<T, TenantGoogleConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantGoogleConfigs and returns the data saved in the database.
     * @param {TenantGoogleConfigCreateManyAndReturnArgs} args - Arguments to create many TenantGoogleConfigs.
     * @example
     * // Create many TenantGoogleConfigs
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantGoogleConfigs and only return the `id`
     * const tenantGoogleConfigWithIdOnly = await prisma.tenantGoogleConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantGoogleConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantGoogleConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenantGoogleConfig.
     * @param {TenantGoogleConfigDeleteArgs} args - Arguments to delete one TenantGoogleConfig.
     * @example
     * // Delete one TenantGoogleConfig
     * const TenantGoogleConfig = await prisma.tenantGoogleConfig.delete({
     *   where: {
     *     // ... filter to delete one TenantGoogleConfig
     *   }
     * })
     * 
     */
    delete<T extends TenantGoogleConfigDeleteArgs>(args: SelectSubset<T, TenantGoogleConfigDeleteArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenantGoogleConfig.
     * @param {TenantGoogleConfigUpdateArgs} args - Arguments to update one TenantGoogleConfig.
     * @example
     * // Update one TenantGoogleConfig
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantGoogleConfigUpdateArgs>(args: SelectSubset<T, TenantGoogleConfigUpdateArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenantGoogleConfigs.
     * @param {TenantGoogleConfigDeleteManyArgs} args - Arguments to filter TenantGoogleConfigs to delete.
     * @example
     * // Delete a few TenantGoogleConfigs
     * const { count } = await prisma.tenantGoogleConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantGoogleConfigDeleteManyArgs>(args?: SelectSubset<T, TenantGoogleConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantGoogleConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGoogleConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantGoogleConfigs
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantGoogleConfigUpdateManyArgs>(args: SelectSubset<T, TenantGoogleConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenantGoogleConfig.
     * @param {TenantGoogleConfigUpsertArgs} args - Arguments to update or create a TenantGoogleConfig.
     * @example
     * // Update or create a TenantGoogleConfig
     * const tenantGoogleConfig = await prisma.tenantGoogleConfig.upsert({
     *   create: {
     *     // ... data to create a TenantGoogleConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantGoogleConfig we want to update
     *   }
     * })
     */
    upsert<T extends TenantGoogleConfigUpsertArgs>(args: SelectSubset<T, TenantGoogleConfigUpsertArgs<ExtArgs>>): Prisma__TenantGoogleConfigClient<$Result.GetResult<Prisma.$TenantGoogleConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenantGoogleConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGoogleConfigCountArgs} args - Arguments to filter TenantGoogleConfigs to count.
     * @example
     * // Count the number of TenantGoogleConfigs
     * const count = await prisma.tenantGoogleConfig.count({
     *   where: {
     *     // ... the filter for the TenantGoogleConfigs we want to count
     *   }
     * })
    **/
    count<T extends TenantGoogleConfigCountArgs>(
      args?: Subset<T, TenantGoogleConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantGoogleConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantGoogleConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGoogleConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantGoogleConfigAggregateArgs>(args: Subset<T, TenantGoogleConfigAggregateArgs>): Prisma.PrismaPromise<GetTenantGoogleConfigAggregateType<T>>

    /**
     * Group by TenantGoogleConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGoogleConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGoogleConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGoogleConfigGroupByArgs['orderBy'] }
        : { orderBy?: TenantGoogleConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGoogleConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGoogleConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantGoogleConfig model
   */
  readonly fields: TenantGoogleConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantGoogleConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantGoogleConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantGoogleConfig model
   */ 
  interface TenantGoogleConfigFieldRefs {
    readonly id: FieldRef<"TenantGoogleConfig", 'String'>
    readonly tenantId: FieldRef<"TenantGoogleConfig", 'String'>
    readonly clientId: FieldRef<"TenantGoogleConfig", 'String'>
    readonly clientSecret: FieldRef<"TenantGoogleConfig", 'String'>
    readonly geminiApiKey: FieldRef<"TenantGoogleConfig", 'String'>
    readonly createdAt: FieldRef<"TenantGoogleConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantGoogleConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantGoogleConfig findUnique
   */
  export type TenantGoogleConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantGoogleConfig to fetch.
     */
    where: TenantGoogleConfigWhereUniqueInput
  }

  /**
   * TenantGoogleConfig findUniqueOrThrow
   */
  export type TenantGoogleConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantGoogleConfig to fetch.
     */
    where: TenantGoogleConfigWhereUniqueInput
  }

  /**
   * TenantGoogleConfig findFirst
   */
  export type TenantGoogleConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantGoogleConfig to fetch.
     */
    where?: TenantGoogleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantGoogleConfigs to fetch.
     */
    orderBy?: TenantGoogleConfigOrderByWithRelationInput | TenantGoogleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantGoogleConfigs.
     */
    cursor?: TenantGoogleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantGoogleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantGoogleConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantGoogleConfigs.
     */
    distinct?: TenantGoogleConfigScalarFieldEnum | TenantGoogleConfigScalarFieldEnum[]
  }

  /**
   * TenantGoogleConfig findFirstOrThrow
   */
  export type TenantGoogleConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantGoogleConfig to fetch.
     */
    where?: TenantGoogleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantGoogleConfigs to fetch.
     */
    orderBy?: TenantGoogleConfigOrderByWithRelationInput | TenantGoogleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantGoogleConfigs.
     */
    cursor?: TenantGoogleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantGoogleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantGoogleConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantGoogleConfigs.
     */
    distinct?: TenantGoogleConfigScalarFieldEnum | TenantGoogleConfigScalarFieldEnum[]
  }

  /**
   * TenantGoogleConfig findMany
   */
  export type TenantGoogleConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * Filter, which TenantGoogleConfigs to fetch.
     */
    where?: TenantGoogleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantGoogleConfigs to fetch.
     */
    orderBy?: TenantGoogleConfigOrderByWithRelationInput | TenantGoogleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantGoogleConfigs.
     */
    cursor?: TenantGoogleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantGoogleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantGoogleConfigs.
     */
    skip?: number
    distinct?: TenantGoogleConfigScalarFieldEnum | TenantGoogleConfigScalarFieldEnum[]
  }

  /**
   * TenantGoogleConfig create
   */
  export type TenantGoogleConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantGoogleConfig.
     */
    data: XOR<TenantGoogleConfigCreateInput, TenantGoogleConfigUncheckedCreateInput>
  }

  /**
   * TenantGoogleConfig createMany
   */
  export type TenantGoogleConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantGoogleConfigs.
     */
    data: TenantGoogleConfigCreateManyInput | TenantGoogleConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantGoogleConfig createManyAndReturn
   */
  export type TenantGoogleConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenantGoogleConfigs.
     */
    data: TenantGoogleConfigCreateManyInput | TenantGoogleConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantGoogleConfig update
   */
  export type TenantGoogleConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantGoogleConfig.
     */
    data: XOR<TenantGoogleConfigUpdateInput, TenantGoogleConfigUncheckedUpdateInput>
    /**
     * Choose, which TenantGoogleConfig to update.
     */
    where: TenantGoogleConfigWhereUniqueInput
  }

  /**
   * TenantGoogleConfig updateMany
   */
  export type TenantGoogleConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantGoogleConfigs.
     */
    data: XOR<TenantGoogleConfigUpdateManyMutationInput, TenantGoogleConfigUncheckedUpdateManyInput>
    /**
     * Filter which TenantGoogleConfigs to update
     */
    where?: TenantGoogleConfigWhereInput
  }

  /**
   * TenantGoogleConfig upsert
   */
  export type TenantGoogleConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantGoogleConfig to update in case it exists.
     */
    where: TenantGoogleConfigWhereUniqueInput
    /**
     * In case the TenantGoogleConfig found by the `where` argument doesn't exist, create a new TenantGoogleConfig with this data.
     */
    create: XOR<TenantGoogleConfigCreateInput, TenantGoogleConfigUncheckedCreateInput>
    /**
     * In case the TenantGoogleConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantGoogleConfigUpdateInput, TenantGoogleConfigUncheckedUpdateInput>
  }

  /**
   * TenantGoogleConfig delete
   */
  export type TenantGoogleConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
    /**
     * Filter which TenantGoogleConfig to delete.
     */
    where: TenantGoogleConfigWhereUniqueInput
  }

  /**
   * TenantGoogleConfig deleteMany
   */
  export type TenantGoogleConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantGoogleConfigs to delete
     */
    where?: TenantGoogleConfigWhereInput
  }

  /**
   * TenantGoogleConfig without action
   */
  export type TenantGoogleConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantGoogleConfig
     */
    select?: TenantGoogleConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantGoogleConfigInclude<ExtArgs> | null
  }


  /**
   * Model CalendarCredentials
   */

  export type AggregateCalendarCredentials = {
    _count: CalendarCredentialsCountAggregateOutputType | null
    _min: CalendarCredentialsMinAggregateOutputType | null
    _max: CalendarCredentialsMaxAggregateOutputType | null
  }

  export type CalendarCredentialsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    calendarEmail: string | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarCredentialsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    calendarEmail: string | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarCredentialsCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    calendarEmail: number
    scope: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarCredentialsMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    calendarEmail?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarCredentialsMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    calendarEmail?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarCredentialsCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    calendarEmail?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarCredentialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarCredentials to aggregate.
     */
    where?: CalendarCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarCredentials to fetch.
     */
    orderBy?: CalendarCredentialsOrderByWithRelationInput | CalendarCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarCredentials
    **/
    _count?: true | CalendarCredentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarCredentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarCredentialsMaxAggregateInputType
  }

  export type GetCalendarCredentialsAggregateType<T extends CalendarCredentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarCredentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarCredentials[P]>
      : GetScalarType<T[P], AggregateCalendarCredentials[P]>
  }




  export type CalendarCredentialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarCredentialsWhereInput
    orderBy?: CalendarCredentialsOrderByWithAggregationInput | CalendarCredentialsOrderByWithAggregationInput[]
    by: CalendarCredentialsScalarFieldEnum[] | CalendarCredentialsScalarFieldEnum
    having?: CalendarCredentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCredentialsCountAggregateInputType | true
    _min?: CalendarCredentialsMinAggregateInputType
    _max?: CalendarCredentialsMaxAggregateInputType
  }

  export type CalendarCredentialsGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken: string | null
    expiresAt: Date | null
    calendarEmail: string | null
    scope: string | null
    createdAt: Date
    updatedAt: Date
    _count: CalendarCredentialsCountAggregateOutputType | null
    _min: CalendarCredentialsMinAggregateOutputType | null
    _max: CalendarCredentialsMaxAggregateOutputType | null
  }

  type GetCalendarCredentialsGroupByPayload<T extends CalendarCredentialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarCredentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarCredentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarCredentialsGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarCredentialsGroupByOutputType[P]>
        }
      >
    >


  export type CalendarCredentialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    calendarEmail?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["calendarCredentials"]>

  export type CalendarCredentialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    calendarEmail?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["calendarCredentials"]>

  export type CalendarCredentialsSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    calendarEmail?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CalendarCredentialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarCredentials"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      accessToken: string
      refreshToken: string | null
      expiresAt: Date | null
      calendarEmail: string | null
      scope: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarCredentials"]>
    composites: {}
  }

  type CalendarCredentialsGetPayload<S extends boolean | null | undefined | CalendarCredentialsDefaultArgs> = $Result.GetResult<Prisma.$CalendarCredentialsPayload, S>

  type CalendarCredentialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarCredentialsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarCredentialsCountAggregateInputType | true
    }

  export interface CalendarCredentialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarCredentials'], meta: { name: 'CalendarCredentials' } }
    /**
     * Find zero or one CalendarCredentials that matches the filter.
     * @param {CalendarCredentialsFindUniqueArgs} args - Arguments to find a CalendarCredentials
     * @example
     * // Get one CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarCredentialsFindUniqueArgs>(args: SelectSubset<T, CalendarCredentialsFindUniqueArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarCredentials that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarCredentialsFindUniqueOrThrowArgs} args - Arguments to find a CalendarCredentials
     * @example
     * // Get one CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarCredentialsFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarCredentialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCredentialsFindFirstArgs} args - Arguments to find a CalendarCredentials
     * @example
     * // Get one CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarCredentialsFindFirstArgs>(args?: SelectSubset<T, CalendarCredentialsFindFirstArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarCredentials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCredentialsFindFirstOrThrowArgs} args - Arguments to find a CalendarCredentials
     * @example
     * // Get one CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarCredentialsFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarCredentialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCredentialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.findMany()
     * 
     * // Get first 10 CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarCredentialsWithIdOnly = await prisma.calendarCredentials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarCredentialsFindManyArgs>(args?: SelectSubset<T, CalendarCredentialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarCredentials.
     * @param {CalendarCredentialsCreateArgs} args - Arguments to create a CalendarCredentials.
     * @example
     * // Create one CalendarCredentials
     * const CalendarCredentials = await prisma.calendarCredentials.create({
     *   data: {
     *     // ... data to create a CalendarCredentials
     *   }
     * })
     * 
     */
    create<T extends CalendarCredentialsCreateArgs>(args: SelectSubset<T, CalendarCredentialsCreateArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarCredentials.
     * @param {CalendarCredentialsCreateManyArgs} args - Arguments to create many CalendarCredentials.
     * @example
     * // Create many CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarCredentialsCreateManyArgs>(args?: SelectSubset<T, CalendarCredentialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarCredentials and returns the data saved in the database.
     * @param {CalendarCredentialsCreateManyAndReturnArgs} args - Arguments to create many CalendarCredentials.
     * @example
     * // Create many CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarCredentials and only return the `id`
     * const calendarCredentialsWithIdOnly = await prisma.calendarCredentials.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarCredentialsCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarCredentialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarCredentials.
     * @param {CalendarCredentialsDeleteArgs} args - Arguments to delete one CalendarCredentials.
     * @example
     * // Delete one CalendarCredentials
     * const CalendarCredentials = await prisma.calendarCredentials.delete({
     *   where: {
     *     // ... filter to delete one CalendarCredentials
     *   }
     * })
     * 
     */
    delete<T extends CalendarCredentialsDeleteArgs>(args: SelectSubset<T, CalendarCredentialsDeleteArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarCredentials.
     * @param {CalendarCredentialsUpdateArgs} args - Arguments to update one CalendarCredentials.
     * @example
     * // Update one CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarCredentialsUpdateArgs>(args: SelectSubset<T, CalendarCredentialsUpdateArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarCredentials.
     * @param {CalendarCredentialsDeleteManyArgs} args - Arguments to filter CalendarCredentials to delete.
     * @example
     * // Delete a few CalendarCredentials
     * const { count } = await prisma.calendarCredentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarCredentialsDeleteManyArgs>(args?: SelectSubset<T, CalendarCredentialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCredentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarCredentialsUpdateManyArgs>(args: SelectSubset<T, CalendarCredentialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarCredentials.
     * @param {CalendarCredentialsUpsertArgs} args - Arguments to update or create a CalendarCredentials.
     * @example
     * // Update or create a CalendarCredentials
     * const calendarCredentials = await prisma.calendarCredentials.upsert({
     *   create: {
     *     // ... data to create a CalendarCredentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarCredentials we want to update
     *   }
     * })
     */
    upsert<T extends CalendarCredentialsUpsertArgs>(args: SelectSubset<T, CalendarCredentialsUpsertArgs<ExtArgs>>): Prisma__CalendarCredentialsClient<$Result.GetResult<Prisma.$CalendarCredentialsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCredentialsCountArgs} args - Arguments to filter CalendarCredentials to count.
     * @example
     * // Count the number of CalendarCredentials
     * const count = await prisma.calendarCredentials.count({
     *   where: {
     *     // ... the filter for the CalendarCredentials we want to count
     *   }
     * })
    **/
    count<T extends CalendarCredentialsCountArgs>(
      args?: Subset<T, CalendarCredentialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCredentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCredentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarCredentialsAggregateArgs>(args: Subset<T, CalendarCredentialsAggregateArgs>): Prisma.PrismaPromise<GetCalendarCredentialsAggregateType<T>>

    /**
     * Group by CalendarCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCredentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarCredentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarCredentialsGroupByArgs['orderBy'] }
        : { orderBy?: CalendarCredentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarCredentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarCredentialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarCredentials model
   */
  readonly fields: CalendarCredentialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarCredentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarCredentialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarCredentials model
   */ 
  interface CalendarCredentialsFieldRefs {
    readonly id: FieldRef<"CalendarCredentials", 'String'>
    readonly userId: FieldRef<"CalendarCredentials", 'String'>
    readonly tenantId: FieldRef<"CalendarCredentials", 'String'>
    readonly accessToken: FieldRef<"CalendarCredentials", 'String'>
    readonly refreshToken: FieldRef<"CalendarCredentials", 'String'>
    readonly expiresAt: FieldRef<"CalendarCredentials", 'DateTime'>
    readonly calendarEmail: FieldRef<"CalendarCredentials", 'String'>
    readonly scope: FieldRef<"CalendarCredentials", 'String'>
    readonly createdAt: FieldRef<"CalendarCredentials", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarCredentials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarCredentials findUnique
   */
  export type CalendarCredentialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which CalendarCredentials to fetch.
     */
    where: CalendarCredentialsWhereUniqueInput
  }

  /**
   * CalendarCredentials findUniqueOrThrow
   */
  export type CalendarCredentialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which CalendarCredentials to fetch.
     */
    where: CalendarCredentialsWhereUniqueInput
  }

  /**
   * CalendarCredentials findFirst
   */
  export type CalendarCredentialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which CalendarCredentials to fetch.
     */
    where?: CalendarCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarCredentials to fetch.
     */
    orderBy?: CalendarCredentialsOrderByWithRelationInput | CalendarCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarCredentials.
     */
    cursor?: CalendarCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarCredentials.
     */
    distinct?: CalendarCredentialsScalarFieldEnum | CalendarCredentialsScalarFieldEnum[]
  }

  /**
   * CalendarCredentials findFirstOrThrow
   */
  export type CalendarCredentialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which CalendarCredentials to fetch.
     */
    where?: CalendarCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarCredentials to fetch.
     */
    orderBy?: CalendarCredentialsOrderByWithRelationInput | CalendarCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarCredentials.
     */
    cursor?: CalendarCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarCredentials.
     */
    distinct?: CalendarCredentialsScalarFieldEnum | CalendarCredentialsScalarFieldEnum[]
  }

  /**
   * CalendarCredentials findMany
   */
  export type CalendarCredentialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which CalendarCredentials to fetch.
     */
    where?: CalendarCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarCredentials to fetch.
     */
    orderBy?: CalendarCredentialsOrderByWithRelationInput | CalendarCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarCredentials.
     */
    cursor?: CalendarCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarCredentials.
     */
    skip?: number
    distinct?: CalendarCredentialsScalarFieldEnum | CalendarCredentialsScalarFieldEnum[]
  }

  /**
   * CalendarCredentials create
   */
  export type CalendarCredentialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * The data needed to create a CalendarCredentials.
     */
    data: XOR<CalendarCredentialsCreateInput, CalendarCredentialsUncheckedCreateInput>
  }

  /**
   * CalendarCredentials createMany
   */
  export type CalendarCredentialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarCredentials.
     */
    data: CalendarCredentialsCreateManyInput | CalendarCredentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarCredentials createManyAndReturn
   */
  export type CalendarCredentialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarCredentials.
     */
    data: CalendarCredentialsCreateManyInput | CalendarCredentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarCredentials update
   */
  export type CalendarCredentialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * The data needed to update a CalendarCredentials.
     */
    data: XOR<CalendarCredentialsUpdateInput, CalendarCredentialsUncheckedUpdateInput>
    /**
     * Choose, which CalendarCredentials to update.
     */
    where: CalendarCredentialsWhereUniqueInput
  }

  /**
   * CalendarCredentials updateMany
   */
  export type CalendarCredentialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarCredentials.
     */
    data: XOR<CalendarCredentialsUpdateManyMutationInput, CalendarCredentialsUncheckedUpdateManyInput>
    /**
     * Filter which CalendarCredentials to update
     */
    where?: CalendarCredentialsWhereInput
  }

  /**
   * CalendarCredentials upsert
   */
  export type CalendarCredentialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * The filter to search for the CalendarCredentials to update in case it exists.
     */
    where: CalendarCredentialsWhereUniqueInput
    /**
     * In case the CalendarCredentials found by the `where` argument doesn't exist, create a new CalendarCredentials with this data.
     */
    create: XOR<CalendarCredentialsCreateInput, CalendarCredentialsUncheckedCreateInput>
    /**
     * In case the CalendarCredentials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarCredentialsUpdateInput, CalendarCredentialsUncheckedUpdateInput>
  }

  /**
   * CalendarCredentials delete
   */
  export type CalendarCredentialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
    /**
     * Filter which CalendarCredentials to delete.
     */
    where: CalendarCredentialsWhereUniqueInput
  }

  /**
   * CalendarCredentials deleteMany
   */
  export type CalendarCredentialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarCredentials to delete
     */
    where?: CalendarCredentialsWhereInput
  }

  /**
   * CalendarCredentials without action
   */
  export type CalendarCredentialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCredentials
     */
    select?: CalendarCredentialsSelect<ExtArgs> | null
  }


  /**
   * Model GmailCredentials
   */

  export type AggregateGmailCredentials = {
    _count: GmailCredentialsCountAggregateOutputType | null
    _min: GmailCredentialsMinAggregateOutputType | null
    _max: GmailCredentialsMaxAggregateOutputType | null
  }

  export type GmailCredentialsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    gmailEmail: string | null
    scope: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmailCredentialsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    gmailEmail: string | null
    scope: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmailCredentialsCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    gmailEmail: number
    scope: number
    verified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GmailCredentialsMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    gmailEmail?: true
    scope?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmailCredentialsMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    gmailEmail?: true
    scope?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmailCredentialsCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    gmailEmail?: true
    scope?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GmailCredentialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmailCredentials to aggregate.
     */
    where?: GmailCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailCredentials to fetch.
     */
    orderBy?: GmailCredentialsOrderByWithRelationInput | GmailCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GmailCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GmailCredentials
    **/
    _count?: true | GmailCredentialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GmailCredentialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GmailCredentialsMaxAggregateInputType
  }

  export type GetGmailCredentialsAggregateType<T extends GmailCredentialsAggregateArgs> = {
        [P in keyof T & keyof AggregateGmailCredentials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGmailCredentials[P]>
      : GetScalarType<T[P], AggregateGmailCredentials[P]>
  }




  export type GmailCredentialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GmailCredentialsWhereInput
    orderBy?: GmailCredentialsOrderByWithAggregationInput | GmailCredentialsOrderByWithAggregationInput[]
    by: GmailCredentialsScalarFieldEnum[] | GmailCredentialsScalarFieldEnum
    having?: GmailCredentialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GmailCredentialsCountAggregateInputType | true
    _min?: GmailCredentialsMinAggregateInputType
    _max?: GmailCredentialsMaxAggregateInputType
  }

  export type GmailCredentialsGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken: string | null
    expiresAt: Date | null
    gmailEmail: string | null
    scope: string | null
    verified: boolean
    createdAt: Date
    updatedAt: Date
    _count: GmailCredentialsCountAggregateOutputType | null
    _min: GmailCredentialsMinAggregateOutputType | null
    _max: GmailCredentialsMaxAggregateOutputType | null
  }

  type GetGmailCredentialsGroupByPayload<T extends GmailCredentialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GmailCredentialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GmailCredentialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GmailCredentialsGroupByOutputType[P]>
            : GetScalarType<T[P], GmailCredentialsGroupByOutputType[P]>
        }
      >
    >


  export type GmailCredentialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    gmailEmail?: boolean
    scope?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gmailCredentials"]>

  export type GmailCredentialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    gmailEmail?: boolean
    scope?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gmailCredentials"]>

  export type GmailCredentialsSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    gmailEmail?: boolean
    scope?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $GmailCredentialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GmailCredentials"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      accessToken: string
      refreshToken: string | null
      expiresAt: Date | null
      gmailEmail: string | null
      scope: string | null
      verified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gmailCredentials"]>
    composites: {}
  }

  type GmailCredentialsGetPayload<S extends boolean | null | undefined | GmailCredentialsDefaultArgs> = $Result.GetResult<Prisma.$GmailCredentialsPayload, S>

  type GmailCredentialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GmailCredentialsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GmailCredentialsCountAggregateInputType | true
    }

  export interface GmailCredentialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GmailCredentials'], meta: { name: 'GmailCredentials' } }
    /**
     * Find zero or one GmailCredentials that matches the filter.
     * @param {GmailCredentialsFindUniqueArgs} args - Arguments to find a GmailCredentials
     * @example
     * // Get one GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GmailCredentialsFindUniqueArgs>(args: SelectSubset<T, GmailCredentialsFindUniqueArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GmailCredentials that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GmailCredentialsFindUniqueOrThrowArgs} args - Arguments to find a GmailCredentials
     * @example
     * // Get one GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GmailCredentialsFindUniqueOrThrowArgs>(args: SelectSubset<T, GmailCredentialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GmailCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailCredentialsFindFirstArgs} args - Arguments to find a GmailCredentials
     * @example
     * // Get one GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GmailCredentialsFindFirstArgs>(args?: SelectSubset<T, GmailCredentialsFindFirstArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GmailCredentials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailCredentialsFindFirstOrThrowArgs} args - Arguments to find a GmailCredentials
     * @example
     * // Get one GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GmailCredentialsFindFirstOrThrowArgs>(args?: SelectSubset<T, GmailCredentialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GmailCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailCredentialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.findMany()
     * 
     * // Get first 10 GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gmailCredentialsWithIdOnly = await prisma.gmailCredentials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GmailCredentialsFindManyArgs>(args?: SelectSubset<T, GmailCredentialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GmailCredentials.
     * @param {GmailCredentialsCreateArgs} args - Arguments to create a GmailCredentials.
     * @example
     * // Create one GmailCredentials
     * const GmailCredentials = await prisma.gmailCredentials.create({
     *   data: {
     *     // ... data to create a GmailCredentials
     *   }
     * })
     * 
     */
    create<T extends GmailCredentialsCreateArgs>(args: SelectSubset<T, GmailCredentialsCreateArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GmailCredentials.
     * @param {GmailCredentialsCreateManyArgs} args - Arguments to create many GmailCredentials.
     * @example
     * // Create many GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GmailCredentialsCreateManyArgs>(args?: SelectSubset<T, GmailCredentialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GmailCredentials and returns the data saved in the database.
     * @param {GmailCredentialsCreateManyAndReturnArgs} args - Arguments to create many GmailCredentials.
     * @example
     * // Create many GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GmailCredentials and only return the `id`
     * const gmailCredentialsWithIdOnly = await prisma.gmailCredentials.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GmailCredentialsCreateManyAndReturnArgs>(args?: SelectSubset<T, GmailCredentialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GmailCredentials.
     * @param {GmailCredentialsDeleteArgs} args - Arguments to delete one GmailCredentials.
     * @example
     * // Delete one GmailCredentials
     * const GmailCredentials = await prisma.gmailCredentials.delete({
     *   where: {
     *     // ... filter to delete one GmailCredentials
     *   }
     * })
     * 
     */
    delete<T extends GmailCredentialsDeleteArgs>(args: SelectSubset<T, GmailCredentialsDeleteArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GmailCredentials.
     * @param {GmailCredentialsUpdateArgs} args - Arguments to update one GmailCredentials.
     * @example
     * // Update one GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GmailCredentialsUpdateArgs>(args: SelectSubset<T, GmailCredentialsUpdateArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GmailCredentials.
     * @param {GmailCredentialsDeleteManyArgs} args - Arguments to filter GmailCredentials to delete.
     * @example
     * // Delete a few GmailCredentials
     * const { count } = await prisma.gmailCredentials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GmailCredentialsDeleteManyArgs>(args?: SelectSubset<T, GmailCredentialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GmailCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailCredentialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GmailCredentialsUpdateManyArgs>(args: SelectSubset<T, GmailCredentialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GmailCredentials.
     * @param {GmailCredentialsUpsertArgs} args - Arguments to update or create a GmailCredentials.
     * @example
     * // Update or create a GmailCredentials
     * const gmailCredentials = await prisma.gmailCredentials.upsert({
     *   create: {
     *     // ... data to create a GmailCredentials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GmailCredentials we want to update
     *   }
     * })
     */
    upsert<T extends GmailCredentialsUpsertArgs>(args: SelectSubset<T, GmailCredentialsUpsertArgs<ExtArgs>>): Prisma__GmailCredentialsClient<$Result.GetResult<Prisma.$GmailCredentialsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GmailCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailCredentialsCountArgs} args - Arguments to filter GmailCredentials to count.
     * @example
     * // Count the number of GmailCredentials
     * const count = await prisma.gmailCredentials.count({
     *   where: {
     *     // ... the filter for the GmailCredentials we want to count
     *   }
     * })
    **/
    count<T extends GmailCredentialsCountArgs>(
      args?: Subset<T, GmailCredentialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GmailCredentialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GmailCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailCredentialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GmailCredentialsAggregateArgs>(args: Subset<T, GmailCredentialsAggregateArgs>): Prisma.PrismaPromise<GetGmailCredentialsAggregateType<T>>

    /**
     * Group by GmailCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailCredentialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GmailCredentialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GmailCredentialsGroupByArgs['orderBy'] }
        : { orderBy?: GmailCredentialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GmailCredentialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGmailCredentialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GmailCredentials model
   */
  readonly fields: GmailCredentialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GmailCredentials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GmailCredentialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GmailCredentials model
   */ 
  interface GmailCredentialsFieldRefs {
    readonly id: FieldRef<"GmailCredentials", 'String'>
    readonly userId: FieldRef<"GmailCredentials", 'String'>
    readonly tenantId: FieldRef<"GmailCredentials", 'String'>
    readonly accessToken: FieldRef<"GmailCredentials", 'String'>
    readonly refreshToken: FieldRef<"GmailCredentials", 'String'>
    readonly expiresAt: FieldRef<"GmailCredentials", 'DateTime'>
    readonly gmailEmail: FieldRef<"GmailCredentials", 'String'>
    readonly scope: FieldRef<"GmailCredentials", 'String'>
    readonly verified: FieldRef<"GmailCredentials", 'Boolean'>
    readonly createdAt: FieldRef<"GmailCredentials", 'DateTime'>
    readonly updatedAt: FieldRef<"GmailCredentials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GmailCredentials findUnique
   */
  export type GmailCredentialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which GmailCredentials to fetch.
     */
    where: GmailCredentialsWhereUniqueInput
  }

  /**
   * GmailCredentials findUniqueOrThrow
   */
  export type GmailCredentialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which GmailCredentials to fetch.
     */
    where: GmailCredentialsWhereUniqueInput
  }

  /**
   * GmailCredentials findFirst
   */
  export type GmailCredentialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which GmailCredentials to fetch.
     */
    where?: GmailCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailCredentials to fetch.
     */
    orderBy?: GmailCredentialsOrderByWithRelationInput | GmailCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmailCredentials.
     */
    cursor?: GmailCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmailCredentials.
     */
    distinct?: GmailCredentialsScalarFieldEnum | GmailCredentialsScalarFieldEnum[]
  }

  /**
   * GmailCredentials findFirstOrThrow
   */
  export type GmailCredentialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which GmailCredentials to fetch.
     */
    where?: GmailCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailCredentials to fetch.
     */
    orderBy?: GmailCredentialsOrderByWithRelationInput | GmailCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmailCredentials.
     */
    cursor?: GmailCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmailCredentials.
     */
    distinct?: GmailCredentialsScalarFieldEnum | GmailCredentialsScalarFieldEnum[]
  }

  /**
   * GmailCredentials findMany
   */
  export type GmailCredentialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * Filter, which GmailCredentials to fetch.
     */
    where?: GmailCredentialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailCredentials to fetch.
     */
    orderBy?: GmailCredentialsOrderByWithRelationInput | GmailCredentialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GmailCredentials.
     */
    cursor?: GmailCredentialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailCredentials.
     */
    skip?: number
    distinct?: GmailCredentialsScalarFieldEnum | GmailCredentialsScalarFieldEnum[]
  }

  /**
   * GmailCredentials create
   */
  export type GmailCredentialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * The data needed to create a GmailCredentials.
     */
    data: XOR<GmailCredentialsCreateInput, GmailCredentialsUncheckedCreateInput>
  }

  /**
   * GmailCredentials createMany
   */
  export type GmailCredentialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GmailCredentials.
     */
    data: GmailCredentialsCreateManyInput | GmailCredentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GmailCredentials createManyAndReturn
   */
  export type GmailCredentialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GmailCredentials.
     */
    data: GmailCredentialsCreateManyInput | GmailCredentialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GmailCredentials update
   */
  export type GmailCredentialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * The data needed to update a GmailCredentials.
     */
    data: XOR<GmailCredentialsUpdateInput, GmailCredentialsUncheckedUpdateInput>
    /**
     * Choose, which GmailCredentials to update.
     */
    where: GmailCredentialsWhereUniqueInput
  }

  /**
   * GmailCredentials updateMany
   */
  export type GmailCredentialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GmailCredentials.
     */
    data: XOR<GmailCredentialsUpdateManyMutationInput, GmailCredentialsUncheckedUpdateManyInput>
    /**
     * Filter which GmailCredentials to update
     */
    where?: GmailCredentialsWhereInput
  }

  /**
   * GmailCredentials upsert
   */
  export type GmailCredentialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * The filter to search for the GmailCredentials to update in case it exists.
     */
    where: GmailCredentialsWhereUniqueInput
    /**
     * In case the GmailCredentials found by the `where` argument doesn't exist, create a new GmailCredentials with this data.
     */
    create: XOR<GmailCredentialsCreateInput, GmailCredentialsUncheckedCreateInput>
    /**
     * In case the GmailCredentials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GmailCredentialsUpdateInput, GmailCredentialsUncheckedUpdateInput>
  }

  /**
   * GmailCredentials delete
   */
  export type GmailCredentialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
    /**
     * Filter which GmailCredentials to delete.
     */
    where: GmailCredentialsWhereUniqueInput
  }

  /**
   * GmailCredentials deleteMany
   */
  export type GmailCredentialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmailCredentials to delete
     */
    where?: GmailCredentialsWhereInput
  }

  /**
   * GmailCredentials without action
   */
  export type GmailCredentialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailCredentials
     */
    select?: GmailCredentialsSelect<ExtArgs> | null
  }


  /**
   * Model PlatformSettings
   */

  export type AggregatePlatformSettings = {
    _count: PlatformSettingsCountAggregateOutputType | null
    _avg: PlatformSettingsAvgAggregateOutputType | null
    _sum: PlatformSettingsSumAggregateOutputType | null
    _min: PlatformSettingsMinAggregateOutputType | null
    _max: PlatformSettingsMaxAggregateOutputType | null
  }

  export type PlatformSettingsAvgAggregateOutputType = {
    lowCommission: number | null
    medCommission: number | null
    highCommission: number | null
    commissionDurationMonths: number | null
    payoutMinimum: number | null
    refundHoldDays: number | null
    payoutCycleDelayMonths: number | null
    transactionFeePercent: number | null
    starterLimit: number | null
    professionalLimit: number | null
    enterpriseLimit: number | null
    ltdLimit: number | null
    aiInfraLimit: number | null
  }

  export type PlatformSettingsSumAggregateOutputType = {
    lowCommission: number | null
    medCommission: number | null
    highCommission: number | null
    commissionDurationMonths: number | null
    payoutMinimum: number | null
    refundHoldDays: number | null
    payoutCycleDelayMonths: number | null
    transactionFeePercent: number | null
    starterLimit: number | null
    professionalLimit: number | null
    enterpriseLimit: number | null
    ltdLimit: number | null
    aiInfraLimit: number | null
  }

  export type PlatformSettingsMinAggregateOutputType = {
    id: string | null
    lowCommission: number | null
    medCommission: number | null
    highCommission: number | null
    commissionDurationMonths: number | null
    defaultCommissionLevel: $Enums.CommissionLevel | null
    payoutMinimum: number | null
    refundHoldDays: number | null
    payoutCycleDelayMonths: number | null
    transactionFeePercent: number | null
    starterLimit: number | null
    professionalLimit: number | null
    enterpriseLimit: number | null
    ltdLimit: number | null
    aiInfraLimit: number | null
    updatedAt: Date | null
  }

  export type PlatformSettingsMaxAggregateOutputType = {
    id: string | null
    lowCommission: number | null
    medCommission: number | null
    highCommission: number | null
    commissionDurationMonths: number | null
    defaultCommissionLevel: $Enums.CommissionLevel | null
    payoutMinimum: number | null
    refundHoldDays: number | null
    payoutCycleDelayMonths: number | null
    transactionFeePercent: number | null
    starterLimit: number | null
    professionalLimit: number | null
    enterpriseLimit: number | null
    ltdLimit: number | null
    aiInfraLimit: number | null
    updatedAt: Date | null
  }

  export type PlatformSettingsCountAggregateOutputType = {
    id: number
    lowCommission: number
    medCommission: number
    highCommission: number
    commissionDurationMonths: number
    defaultCommissionLevel: number
    payoutMinimum: number
    refundHoldDays: number
    payoutCycleDelayMonths: number
    transactionFeePercent: number
    starterLimit: number
    professionalLimit: number
    enterpriseLimit: number
    ltdLimit: number
    aiInfraLimit: number
    updatedAt: number
    _all: number
  }


  export type PlatformSettingsAvgAggregateInputType = {
    lowCommission?: true
    medCommission?: true
    highCommission?: true
    commissionDurationMonths?: true
    payoutMinimum?: true
    refundHoldDays?: true
    payoutCycleDelayMonths?: true
    transactionFeePercent?: true
    starterLimit?: true
    professionalLimit?: true
    enterpriseLimit?: true
    ltdLimit?: true
    aiInfraLimit?: true
  }

  export type PlatformSettingsSumAggregateInputType = {
    lowCommission?: true
    medCommission?: true
    highCommission?: true
    commissionDurationMonths?: true
    payoutMinimum?: true
    refundHoldDays?: true
    payoutCycleDelayMonths?: true
    transactionFeePercent?: true
    starterLimit?: true
    professionalLimit?: true
    enterpriseLimit?: true
    ltdLimit?: true
    aiInfraLimit?: true
  }

  export type PlatformSettingsMinAggregateInputType = {
    id?: true
    lowCommission?: true
    medCommission?: true
    highCommission?: true
    commissionDurationMonths?: true
    defaultCommissionLevel?: true
    payoutMinimum?: true
    refundHoldDays?: true
    payoutCycleDelayMonths?: true
    transactionFeePercent?: true
    starterLimit?: true
    professionalLimit?: true
    enterpriseLimit?: true
    ltdLimit?: true
    aiInfraLimit?: true
    updatedAt?: true
  }

  export type PlatformSettingsMaxAggregateInputType = {
    id?: true
    lowCommission?: true
    medCommission?: true
    highCommission?: true
    commissionDurationMonths?: true
    defaultCommissionLevel?: true
    payoutMinimum?: true
    refundHoldDays?: true
    payoutCycleDelayMonths?: true
    transactionFeePercent?: true
    starterLimit?: true
    professionalLimit?: true
    enterpriseLimit?: true
    ltdLimit?: true
    aiInfraLimit?: true
    updatedAt?: true
  }

  export type PlatformSettingsCountAggregateInputType = {
    id?: true
    lowCommission?: true
    medCommission?: true
    highCommission?: true
    commissionDurationMonths?: true
    defaultCommissionLevel?: true
    payoutMinimum?: true
    refundHoldDays?: true
    payoutCycleDelayMonths?: true
    transactionFeePercent?: true
    starterLimit?: true
    professionalLimit?: true
    enterpriseLimit?: true
    ltdLimit?: true
    aiInfraLimit?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSettings to aggregate.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformSettings
    **/
    _count?: true | PlatformSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformSettingsMaxAggregateInputType
  }

  export type GetPlatformSettingsAggregateType<T extends PlatformSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformSettings[P]>
      : GetScalarType<T[P], AggregatePlatformSettings[P]>
  }




  export type PlatformSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformSettingsWhereInput
    orderBy?: PlatformSettingsOrderByWithAggregationInput | PlatformSettingsOrderByWithAggregationInput[]
    by: PlatformSettingsScalarFieldEnum[] | PlatformSettingsScalarFieldEnum
    having?: PlatformSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformSettingsCountAggregateInputType | true
    _avg?: PlatformSettingsAvgAggregateInputType
    _sum?: PlatformSettingsSumAggregateInputType
    _min?: PlatformSettingsMinAggregateInputType
    _max?: PlatformSettingsMaxAggregateInputType
  }

  export type PlatformSettingsGroupByOutputType = {
    id: string
    lowCommission: number
    medCommission: number
    highCommission: number
    commissionDurationMonths: number
    defaultCommissionLevel: $Enums.CommissionLevel
    payoutMinimum: number
    refundHoldDays: number
    payoutCycleDelayMonths: number
    transactionFeePercent: number
    starterLimit: number
    professionalLimit: number
    enterpriseLimit: number
    ltdLimit: number
    aiInfraLimit: number
    updatedAt: Date
    _count: PlatformSettingsCountAggregateOutputType | null
    _avg: PlatformSettingsAvgAggregateOutputType | null
    _sum: PlatformSettingsSumAggregateOutputType | null
    _min: PlatformSettingsMinAggregateOutputType | null
    _max: PlatformSettingsMaxAggregateOutputType | null
  }

  type GetPlatformSettingsGroupByPayload<T extends PlatformSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformSettingsGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lowCommission?: boolean
    medCommission?: boolean
    highCommission?: boolean
    commissionDurationMonths?: boolean
    defaultCommissionLevel?: boolean
    payoutMinimum?: boolean
    refundHoldDays?: boolean
    payoutCycleDelayMonths?: boolean
    transactionFeePercent?: boolean
    starterLimit?: boolean
    professionalLimit?: boolean
    enterpriseLimit?: boolean
    ltdLimit?: boolean
    aiInfraLimit?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platformSettings"]>

  export type PlatformSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lowCommission?: boolean
    medCommission?: boolean
    highCommission?: boolean
    commissionDurationMonths?: boolean
    defaultCommissionLevel?: boolean
    payoutMinimum?: boolean
    refundHoldDays?: boolean
    payoutCycleDelayMonths?: boolean
    transactionFeePercent?: boolean
    starterLimit?: boolean
    professionalLimit?: boolean
    enterpriseLimit?: boolean
    ltdLimit?: boolean
    aiInfraLimit?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platformSettings"]>

  export type PlatformSettingsSelectScalar = {
    id?: boolean
    lowCommission?: boolean
    medCommission?: boolean
    highCommission?: boolean
    commissionDurationMonths?: boolean
    defaultCommissionLevel?: boolean
    payoutMinimum?: boolean
    refundHoldDays?: boolean
    payoutCycleDelayMonths?: boolean
    transactionFeePercent?: boolean
    starterLimit?: boolean
    professionalLimit?: boolean
    enterpriseLimit?: boolean
    ltdLimit?: boolean
    aiInfraLimit?: boolean
    updatedAt?: boolean
  }


  export type $PlatformSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lowCommission: number
      medCommission: number
      highCommission: number
      commissionDurationMonths: number
      defaultCommissionLevel: $Enums.CommissionLevel
      payoutMinimum: number
      refundHoldDays: number
      payoutCycleDelayMonths: number
      transactionFeePercent: number
      starterLimit: number
      professionalLimit: number
      enterpriseLimit: number
      ltdLimit: number
      aiInfraLimit: number
      updatedAt: Date
    }, ExtArgs["result"]["platformSettings"]>
    composites: {}
  }

  type PlatformSettingsGetPayload<S extends boolean | null | undefined | PlatformSettingsDefaultArgs> = $Result.GetResult<Prisma.$PlatformSettingsPayload, S>

  type PlatformSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlatformSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlatformSettingsCountAggregateInputType | true
    }

  export interface PlatformSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformSettings'], meta: { name: 'PlatformSettings' } }
    /**
     * Find zero or one PlatformSettings that matches the filter.
     * @param {PlatformSettingsFindUniqueArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformSettingsFindUniqueArgs>(args: SelectSubset<T, PlatformSettingsFindUniqueArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlatformSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlatformSettingsFindUniqueOrThrowArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlatformSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsFindFirstArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformSettingsFindFirstArgs>(args?: SelectSubset<T, PlatformSettingsFindFirstArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlatformSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsFindFirstOrThrowArgs} args - Arguments to find a PlatformSettings
     * @example
     * // Get one PlatformSettings
     * const platformSettings = await prisma.platformSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlatformSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformSettings
     * const platformSettings = await prisma.platformSettings.findMany()
     * 
     * // Get first 10 PlatformSettings
     * const platformSettings = await prisma.platformSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformSettingsWithIdOnly = await prisma.platformSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformSettingsFindManyArgs>(args?: SelectSubset<T, PlatformSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlatformSettings.
     * @param {PlatformSettingsCreateArgs} args - Arguments to create a PlatformSettings.
     * @example
     * // Create one PlatformSettings
     * const PlatformSettings = await prisma.platformSettings.create({
     *   data: {
     *     // ... data to create a PlatformSettings
     *   }
     * })
     * 
     */
    create<T extends PlatformSettingsCreateArgs>(args: SelectSubset<T, PlatformSettingsCreateArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlatformSettings.
     * @param {PlatformSettingsCreateManyArgs} args - Arguments to create many PlatformSettings.
     * @example
     * // Create many PlatformSettings
     * const platformSettings = await prisma.platformSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformSettingsCreateManyArgs>(args?: SelectSubset<T, PlatformSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformSettings and returns the data saved in the database.
     * @param {PlatformSettingsCreateManyAndReturnArgs} args - Arguments to create many PlatformSettings.
     * @example
     * // Create many PlatformSettings
     * const platformSettings = await prisma.platformSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformSettings and only return the `id`
     * const platformSettingsWithIdOnly = await prisma.platformSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlatformSettings.
     * @param {PlatformSettingsDeleteArgs} args - Arguments to delete one PlatformSettings.
     * @example
     * // Delete one PlatformSettings
     * const PlatformSettings = await prisma.platformSettings.delete({
     *   where: {
     *     // ... filter to delete one PlatformSettings
     *   }
     * })
     * 
     */
    delete<T extends PlatformSettingsDeleteArgs>(args: SelectSubset<T, PlatformSettingsDeleteArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlatformSettings.
     * @param {PlatformSettingsUpdateArgs} args - Arguments to update one PlatformSettings.
     * @example
     * // Update one PlatformSettings
     * const platformSettings = await prisma.platformSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformSettingsUpdateArgs>(args: SelectSubset<T, PlatformSettingsUpdateArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlatformSettings.
     * @param {PlatformSettingsDeleteManyArgs} args - Arguments to filter PlatformSettings to delete.
     * @example
     * // Delete a few PlatformSettings
     * const { count } = await prisma.platformSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformSettingsDeleteManyArgs>(args?: SelectSubset<T, PlatformSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformSettings
     * const platformSettings = await prisma.platformSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformSettingsUpdateManyArgs>(args: SelectSubset<T, PlatformSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlatformSettings.
     * @param {PlatformSettingsUpsertArgs} args - Arguments to update or create a PlatformSettings.
     * @example
     * // Update or create a PlatformSettings
     * const platformSettings = await prisma.platformSettings.upsert({
     *   create: {
     *     // ... data to create a PlatformSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformSettings we want to update
     *   }
     * })
     */
    upsert<T extends PlatformSettingsUpsertArgs>(args: SelectSubset<T, PlatformSettingsUpsertArgs<ExtArgs>>): Prisma__PlatformSettingsClient<$Result.GetResult<Prisma.$PlatformSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsCountArgs} args - Arguments to filter PlatformSettings to count.
     * @example
     * // Count the number of PlatformSettings
     * const count = await prisma.platformSettings.count({
     *   where: {
     *     // ... the filter for the PlatformSettings we want to count
     *   }
     * })
    **/
    count<T extends PlatformSettingsCountArgs>(
      args?: Subset<T, PlatformSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformSettingsAggregateArgs>(args: Subset<T, PlatformSettingsAggregateArgs>): Prisma.PrismaPromise<GetPlatformSettingsAggregateType<T>>

    /**
     * Group by PlatformSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformSettingsGroupByArgs['orderBy'] }
        : { orderBy?: PlatformSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformSettings model
   */
  readonly fields: PlatformSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformSettings model
   */ 
  interface PlatformSettingsFieldRefs {
    readonly id: FieldRef<"PlatformSettings", 'String'>
    readonly lowCommission: FieldRef<"PlatformSettings", 'Float'>
    readonly medCommission: FieldRef<"PlatformSettings", 'Float'>
    readonly highCommission: FieldRef<"PlatformSettings", 'Float'>
    readonly commissionDurationMonths: FieldRef<"PlatformSettings", 'Int'>
    readonly defaultCommissionLevel: FieldRef<"PlatformSettings", 'CommissionLevel'>
    readonly payoutMinimum: FieldRef<"PlatformSettings", 'Float'>
    readonly refundHoldDays: FieldRef<"PlatformSettings", 'Int'>
    readonly payoutCycleDelayMonths: FieldRef<"PlatformSettings", 'Int'>
    readonly transactionFeePercent: FieldRef<"PlatformSettings", 'Float'>
    readonly starterLimit: FieldRef<"PlatformSettings", 'Int'>
    readonly professionalLimit: FieldRef<"PlatformSettings", 'Int'>
    readonly enterpriseLimit: FieldRef<"PlatformSettings", 'Int'>
    readonly ltdLimit: FieldRef<"PlatformSettings", 'Int'>
    readonly aiInfraLimit: FieldRef<"PlatformSettings", 'Int'>
    readonly updatedAt: FieldRef<"PlatformSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformSettings findUnique
   */
  export type PlatformSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings findUniqueOrThrow
   */
  export type PlatformSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings findFirst
   */
  export type PlatformSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSettings.
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSettings.
     */
    distinct?: PlatformSettingsScalarFieldEnum | PlatformSettingsScalarFieldEnum[]
  }

  /**
   * PlatformSettings findFirstOrThrow
   */
  export type PlatformSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSettings.
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSettings.
     */
    distinct?: PlatformSettingsScalarFieldEnum | PlatformSettingsScalarFieldEnum[]
  }

  /**
   * PlatformSettings findMany
   */
  export type PlatformSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSettings to fetch.
     */
    where?: PlatformSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSettings to fetch.
     */
    orderBy?: PlatformSettingsOrderByWithRelationInput | PlatformSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformSettings.
     */
    cursor?: PlatformSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSettings.
     */
    skip?: number
    distinct?: PlatformSettingsScalarFieldEnum | PlatformSettingsScalarFieldEnum[]
  }

  /**
   * PlatformSettings create
   */
  export type PlatformSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a PlatformSettings.
     */
    data: XOR<PlatformSettingsCreateInput, PlatformSettingsUncheckedCreateInput>
  }

  /**
   * PlatformSettings createMany
   */
  export type PlatformSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformSettings.
     */
    data: PlatformSettingsCreateManyInput | PlatformSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformSettings createManyAndReturn
   */
  export type PlatformSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlatformSettings.
     */
    data: PlatformSettingsCreateManyInput | PlatformSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformSettings update
   */
  export type PlatformSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a PlatformSettings.
     */
    data: XOR<PlatformSettingsUpdateInput, PlatformSettingsUncheckedUpdateInput>
    /**
     * Choose, which PlatformSettings to update.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings updateMany
   */
  export type PlatformSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformSettings.
     */
    data: XOR<PlatformSettingsUpdateManyMutationInput, PlatformSettingsUncheckedUpdateManyInput>
    /**
     * Filter which PlatformSettings to update
     */
    where?: PlatformSettingsWhereInput
  }

  /**
   * PlatformSettings upsert
   */
  export type PlatformSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the PlatformSettings to update in case it exists.
     */
    where: PlatformSettingsWhereUniqueInput
    /**
     * In case the PlatformSettings found by the `where` argument doesn't exist, create a new PlatformSettings with this data.
     */
    create: XOR<PlatformSettingsCreateInput, PlatformSettingsUncheckedCreateInput>
    /**
     * In case the PlatformSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformSettingsUpdateInput, PlatformSettingsUncheckedUpdateInput>
  }

  /**
   * PlatformSettings delete
   */
  export type PlatformSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
    /**
     * Filter which PlatformSettings to delete.
     */
    where: PlatformSettingsWhereUniqueInput
  }

  /**
   * PlatformSettings deleteMany
   */
  export type PlatformSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSettings to delete
     */
    where?: PlatformSettingsWhereInput
  }

  /**
   * PlatformSettings without action
   */
  export type PlatformSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSettings
     */
    select?: PlatformSettingsSelect<ExtArgs> | null
  }


  /**
   * Model Affiliate
   */

  export type AggregateAffiliate = {
    _count: AffiliateCountAggregateOutputType | null
    _avg: AffiliateAvgAggregateOutputType | null
    _sum: AffiliateSumAggregateOutputType | null
    _min: AffiliateMinAggregateOutputType | null
    _max: AffiliateMaxAggregateOutputType | null
  }

  export type AffiliateAvgAggregateOutputType = {
    lockedCommissionRate: number | null
    customCommissionRate: number | null
    totalEarnings: number | null
    totalPaid: number | null
    balance: number | null
  }

  export type AffiliateSumAggregateOutputType = {
    lockedCommissionRate: number | null
    customCommissionRate: number | null
    totalEarnings: number | null
    totalPaid: number | null
    balance: number | null
  }

  export type AffiliateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.AffiliateStatus | null
    slug: string | null
    paymentInfo: string | null
    payoutMethod: string | null
    payoutEmail: string | null
    payoutPhone: string | null
    stripeAccountId: string | null
    stripeAccountStatus: string | null
    taxFormCompleted: boolean | null
    tax1099Uploaded: boolean | null
    lastPayoutAt: Date | null
    lockedCommissionRate: number | null
    customCommissionRate: number | null
    totalEarnings: number | null
    totalPaid: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.AffiliateStatus | null
    slug: string | null
    paymentInfo: string | null
    payoutMethod: string | null
    payoutEmail: string | null
    payoutPhone: string | null
    stripeAccountId: string | null
    stripeAccountStatus: string | null
    taxFormCompleted: boolean | null
    tax1099Uploaded: boolean | null
    lastPayoutAt: Date | null
    lockedCommissionRate: number | null
    customCommissionRate: number | null
    totalEarnings: number | null
    totalPaid: number | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    slug: number
    paymentInfo: number
    payoutMethod: number
    payoutEmail: number
    payoutPhone: number
    stripeAccountId: number
    stripeAccountStatus: number
    taxFormCompleted: number
    tax1099Uploaded: number
    lastPayoutAt: number
    lockedCommissionRate: number
    customCommissionRate: number
    totalEarnings: number
    totalPaid: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AffiliateAvgAggregateInputType = {
    lockedCommissionRate?: true
    customCommissionRate?: true
    totalEarnings?: true
    totalPaid?: true
    balance?: true
  }

  export type AffiliateSumAggregateInputType = {
    lockedCommissionRate?: true
    customCommissionRate?: true
    totalEarnings?: true
    totalPaid?: true
    balance?: true
  }

  export type AffiliateMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    slug?: true
    paymentInfo?: true
    payoutMethod?: true
    payoutEmail?: true
    payoutPhone?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
    taxFormCompleted?: true
    tax1099Uploaded?: true
    lastPayoutAt?: true
    lockedCommissionRate?: true
    customCommissionRate?: true
    totalEarnings?: true
    totalPaid?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    slug?: true
    paymentInfo?: true
    payoutMethod?: true
    payoutEmail?: true
    payoutPhone?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
    taxFormCompleted?: true
    tax1099Uploaded?: true
    lastPayoutAt?: true
    lockedCommissionRate?: true
    customCommissionRate?: true
    totalEarnings?: true
    totalPaid?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    slug?: true
    paymentInfo?: true
    payoutMethod?: true
    payoutEmail?: true
    payoutPhone?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
    taxFormCompleted?: true
    tax1099Uploaded?: true
    lastPayoutAt?: true
    lockedCommissionRate?: true
    customCommissionRate?: true
    totalEarnings?: true
    totalPaid?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AffiliateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliate to aggregate.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Affiliates
    **/
    _count?: true | AffiliateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateMaxAggregateInputType
  }

  export type GetAffiliateAggregateType<T extends AffiliateAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliate[P]>
      : GetScalarType<T[P], AggregateAffiliate[P]>
  }




  export type AffiliateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateWhereInput
    orderBy?: AffiliateOrderByWithAggregationInput | AffiliateOrderByWithAggregationInput[]
    by: AffiliateScalarFieldEnum[] | AffiliateScalarFieldEnum
    having?: AffiliateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateCountAggregateInputType | true
    _avg?: AffiliateAvgAggregateInputType
    _sum?: AffiliateSumAggregateInputType
    _min?: AffiliateMinAggregateInputType
    _max?: AffiliateMaxAggregateInputType
  }

  export type AffiliateGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.AffiliateStatus
    slug: string
    paymentInfo: string | null
    payoutMethod: string | null
    payoutEmail: string | null
    payoutPhone: string | null
    stripeAccountId: string | null
    stripeAccountStatus: string | null
    taxFormCompleted: boolean
    tax1099Uploaded: boolean
    lastPayoutAt: Date | null
    lockedCommissionRate: number | null
    customCommissionRate: number | null
    totalEarnings: number
    totalPaid: number
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: AffiliateCountAggregateOutputType | null
    _avg: AffiliateAvgAggregateOutputType | null
    _sum: AffiliateSumAggregateOutputType | null
    _min: AffiliateMinAggregateOutputType | null
    _max: AffiliateMaxAggregateOutputType | null
  }

  type GetAffiliateGroupByPayload<T extends AffiliateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    slug?: boolean
    paymentInfo?: boolean
    payoutMethod?: boolean
    payoutEmail?: boolean
    payoutPhone?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: boolean
    lockedCommissionRate?: boolean
    customCommissionRate?: boolean
    totalEarnings?: boolean
    totalPaid?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    referrals?: boolean | Affiliate$referralsArgs<ExtArgs>
    payouts?: boolean | Affiliate$payoutsArgs<ExtArgs>
    _count?: boolean | AffiliateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate"]>

  export type AffiliateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    slug?: boolean
    paymentInfo?: boolean
    payoutMethod?: boolean
    payoutEmail?: boolean
    payoutPhone?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: boolean
    lockedCommissionRate?: boolean
    customCommissionRate?: boolean
    totalEarnings?: boolean
    totalPaid?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate"]>

  export type AffiliateSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    slug?: boolean
    paymentInfo?: boolean
    payoutMethod?: boolean
    payoutEmail?: boolean
    payoutPhone?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: boolean
    lockedCommissionRate?: boolean
    customCommissionRate?: boolean
    totalEarnings?: boolean
    totalPaid?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AffiliateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    referrals?: boolean | Affiliate$referralsArgs<ExtArgs>
    payouts?: boolean | Affiliate$payoutsArgs<ExtArgs>
    _count?: boolean | AffiliateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AffiliatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Affiliate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      referrals: Prisma.$AffiliateReferralPayload<ExtArgs>[]
      payouts: Prisma.$AffiliatePayoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.AffiliateStatus
      slug: string
      paymentInfo: string | null
      payoutMethod: string | null
      payoutEmail: string | null
      payoutPhone: string | null
      stripeAccountId: string | null
      stripeAccountStatus: string | null
      taxFormCompleted: boolean
      tax1099Uploaded: boolean
      lastPayoutAt: Date | null
      lockedCommissionRate: number | null
      customCommissionRate: number | null
      totalEarnings: number
      totalPaid: number
      balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["affiliate"]>
    composites: {}
  }

  type AffiliateGetPayload<S extends boolean | null | undefined | AffiliateDefaultArgs> = $Result.GetResult<Prisma.$AffiliatePayload, S>

  type AffiliateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateCountAggregateInputType | true
    }

  export interface AffiliateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Affiliate'], meta: { name: 'Affiliate' } }
    /**
     * Find zero or one Affiliate that matches the filter.
     * @param {AffiliateFindUniqueArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateFindUniqueArgs>(args: SelectSubset<T, AffiliateFindUniqueArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Affiliate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateFindUniqueOrThrowArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Affiliate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateFindFirstArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateFindFirstArgs>(args?: SelectSubset<T, AffiliateFindFirstArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Affiliate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateFindFirstOrThrowArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Affiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliates
     * const affiliates = await prisma.affiliate.findMany()
     * 
     * // Get first 10 Affiliates
     * const affiliates = await prisma.affiliate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateWithIdOnly = await prisma.affiliate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateFindManyArgs>(args?: SelectSubset<T, AffiliateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Affiliate.
     * @param {AffiliateCreateArgs} args - Arguments to create a Affiliate.
     * @example
     * // Create one Affiliate
     * const Affiliate = await prisma.affiliate.create({
     *   data: {
     *     // ... data to create a Affiliate
     *   }
     * })
     * 
     */
    create<T extends AffiliateCreateArgs>(args: SelectSubset<T, AffiliateCreateArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Affiliates.
     * @param {AffiliateCreateManyArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliate = await prisma.affiliate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateCreateManyArgs>(args?: SelectSubset<T, AffiliateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Affiliates and returns the data saved in the database.
     * @param {AffiliateCreateManyAndReturnArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliate = await prisma.affiliate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Affiliates and only return the `id`
     * const affiliateWithIdOnly = await prisma.affiliate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Affiliate.
     * @param {AffiliateDeleteArgs} args - Arguments to delete one Affiliate.
     * @example
     * // Delete one Affiliate
     * const Affiliate = await prisma.affiliate.delete({
     *   where: {
     *     // ... filter to delete one Affiliate
     *   }
     * })
     * 
     */
    delete<T extends AffiliateDeleteArgs>(args: SelectSubset<T, AffiliateDeleteArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Affiliate.
     * @param {AffiliateUpdateArgs} args - Arguments to update one Affiliate.
     * @example
     * // Update one Affiliate
     * const affiliate = await prisma.affiliate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateUpdateArgs>(args: SelectSubset<T, AffiliateUpdateArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Affiliates.
     * @param {AffiliateDeleteManyArgs} args - Arguments to filter Affiliates to delete.
     * @example
     * // Delete a few Affiliates
     * const { count } = await prisma.affiliate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateDeleteManyArgs>(args?: SelectSubset<T, AffiliateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliates
     * const affiliate = await prisma.affiliate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateUpdateManyArgs>(args: SelectSubset<T, AffiliateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Affiliate.
     * @param {AffiliateUpsertArgs} args - Arguments to update or create a Affiliate.
     * @example
     * // Update or create a Affiliate
     * const affiliate = await prisma.affiliate.upsert({
     *   create: {
     *     // ... data to create a Affiliate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliate we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateUpsertArgs>(args: SelectSubset<T, AffiliateUpsertArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateCountArgs} args - Arguments to filter Affiliates to count.
     * @example
     * // Count the number of Affiliates
     * const count = await prisma.affiliate.count({
     *   where: {
     *     // ... the filter for the Affiliates we want to count
     *   }
     * })
    **/
    count<T extends AffiliateCountArgs>(
      args?: Subset<T, AffiliateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateAggregateArgs>(args: Subset<T, AffiliateAggregateArgs>): Prisma.PrismaPromise<GetAffiliateAggregateType<T>>

    /**
     * Group by Affiliate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Affiliate model
   */
  readonly fields: AffiliateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Affiliate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referrals<T extends Affiliate$referralsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliate$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "findMany"> | Null>
    payouts<T extends Affiliate$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliate$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Affiliate model
   */ 
  interface AffiliateFieldRefs {
    readonly id: FieldRef<"Affiliate", 'String'>
    readonly userId: FieldRef<"Affiliate", 'String'>
    readonly status: FieldRef<"Affiliate", 'AffiliateStatus'>
    readonly slug: FieldRef<"Affiliate", 'String'>
    readonly paymentInfo: FieldRef<"Affiliate", 'String'>
    readonly payoutMethod: FieldRef<"Affiliate", 'String'>
    readonly payoutEmail: FieldRef<"Affiliate", 'String'>
    readonly payoutPhone: FieldRef<"Affiliate", 'String'>
    readonly stripeAccountId: FieldRef<"Affiliate", 'String'>
    readonly stripeAccountStatus: FieldRef<"Affiliate", 'String'>
    readonly taxFormCompleted: FieldRef<"Affiliate", 'Boolean'>
    readonly tax1099Uploaded: FieldRef<"Affiliate", 'Boolean'>
    readonly lastPayoutAt: FieldRef<"Affiliate", 'DateTime'>
    readonly lockedCommissionRate: FieldRef<"Affiliate", 'Float'>
    readonly customCommissionRate: FieldRef<"Affiliate", 'Float'>
    readonly totalEarnings: FieldRef<"Affiliate", 'Float'>
    readonly totalPaid: FieldRef<"Affiliate", 'Float'>
    readonly balance: FieldRef<"Affiliate", 'Float'>
    readonly createdAt: FieldRef<"Affiliate", 'DateTime'>
    readonly updatedAt: FieldRef<"Affiliate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Affiliate findUnique
   */
  export type AffiliateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate findUniqueOrThrow
   */
  export type AffiliateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate findFirst
   */
  export type AffiliateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * Affiliate findFirstOrThrow
   */
  export type AffiliateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * Affiliate findMany
   */
  export type AffiliateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Affiliates.
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * Affiliate create
   */
  export type AffiliateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * The data needed to create a Affiliate.
     */
    data: XOR<AffiliateCreateInput, AffiliateUncheckedCreateInput>
  }

  /**
   * Affiliate createMany
   */
  export type AffiliateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliateCreateManyInput | AffiliateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliate createManyAndReturn
   */
  export type AffiliateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliateCreateManyInput | AffiliateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Affiliate update
   */
  export type AffiliateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * The data needed to update a Affiliate.
     */
    data: XOR<AffiliateUpdateInput, AffiliateUncheckedUpdateInput>
    /**
     * Choose, which Affiliate to update.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate updateMany
   */
  export type AffiliateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Affiliates.
     */
    data: XOR<AffiliateUpdateManyMutationInput, AffiliateUncheckedUpdateManyInput>
    /**
     * Filter which Affiliates to update
     */
    where?: AffiliateWhereInput
  }

  /**
   * Affiliate upsert
   */
  export type AffiliateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * The filter to search for the Affiliate to update in case it exists.
     */
    where: AffiliateWhereUniqueInput
    /**
     * In case the Affiliate found by the `where` argument doesn't exist, create a new Affiliate with this data.
     */
    create: XOR<AffiliateCreateInput, AffiliateUncheckedCreateInput>
    /**
     * In case the Affiliate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateUpdateInput, AffiliateUncheckedUpdateInput>
  }

  /**
   * Affiliate delete
   */
  export type AffiliateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter which Affiliate to delete.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate deleteMany
   */
  export type AffiliateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliates to delete
     */
    where?: AffiliateWhereInput
  }

  /**
   * Affiliate.referrals
   */
  export type Affiliate$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    where?: AffiliateReferralWhereInput
    orderBy?: AffiliateReferralOrderByWithRelationInput | AffiliateReferralOrderByWithRelationInput[]
    cursor?: AffiliateReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateReferralScalarFieldEnum | AffiliateReferralScalarFieldEnum[]
  }

  /**
   * Affiliate.payouts
   */
  export type Affiliate$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    where?: AffiliatePayoutWhereInput
    orderBy?: AffiliatePayoutOrderByWithRelationInput | AffiliatePayoutOrderByWithRelationInput[]
    cursor?: AffiliatePayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliatePayoutScalarFieldEnum | AffiliatePayoutScalarFieldEnum[]
  }

  /**
   * Affiliate without action
   */
  export type AffiliateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateReferral
   */

  export type AggregateAffiliateReferral = {
    _count: AffiliateReferralCountAggregateOutputType | null
    _avg: AffiliateReferralAvgAggregateOutputType | null
    _sum: AffiliateReferralSumAggregateOutputType | null
    _min: AffiliateReferralMinAggregateOutputType | null
    _max: AffiliateReferralMaxAggregateOutputType | null
  }

  export type AffiliateReferralAvgAggregateOutputType = {
    commissionAmount: number | null
  }

  export type AffiliateReferralSumAggregateOutputType = {
    commissionAmount: number | null
  }

  export type AffiliateReferralMinAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    refereeId: string | null
    status: $Enums.AffiliateReferralStatus | null
    commissionAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateReferralMaxAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    refereeId: string | null
    status: $Enums.AffiliateReferralStatus | null
    commissionAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateReferralCountAggregateOutputType = {
    id: number
    affiliateId: number
    refereeId: number
    status: number
    commissionAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AffiliateReferralAvgAggregateInputType = {
    commissionAmount?: true
  }

  export type AffiliateReferralSumAggregateInputType = {
    commissionAmount?: true
  }

  export type AffiliateReferralMinAggregateInputType = {
    id?: true
    affiliateId?: true
    refereeId?: true
    status?: true
    commissionAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateReferralMaxAggregateInputType = {
    id?: true
    affiliateId?: true
    refereeId?: true
    status?: true
    commissionAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateReferralCountAggregateInputType = {
    id?: true
    affiliateId?: true
    refereeId?: true
    status?: true
    commissionAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AffiliateReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateReferral to aggregate.
     */
    where?: AffiliateReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateReferrals to fetch.
     */
    orderBy?: AffiliateReferralOrderByWithRelationInput | AffiliateReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateReferrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateReferrals
    **/
    _count?: true | AffiliateReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateReferralMaxAggregateInputType
  }

  export type GetAffiliateReferralAggregateType<T extends AffiliateReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateReferral[P]>
      : GetScalarType<T[P], AggregateAffiliateReferral[P]>
  }




  export type AffiliateReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateReferralWhereInput
    orderBy?: AffiliateReferralOrderByWithAggregationInput | AffiliateReferralOrderByWithAggregationInput[]
    by: AffiliateReferralScalarFieldEnum[] | AffiliateReferralScalarFieldEnum
    having?: AffiliateReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateReferralCountAggregateInputType | true
    _avg?: AffiliateReferralAvgAggregateInputType
    _sum?: AffiliateReferralSumAggregateInputType
    _min?: AffiliateReferralMinAggregateInputType
    _max?: AffiliateReferralMaxAggregateInputType
  }

  export type AffiliateReferralGroupByOutputType = {
    id: string
    affiliateId: string
    refereeId: string | null
    status: $Enums.AffiliateReferralStatus
    commissionAmount: number
    createdAt: Date
    updatedAt: Date
    _count: AffiliateReferralCountAggregateOutputType | null
    _avg: AffiliateReferralAvgAggregateOutputType | null
    _sum: AffiliateReferralSumAggregateOutputType | null
    _min: AffiliateReferralMinAggregateOutputType | null
    _max: AffiliateReferralMaxAggregateOutputType | null
  }

  type GetAffiliateReferralGroupByPayload<T extends AffiliateReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateReferralGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateReferralGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    refereeId?: boolean
    status?: boolean
    commissionAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateReferral"]>

  export type AffiliateReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    refereeId?: boolean
    status?: boolean
    commissionAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateReferral"]>

  export type AffiliateReferralSelectScalar = {
    id?: boolean
    affiliateId?: boolean
    refereeId?: boolean
    status?: boolean
    commissionAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AffiliateReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }
  export type AffiliateReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }

  export type $AffiliateReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateReferral"
    objects: {
      affiliate: Prisma.$AffiliatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateId: string
      refereeId: string | null
      status: $Enums.AffiliateReferralStatus
      commissionAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["affiliateReferral"]>
    composites: {}
  }

  type AffiliateReferralGetPayload<S extends boolean | null | undefined | AffiliateReferralDefaultArgs> = $Result.GetResult<Prisma.$AffiliateReferralPayload, S>

  type AffiliateReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateReferralCountAggregateInputType | true
    }

  export interface AffiliateReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateReferral'], meta: { name: 'AffiliateReferral' } }
    /**
     * Find zero or one AffiliateReferral that matches the filter.
     * @param {AffiliateReferralFindUniqueArgs} args - Arguments to find a AffiliateReferral
     * @example
     * // Get one AffiliateReferral
     * const affiliateReferral = await prisma.affiliateReferral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateReferralFindUniqueArgs>(args: SelectSubset<T, AffiliateReferralFindUniqueArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateReferral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateReferralFindUniqueOrThrowArgs} args - Arguments to find a AffiliateReferral
     * @example
     * // Get one AffiliateReferral
     * const affiliateReferral = await prisma.affiliateReferral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateReferral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateReferralFindFirstArgs} args - Arguments to find a AffiliateReferral
     * @example
     * // Get one AffiliateReferral
     * const affiliateReferral = await prisma.affiliateReferral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateReferralFindFirstArgs>(args?: SelectSubset<T, AffiliateReferralFindFirstArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateReferral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateReferralFindFirstOrThrowArgs} args - Arguments to find a AffiliateReferral
     * @example
     * // Get one AffiliateReferral
     * const affiliateReferral = await prisma.affiliateReferral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateReferrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateReferrals
     * const affiliateReferrals = await prisma.affiliateReferral.findMany()
     * 
     * // Get first 10 AffiliateReferrals
     * const affiliateReferrals = await prisma.affiliateReferral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateReferralWithIdOnly = await prisma.affiliateReferral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateReferralFindManyArgs>(args?: SelectSubset<T, AffiliateReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateReferral.
     * @param {AffiliateReferralCreateArgs} args - Arguments to create a AffiliateReferral.
     * @example
     * // Create one AffiliateReferral
     * const AffiliateReferral = await prisma.affiliateReferral.create({
     *   data: {
     *     // ... data to create a AffiliateReferral
     *   }
     * })
     * 
     */
    create<T extends AffiliateReferralCreateArgs>(args: SelectSubset<T, AffiliateReferralCreateArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateReferrals.
     * @param {AffiliateReferralCreateManyArgs} args - Arguments to create many AffiliateReferrals.
     * @example
     * // Create many AffiliateReferrals
     * const affiliateReferral = await prisma.affiliateReferral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateReferralCreateManyArgs>(args?: SelectSubset<T, AffiliateReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateReferrals and returns the data saved in the database.
     * @param {AffiliateReferralCreateManyAndReturnArgs} args - Arguments to create many AffiliateReferrals.
     * @example
     * // Create many AffiliateReferrals
     * const affiliateReferral = await prisma.affiliateReferral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateReferrals and only return the `id`
     * const affiliateReferralWithIdOnly = await prisma.affiliateReferral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateReferral.
     * @param {AffiliateReferralDeleteArgs} args - Arguments to delete one AffiliateReferral.
     * @example
     * // Delete one AffiliateReferral
     * const AffiliateReferral = await prisma.affiliateReferral.delete({
     *   where: {
     *     // ... filter to delete one AffiliateReferral
     *   }
     * })
     * 
     */
    delete<T extends AffiliateReferralDeleteArgs>(args: SelectSubset<T, AffiliateReferralDeleteArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateReferral.
     * @param {AffiliateReferralUpdateArgs} args - Arguments to update one AffiliateReferral.
     * @example
     * // Update one AffiliateReferral
     * const affiliateReferral = await prisma.affiliateReferral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateReferralUpdateArgs>(args: SelectSubset<T, AffiliateReferralUpdateArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateReferrals.
     * @param {AffiliateReferralDeleteManyArgs} args - Arguments to filter AffiliateReferrals to delete.
     * @example
     * // Delete a few AffiliateReferrals
     * const { count } = await prisma.affiliateReferral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateReferralDeleteManyArgs>(args?: SelectSubset<T, AffiliateReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateReferrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateReferrals
     * const affiliateReferral = await prisma.affiliateReferral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateReferralUpdateManyArgs>(args: SelectSubset<T, AffiliateReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateReferral.
     * @param {AffiliateReferralUpsertArgs} args - Arguments to update or create a AffiliateReferral.
     * @example
     * // Update or create a AffiliateReferral
     * const affiliateReferral = await prisma.affiliateReferral.upsert({
     *   create: {
     *     // ... data to create a AffiliateReferral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateReferral we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateReferralUpsertArgs>(args: SelectSubset<T, AffiliateReferralUpsertArgs<ExtArgs>>): Prisma__AffiliateReferralClient<$Result.GetResult<Prisma.$AffiliateReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateReferrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateReferralCountArgs} args - Arguments to filter AffiliateReferrals to count.
     * @example
     * // Count the number of AffiliateReferrals
     * const count = await prisma.affiliateReferral.count({
     *   where: {
     *     // ... the filter for the AffiliateReferrals we want to count
     *   }
     * })
    **/
    count<T extends AffiliateReferralCountArgs>(
      args?: Subset<T, AffiliateReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateReferral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateReferralAggregateArgs>(args: Subset<T, AffiliateReferralAggregateArgs>): Prisma.PrismaPromise<GetAffiliateReferralAggregateType<T>>

    /**
     * Group by AffiliateReferral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateReferralGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateReferral model
   */
  readonly fields: AffiliateReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateReferral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends AffiliateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateDefaultArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateReferral model
   */ 
  interface AffiliateReferralFieldRefs {
    readonly id: FieldRef<"AffiliateReferral", 'String'>
    readonly affiliateId: FieldRef<"AffiliateReferral", 'String'>
    readonly refereeId: FieldRef<"AffiliateReferral", 'String'>
    readonly status: FieldRef<"AffiliateReferral", 'AffiliateReferralStatus'>
    readonly commissionAmount: FieldRef<"AffiliateReferral", 'Float'>
    readonly createdAt: FieldRef<"AffiliateReferral", 'DateTime'>
    readonly updatedAt: FieldRef<"AffiliateReferral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateReferral findUnique
   */
  export type AffiliateReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateReferral to fetch.
     */
    where: AffiliateReferralWhereUniqueInput
  }

  /**
   * AffiliateReferral findUniqueOrThrow
   */
  export type AffiliateReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateReferral to fetch.
     */
    where: AffiliateReferralWhereUniqueInput
  }

  /**
   * AffiliateReferral findFirst
   */
  export type AffiliateReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateReferral to fetch.
     */
    where?: AffiliateReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateReferrals to fetch.
     */
    orderBy?: AffiliateReferralOrderByWithRelationInput | AffiliateReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateReferrals.
     */
    cursor?: AffiliateReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateReferrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateReferrals.
     */
    distinct?: AffiliateReferralScalarFieldEnum | AffiliateReferralScalarFieldEnum[]
  }

  /**
   * AffiliateReferral findFirstOrThrow
   */
  export type AffiliateReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateReferral to fetch.
     */
    where?: AffiliateReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateReferrals to fetch.
     */
    orderBy?: AffiliateReferralOrderByWithRelationInput | AffiliateReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateReferrals.
     */
    cursor?: AffiliateReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateReferrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateReferrals.
     */
    distinct?: AffiliateReferralScalarFieldEnum | AffiliateReferralScalarFieldEnum[]
  }

  /**
   * AffiliateReferral findMany
   */
  export type AffiliateReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateReferrals to fetch.
     */
    where?: AffiliateReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateReferrals to fetch.
     */
    orderBy?: AffiliateReferralOrderByWithRelationInput | AffiliateReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateReferrals.
     */
    cursor?: AffiliateReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateReferrals.
     */
    skip?: number
    distinct?: AffiliateReferralScalarFieldEnum | AffiliateReferralScalarFieldEnum[]
  }

  /**
   * AffiliateReferral create
   */
  export type AffiliateReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateReferral.
     */
    data: XOR<AffiliateReferralCreateInput, AffiliateReferralUncheckedCreateInput>
  }

  /**
   * AffiliateReferral createMany
   */
  export type AffiliateReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateReferrals.
     */
    data: AffiliateReferralCreateManyInput | AffiliateReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateReferral createManyAndReturn
   */
  export type AffiliateReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateReferrals.
     */
    data: AffiliateReferralCreateManyInput | AffiliateReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateReferral update
   */
  export type AffiliateReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateReferral.
     */
    data: XOR<AffiliateReferralUpdateInput, AffiliateReferralUncheckedUpdateInput>
    /**
     * Choose, which AffiliateReferral to update.
     */
    where: AffiliateReferralWhereUniqueInput
  }

  /**
   * AffiliateReferral updateMany
   */
  export type AffiliateReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateReferrals.
     */
    data: XOR<AffiliateReferralUpdateManyMutationInput, AffiliateReferralUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateReferrals to update
     */
    where?: AffiliateReferralWhereInput
  }

  /**
   * AffiliateReferral upsert
   */
  export type AffiliateReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateReferral to update in case it exists.
     */
    where: AffiliateReferralWhereUniqueInput
    /**
     * In case the AffiliateReferral found by the `where` argument doesn't exist, create a new AffiliateReferral with this data.
     */
    create: XOR<AffiliateReferralCreateInput, AffiliateReferralUncheckedCreateInput>
    /**
     * In case the AffiliateReferral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateReferralUpdateInput, AffiliateReferralUncheckedUpdateInput>
  }

  /**
   * AffiliateReferral delete
   */
  export type AffiliateReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
    /**
     * Filter which AffiliateReferral to delete.
     */
    where: AffiliateReferralWhereUniqueInput
  }

  /**
   * AffiliateReferral deleteMany
   */
  export type AffiliateReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateReferrals to delete
     */
    where?: AffiliateReferralWhereInput
  }

  /**
   * AffiliateReferral without action
   */
  export type AffiliateReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateReferral
     */
    select?: AffiliateReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateReferralInclude<ExtArgs> | null
  }


  /**
   * Model AffiliatePayout
   */

  export type AggregateAffiliatePayout = {
    _count: AffiliatePayoutCountAggregateOutputType | null
    _avg: AffiliatePayoutAvgAggregateOutputType | null
    _sum: AffiliatePayoutSumAggregateOutputType | null
    _min: AffiliatePayoutMinAggregateOutputType | null
    _max: AffiliatePayoutMaxAggregateOutputType | null
  }

  export type AffiliatePayoutAvgAggregateOutputType = {
    amount: number | null
    feeAmount: number | null
    netAmount: number | null
  }

  export type AffiliatePayoutSumAggregateOutputType = {
    amount: number | null
    feeAmount: number | null
    netAmount: number | null
  }

  export type AffiliatePayoutMinAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    amount: number | null
    feeAmount: number | null
    netAmount: number | null
    status: $Enums.PayoutStatus | null
    method: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliatePayoutMaxAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    amount: number | null
    feeAmount: number | null
    netAmount: number | null
    status: $Enums.PayoutStatus | null
    method: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliatePayoutCountAggregateOutputType = {
    id: number
    affiliateId: number
    amount: number
    feeAmount: number
    netAmount: number
    status: number
    method: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AffiliatePayoutAvgAggregateInputType = {
    amount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type AffiliatePayoutSumAggregateInputType = {
    amount?: true
    feeAmount?: true
    netAmount?: true
  }

  export type AffiliatePayoutMinAggregateInputType = {
    id?: true
    affiliateId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    status?: true
    method?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliatePayoutMaxAggregateInputType = {
    id?: true
    affiliateId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    status?: true
    method?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliatePayoutCountAggregateInputType = {
    id?: true
    affiliateId?: true
    amount?: true
    feeAmount?: true
    netAmount?: true
    status?: true
    method?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AffiliatePayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliatePayout to aggregate.
     */
    where?: AffiliatePayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePayouts to fetch.
     */
    orderBy?: AffiliatePayoutOrderByWithRelationInput | AffiliatePayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliatePayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliatePayouts
    **/
    _count?: true | AffiliatePayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliatePayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliatePayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliatePayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliatePayoutMaxAggregateInputType
  }

  export type GetAffiliatePayoutAggregateType<T extends AffiliatePayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliatePayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliatePayout[P]>
      : GetScalarType<T[P], AggregateAffiliatePayout[P]>
  }




  export type AffiliatePayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliatePayoutWhereInput
    orderBy?: AffiliatePayoutOrderByWithAggregationInput | AffiliatePayoutOrderByWithAggregationInput[]
    by: AffiliatePayoutScalarFieldEnum[] | AffiliatePayoutScalarFieldEnum
    having?: AffiliatePayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliatePayoutCountAggregateInputType | true
    _avg?: AffiliatePayoutAvgAggregateInputType
    _sum?: AffiliatePayoutSumAggregateInputType
    _min?: AffiliatePayoutMinAggregateInputType
    _max?: AffiliatePayoutMaxAggregateInputType
  }

  export type AffiliatePayoutGroupByOutputType = {
    id: string
    affiliateId: string
    amount: number
    feeAmount: number
    netAmount: number
    status: $Enums.PayoutStatus
    method: string
    transactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AffiliatePayoutCountAggregateOutputType | null
    _avg: AffiliatePayoutAvgAggregateOutputType | null
    _sum: AffiliatePayoutSumAggregateOutputType | null
    _min: AffiliatePayoutMinAggregateOutputType | null
    _max: AffiliatePayoutMaxAggregateOutputType | null
  }

  type GetAffiliatePayoutGroupByPayload<T extends AffiliatePayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliatePayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliatePayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliatePayoutGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliatePayoutGroupByOutputType[P]>
        }
      >
    >


  export type AffiliatePayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    status?: boolean
    method?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliatePayout"]>

  export type AffiliatePayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    status?: boolean
    method?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliatePayout"]>

  export type AffiliatePayoutSelectScalar = {
    id?: boolean
    affiliateId?: boolean
    amount?: boolean
    feeAmount?: boolean
    netAmount?: boolean
    status?: boolean
    method?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AffiliatePayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }
  export type AffiliatePayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateDefaultArgs<ExtArgs>
  }

  export type $AffiliatePayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliatePayout"
    objects: {
      affiliate: Prisma.$AffiliatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateId: string
      amount: number
      feeAmount: number
      netAmount: number
      status: $Enums.PayoutStatus
      method: string
      transactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["affiliatePayout"]>
    composites: {}
  }

  type AffiliatePayoutGetPayload<S extends boolean | null | undefined | AffiliatePayoutDefaultArgs> = $Result.GetResult<Prisma.$AffiliatePayoutPayload, S>

  type AffiliatePayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliatePayoutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliatePayoutCountAggregateInputType | true
    }

  export interface AffiliatePayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliatePayout'], meta: { name: 'AffiliatePayout' } }
    /**
     * Find zero or one AffiliatePayout that matches the filter.
     * @param {AffiliatePayoutFindUniqueArgs} args - Arguments to find a AffiliatePayout
     * @example
     * // Get one AffiliatePayout
     * const affiliatePayout = await prisma.affiliatePayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliatePayoutFindUniqueArgs>(args: SelectSubset<T, AffiliatePayoutFindUniqueArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliatePayout that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliatePayoutFindUniqueOrThrowArgs} args - Arguments to find a AffiliatePayout
     * @example
     * // Get one AffiliatePayout
     * const affiliatePayout = await prisma.affiliatePayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliatePayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliatePayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliatePayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatePayoutFindFirstArgs} args - Arguments to find a AffiliatePayout
     * @example
     * // Get one AffiliatePayout
     * const affiliatePayout = await prisma.affiliatePayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliatePayoutFindFirstArgs>(args?: SelectSubset<T, AffiliatePayoutFindFirstArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliatePayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatePayoutFindFirstOrThrowArgs} args - Arguments to find a AffiliatePayout
     * @example
     * // Get one AffiliatePayout
     * const affiliatePayout = await prisma.affiliatePayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliatePayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliatePayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliatePayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatePayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliatePayouts
     * const affiliatePayouts = await prisma.affiliatePayout.findMany()
     * 
     * // Get first 10 AffiliatePayouts
     * const affiliatePayouts = await prisma.affiliatePayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliatePayoutWithIdOnly = await prisma.affiliatePayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliatePayoutFindManyArgs>(args?: SelectSubset<T, AffiliatePayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliatePayout.
     * @param {AffiliatePayoutCreateArgs} args - Arguments to create a AffiliatePayout.
     * @example
     * // Create one AffiliatePayout
     * const AffiliatePayout = await prisma.affiliatePayout.create({
     *   data: {
     *     // ... data to create a AffiliatePayout
     *   }
     * })
     * 
     */
    create<T extends AffiliatePayoutCreateArgs>(args: SelectSubset<T, AffiliatePayoutCreateArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliatePayouts.
     * @param {AffiliatePayoutCreateManyArgs} args - Arguments to create many AffiliatePayouts.
     * @example
     * // Create many AffiliatePayouts
     * const affiliatePayout = await prisma.affiliatePayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliatePayoutCreateManyArgs>(args?: SelectSubset<T, AffiliatePayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliatePayouts and returns the data saved in the database.
     * @param {AffiliatePayoutCreateManyAndReturnArgs} args - Arguments to create many AffiliatePayouts.
     * @example
     * // Create many AffiliatePayouts
     * const affiliatePayout = await prisma.affiliatePayout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliatePayouts and only return the `id`
     * const affiliatePayoutWithIdOnly = await prisma.affiliatePayout.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliatePayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliatePayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliatePayout.
     * @param {AffiliatePayoutDeleteArgs} args - Arguments to delete one AffiliatePayout.
     * @example
     * // Delete one AffiliatePayout
     * const AffiliatePayout = await prisma.affiliatePayout.delete({
     *   where: {
     *     // ... filter to delete one AffiliatePayout
     *   }
     * })
     * 
     */
    delete<T extends AffiliatePayoutDeleteArgs>(args: SelectSubset<T, AffiliatePayoutDeleteArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliatePayout.
     * @param {AffiliatePayoutUpdateArgs} args - Arguments to update one AffiliatePayout.
     * @example
     * // Update one AffiliatePayout
     * const affiliatePayout = await prisma.affiliatePayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliatePayoutUpdateArgs>(args: SelectSubset<T, AffiliatePayoutUpdateArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliatePayouts.
     * @param {AffiliatePayoutDeleteManyArgs} args - Arguments to filter AffiliatePayouts to delete.
     * @example
     * // Delete a few AffiliatePayouts
     * const { count } = await prisma.affiliatePayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliatePayoutDeleteManyArgs>(args?: SelectSubset<T, AffiliatePayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliatePayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatePayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliatePayouts
     * const affiliatePayout = await prisma.affiliatePayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliatePayoutUpdateManyArgs>(args: SelectSubset<T, AffiliatePayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliatePayout.
     * @param {AffiliatePayoutUpsertArgs} args - Arguments to update or create a AffiliatePayout.
     * @example
     * // Update or create a AffiliatePayout
     * const affiliatePayout = await prisma.affiliatePayout.upsert({
     *   create: {
     *     // ... data to create a AffiliatePayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliatePayout we want to update
     *   }
     * })
     */
    upsert<T extends AffiliatePayoutUpsertArgs>(args: SelectSubset<T, AffiliatePayoutUpsertArgs<ExtArgs>>): Prisma__AffiliatePayoutClient<$Result.GetResult<Prisma.$AffiliatePayoutPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliatePayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatePayoutCountArgs} args - Arguments to filter AffiliatePayouts to count.
     * @example
     * // Count the number of AffiliatePayouts
     * const count = await prisma.affiliatePayout.count({
     *   where: {
     *     // ... the filter for the AffiliatePayouts we want to count
     *   }
     * })
    **/
    count<T extends AffiliatePayoutCountArgs>(
      args?: Subset<T, AffiliatePayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliatePayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliatePayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatePayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliatePayoutAggregateArgs>(args: Subset<T, AffiliatePayoutAggregateArgs>): Prisma.PrismaPromise<GetAffiliatePayoutAggregateType<T>>

    /**
     * Group by AffiliatePayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatePayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliatePayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliatePayoutGroupByArgs['orderBy'] }
        : { orderBy?: AffiliatePayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliatePayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliatePayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliatePayout model
   */
  readonly fields: AffiliatePayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliatePayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliatePayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends AffiliateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateDefaultArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliatePayout model
   */ 
  interface AffiliatePayoutFieldRefs {
    readonly id: FieldRef<"AffiliatePayout", 'String'>
    readonly affiliateId: FieldRef<"AffiliatePayout", 'String'>
    readonly amount: FieldRef<"AffiliatePayout", 'Float'>
    readonly feeAmount: FieldRef<"AffiliatePayout", 'Float'>
    readonly netAmount: FieldRef<"AffiliatePayout", 'Float'>
    readonly status: FieldRef<"AffiliatePayout", 'PayoutStatus'>
    readonly method: FieldRef<"AffiliatePayout", 'String'>
    readonly transactionId: FieldRef<"AffiliatePayout", 'String'>
    readonly createdAt: FieldRef<"AffiliatePayout", 'DateTime'>
    readonly updatedAt: FieldRef<"AffiliatePayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliatePayout findUnique
   */
  export type AffiliatePayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePayout to fetch.
     */
    where: AffiliatePayoutWhereUniqueInput
  }

  /**
   * AffiliatePayout findUniqueOrThrow
   */
  export type AffiliatePayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePayout to fetch.
     */
    where: AffiliatePayoutWhereUniqueInput
  }

  /**
   * AffiliatePayout findFirst
   */
  export type AffiliatePayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePayout to fetch.
     */
    where?: AffiliatePayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePayouts to fetch.
     */
    orderBy?: AffiliatePayoutOrderByWithRelationInput | AffiliatePayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliatePayouts.
     */
    cursor?: AffiliatePayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliatePayouts.
     */
    distinct?: AffiliatePayoutScalarFieldEnum | AffiliatePayoutScalarFieldEnum[]
  }

  /**
   * AffiliatePayout findFirstOrThrow
   */
  export type AffiliatePayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePayout to fetch.
     */
    where?: AffiliatePayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePayouts to fetch.
     */
    orderBy?: AffiliatePayoutOrderByWithRelationInput | AffiliatePayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliatePayouts.
     */
    cursor?: AffiliatePayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliatePayouts.
     */
    distinct?: AffiliatePayoutScalarFieldEnum | AffiliatePayoutScalarFieldEnum[]
  }

  /**
   * AffiliatePayout findMany
   */
  export type AffiliatePayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePayouts to fetch.
     */
    where?: AffiliatePayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePayouts to fetch.
     */
    orderBy?: AffiliatePayoutOrderByWithRelationInput | AffiliatePayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliatePayouts.
     */
    cursor?: AffiliatePayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePayouts.
     */
    skip?: number
    distinct?: AffiliatePayoutScalarFieldEnum | AffiliatePayoutScalarFieldEnum[]
  }

  /**
   * AffiliatePayout create
   */
  export type AffiliatePayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliatePayout.
     */
    data: XOR<AffiliatePayoutCreateInput, AffiliatePayoutUncheckedCreateInput>
  }

  /**
   * AffiliatePayout createMany
   */
  export type AffiliatePayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliatePayouts.
     */
    data: AffiliatePayoutCreateManyInput | AffiliatePayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliatePayout createManyAndReturn
   */
  export type AffiliatePayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliatePayouts.
     */
    data: AffiliatePayoutCreateManyInput | AffiliatePayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliatePayout update
   */
  export type AffiliatePayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliatePayout.
     */
    data: XOR<AffiliatePayoutUpdateInput, AffiliatePayoutUncheckedUpdateInput>
    /**
     * Choose, which AffiliatePayout to update.
     */
    where: AffiliatePayoutWhereUniqueInput
  }

  /**
   * AffiliatePayout updateMany
   */
  export type AffiliatePayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliatePayouts.
     */
    data: XOR<AffiliatePayoutUpdateManyMutationInput, AffiliatePayoutUncheckedUpdateManyInput>
    /**
     * Filter which AffiliatePayouts to update
     */
    where?: AffiliatePayoutWhereInput
  }

  /**
   * AffiliatePayout upsert
   */
  export type AffiliatePayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliatePayout to update in case it exists.
     */
    where: AffiliatePayoutWhereUniqueInput
    /**
     * In case the AffiliatePayout found by the `where` argument doesn't exist, create a new AffiliatePayout with this data.
     */
    create: XOR<AffiliatePayoutCreateInput, AffiliatePayoutUncheckedCreateInput>
    /**
     * In case the AffiliatePayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliatePayoutUpdateInput, AffiliatePayoutUncheckedUpdateInput>
  }

  /**
   * AffiliatePayout delete
   */
  export type AffiliatePayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
    /**
     * Filter which AffiliatePayout to delete.
     */
    where: AffiliatePayoutWhereUniqueInput
  }

  /**
   * AffiliatePayout deleteMany
   */
  export type AffiliatePayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliatePayouts to delete
     */
    where?: AffiliatePayoutWhereInput
  }

  /**
   * AffiliatePayout without action
   */
  export type AffiliatePayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePayout
     */
    select?: AffiliatePayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatePayoutInclude<ExtArgs> | null
  }


  /**
   * Model ConversationPackage
   */

  export type AggregateConversationPackage = {
    _count: ConversationPackageCountAggregateOutputType | null
    _avg: ConversationPackageAvgAggregateOutputType | null
    _sum: ConversationPackageSumAggregateOutputType | null
    _min: ConversationPackageMinAggregateOutputType | null
    _max: ConversationPackageMaxAggregateOutputType | null
  }

  export type ConversationPackageAvgAggregateOutputType = {
    price: number | null
    credits: number | null
  }

  export type ConversationPackageSumAggregateOutputType = {
    price: number | null
    credits: number | null
  }

  export type ConversationPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    credits: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    credits: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationPackageCountAggregateOutputType = {
    id: number
    name: number
    price: number
    credits: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationPackageAvgAggregateInputType = {
    price?: true
    credits?: true
  }

  export type ConversationPackageSumAggregateInputType = {
    price?: true
    credits?: true
  }

  export type ConversationPackageMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    credits?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationPackageMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    credits?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationPackageCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    credits?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationPackage to aggregate.
     */
    where?: ConversationPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationPackages to fetch.
     */
    orderBy?: ConversationPackageOrderByWithRelationInput | ConversationPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationPackages
    **/
    _count?: true | ConversationPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationPackageMaxAggregateInputType
  }

  export type GetConversationPackageAggregateType<T extends ConversationPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationPackage[P]>
      : GetScalarType<T[P], AggregateConversationPackage[P]>
  }




  export type ConversationPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationPackageWhereInput
    orderBy?: ConversationPackageOrderByWithAggregationInput | ConversationPackageOrderByWithAggregationInput[]
    by: ConversationPackageScalarFieldEnum[] | ConversationPackageScalarFieldEnum
    having?: ConversationPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationPackageCountAggregateInputType | true
    _avg?: ConversationPackageAvgAggregateInputType
    _sum?: ConversationPackageSumAggregateInputType
    _min?: ConversationPackageMinAggregateInputType
    _max?: ConversationPackageMaxAggregateInputType
  }

  export type ConversationPackageGroupByOutputType = {
    id: string
    name: string
    price: number
    credits: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConversationPackageCountAggregateOutputType | null
    _avg: ConversationPackageAvgAggregateOutputType | null
    _sum: ConversationPackageSumAggregateOutputType | null
    _min: ConversationPackageMinAggregateOutputType | null
    _max: ConversationPackageMaxAggregateOutputType | null
  }

  type GetConversationPackageGroupByPayload<T extends ConversationPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationPackageGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationPackageGroupByOutputType[P]>
        }
      >
    >


  export type ConversationPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    credits?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversationPackage"]>

  export type ConversationPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    credits?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversationPackage"]>

  export type ConversationPackageSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    credits?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ConversationPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationPackage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      credits: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversationPackage"]>
    composites: {}
  }

  type ConversationPackageGetPayload<S extends boolean | null | undefined | ConversationPackageDefaultArgs> = $Result.GetResult<Prisma.$ConversationPackagePayload, S>

  type ConversationPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationPackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationPackageCountAggregateInputType | true
    }

  export interface ConversationPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationPackage'], meta: { name: 'ConversationPackage' } }
    /**
     * Find zero or one ConversationPackage that matches the filter.
     * @param {ConversationPackageFindUniqueArgs} args - Arguments to find a ConversationPackage
     * @example
     * // Get one ConversationPackage
     * const conversationPackage = await prisma.conversationPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationPackageFindUniqueArgs>(args: SelectSubset<T, ConversationPackageFindUniqueArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConversationPackage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationPackageFindUniqueOrThrowArgs} args - Arguments to find a ConversationPackage
     * @example
     * // Get one ConversationPackage
     * const conversationPackage = await prisma.conversationPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConversationPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationPackageFindFirstArgs} args - Arguments to find a ConversationPackage
     * @example
     * // Get one ConversationPackage
     * const conversationPackage = await prisma.conversationPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationPackageFindFirstArgs>(args?: SelectSubset<T, ConversationPackageFindFirstArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConversationPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationPackageFindFirstOrThrowArgs} args - Arguments to find a ConversationPackage
     * @example
     * // Get one ConversationPackage
     * const conversationPackage = await prisma.conversationPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConversationPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationPackages
     * const conversationPackages = await prisma.conversationPackage.findMany()
     * 
     * // Get first 10 ConversationPackages
     * const conversationPackages = await prisma.conversationPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationPackageWithIdOnly = await prisma.conversationPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationPackageFindManyArgs>(args?: SelectSubset<T, ConversationPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConversationPackage.
     * @param {ConversationPackageCreateArgs} args - Arguments to create a ConversationPackage.
     * @example
     * // Create one ConversationPackage
     * const ConversationPackage = await prisma.conversationPackage.create({
     *   data: {
     *     // ... data to create a ConversationPackage
     *   }
     * })
     * 
     */
    create<T extends ConversationPackageCreateArgs>(args: SelectSubset<T, ConversationPackageCreateArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConversationPackages.
     * @param {ConversationPackageCreateManyArgs} args - Arguments to create many ConversationPackages.
     * @example
     * // Create many ConversationPackages
     * const conversationPackage = await prisma.conversationPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationPackageCreateManyArgs>(args?: SelectSubset<T, ConversationPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationPackages and returns the data saved in the database.
     * @param {ConversationPackageCreateManyAndReturnArgs} args - Arguments to create many ConversationPackages.
     * @example
     * // Create many ConversationPackages
     * const conversationPackage = await prisma.conversationPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationPackages and only return the `id`
     * const conversationPackageWithIdOnly = await prisma.conversationPackage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConversationPackage.
     * @param {ConversationPackageDeleteArgs} args - Arguments to delete one ConversationPackage.
     * @example
     * // Delete one ConversationPackage
     * const ConversationPackage = await prisma.conversationPackage.delete({
     *   where: {
     *     // ... filter to delete one ConversationPackage
     *   }
     * })
     * 
     */
    delete<T extends ConversationPackageDeleteArgs>(args: SelectSubset<T, ConversationPackageDeleteArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConversationPackage.
     * @param {ConversationPackageUpdateArgs} args - Arguments to update one ConversationPackage.
     * @example
     * // Update one ConversationPackage
     * const conversationPackage = await prisma.conversationPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationPackageUpdateArgs>(args: SelectSubset<T, ConversationPackageUpdateArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConversationPackages.
     * @param {ConversationPackageDeleteManyArgs} args - Arguments to filter ConversationPackages to delete.
     * @example
     * // Delete a few ConversationPackages
     * const { count } = await prisma.conversationPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationPackageDeleteManyArgs>(args?: SelectSubset<T, ConversationPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationPackages
     * const conversationPackage = await prisma.conversationPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationPackageUpdateManyArgs>(args: SelectSubset<T, ConversationPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationPackage.
     * @param {ConversationPackageUpsertArgs} args - Arguments to update or create a ConversationPackage.
     * @example
     * // Update or create a ConversationPackage
     * const conversationPackage = await prisma.conversationPackage.upsert({
     *   create: {
     *     // ... data to create a ConversationPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationPackage we want to update
     *   }
     * })
     */
    upsert<T extends ConversationPackageUpsertArgs>(args: SelectSubset<T, ConversationPackageUpsertArgs<ExtArgs>>): Prisma__ConversationPackageClient<$Result.GetResult<Prisma.$ConversationPackagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConversationPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationPackageCountArgs} args - Arguments to filter ConversationPackages to count.
     * @example
     * // Count the number of ConversationPackages
     * const count = await prisma.conversationPackage.count({
     *   where: {
     *     // ... the filter for the ConversationPackages we want to count
     *   }
     * })
    **/
    count<T extends ConversationPackageCountArgs>(
      args?: Subset<T, ConversationPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationPackageAggregateArgs>(args: Subset<T, ConversationPackageAggregateArgs>): Prisma.PrismaPromise<GetConversationPackageAggregateType<T>>

    /**
     * Group by ConversationPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationPackageGroupByArgs['orderBy'] }
        : { orderBy?: ConversationPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationPackage model
   */
  readonly fields: ConversationPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationPackage model
   */ 
  interface ConversationPackageFieldRefs {
    readonly id: FieldRef<"ConversationPackage", 'String'>
    readonly name: FieldRef<"ConversationPackage", 'String'>
    readonly price: FieldRef<"ConversationPackage", 'Float'>
    readonly credits: FieldRef<"ConversationPackage", 'Int'>
    readonly active: FieldRef<"ConversationPackage", 'Boolean'>
    readonly createdAt: FieldRef<"ConversationPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"ConversationPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationPackage findUnique
   */
  export type ConversationPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * Filter, which ConversationPackage to fetch.
     */
    where: ConversationPackageWhereUniqueInput
  }

  /**
   * ConversationPackage findUniqueOrThrow
   */
  export type ConversationPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * Filter, which ConversationPackage to fetch.
     */
    where: ConversationPackageWhereUniqueInput
  }

  /**
   * ConversationPackage findFirst
   */
  export type ConversationPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * Filter, which ConversationPackage to fetch.
     */
    where?: ConversationPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationPackages to fetch.
     */
    orderBy?: ConversationPackageOrderByWithRelationInput | ConversationPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationPackages.
     */
    cursor?: ConversationPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationPackages.
     */
    distinct?: ConversationPackageScalarFieldEnum | ConversationPackageScalarFieldEnum[]
  }

  /**
   * ConversationPackage findFirstOrThrow
   */
  export type ConversationPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * Filter, which ConversationPackage to fetch.
     */
    where?: ConversationPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationPackages to fetch.
     */
    orderBy?: ConversationPackageOrderByWithRelationInput | ConversationPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationPackages.
     */
    cursor?: ConversationPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationPackages.
     */
    distinct?: ConversationPackageScalarFieldEnum | ConversationPackageScalarFieldEnum[]
  }

  /**
   * ConversationPackage findMany
   */
  export type ConversationPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * Filter, which ConversationPackages to fetch.
     */
    where?: ConversationPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationPackages to fetch.
     */
    orderBy?: ConversationPackageOrderByWithRelationInput | ConversationPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationPackages.
     */
    cursor?: ConversationPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationPackages.
     */
    skip?: number
    distinct?: ConversationPackageScalarFieldEnum | ConversationPackageScalarFieldEnum[]
  }

  /**
   * ConversationPackage create
   */
  export type ConversationPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * The data needed to create a ConversationPackage.
     */
    data: XOR<ConversationPackageCreateInput, ConversationPackageUncheckedCreateInput>
  }

  /**
   * ConversationPackage createMany
   */
  export type ConversationPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationPackages.
     */
    data: ConversationPackageCreateManyInput | ConversationPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationPackage createManyAndReturn
   */
  export type ConversationPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConversationPackages.
     */
    data: ConversationPackageCreateManyInput | ConversationPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationPackage update
   */
  export type ConversationPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * The data needed to update a ConversationPackage.
     */
    data: XOR<ConversationPackageUpdateInput, ConversationPackageUncheckedUpdateInput>
    /**
     * Choose, which ConversationPackage to update.
     */
    where: ConversationPackageWhereUniqueInput
  }

  /**
   * ConversationPackage updateMany
   */
  export type ConversationPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationPackages.
     */
    data: XOR<ConversationPackageUpdateManyMutationInput, ConversationPackageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationPackages to update
     */
    where?: ConversationPackageWhereInput
  }

  /**
   * ConversationPackage upsert
   */
  export type ConversationPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * The filter to search for the ConversationPackage to update in case it exists.
     */
    where: ConversationPackageWhereUniqueInput
    /**
     * In case the ConversationPackage found by the `where` argument doesn't exist, create a new ConversationPackage with this data.
     */
    create: XOR<ConversationPackageCreateInput, ConversationPackageUncheckedCreateInput>
    /**
     * In case the ConversationPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationPackageUpdateInput, ConversationPackageUncheckedUpdateInput>
  }

  /**
   * ConversationPackage delete
   */
  export type ConversationPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
    /**
     * Filter which ConversationPackage to delete.
     */
    where: ConversationPackageWhereUniqueInput
  }

  /**
   * ConversationPackage deleteMany
   */
  export type ConversationPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationPackages to delete
     */
    where?: ConversationPackageWhereInput
  }

  /**
   * ConversationPackage without action
   */
  export type ConversationPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationPackage
     */
    select?: ConversationPackageSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionTier: 'subscriptionTier',
    subscriptionEnds: 'subscriptionEnds',
    usageLimit: 'usageLimit',
    usageCount: 'usageCount',
    usageResetAt: 'usageResetAt',
    billingEmail: 'billingEmail',
    creditBalance: 'creditBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantTwilioConfigScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    accountSid: 'accountSid',
    authToken: 'authToken',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantTwilioConfigScalarFieldEnum = (typeof TenantTwilioConfigScalarFieldEnum)[keyof typeof TenantTwilioConfigScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    name: 'name',
    username: 'username',
    passwordHash: 'passwordHash',
    isAdmin: 'isAdmin',
    role: 'role',
    isBlocked: 'isBlocked',
    avatar: 'avatar',
    commissionLevel: 'commissionLevel',
    googleId: 'googleId',
    googleEmail: 'googleEmail',
    googleName: 'googleName',
    googleProfilePicture: 'googleProfilePicture',
    googleAuthProvider: 'googleAuthProvider',
    referralCodeUsed: 'referralCodeUsed',
    referralRewardTotal: 'referralRewardTotal',
    isAffiliate: 'isAffiliate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    firstName: 'firstName',
    lastName: 'lastName',
    businessName: 'businessName',
    phone: 'phone',
    address: 'address',
    unit: 'unit',
    city: 'city',
    state: 'state',
    zip: 'zip',
    tinSsn: 'tinSsn',
    taxFormUrl: 'taxFormUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    systemPrompt: 'systemPrompt',
    voiceId: 'voiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    key: 'key',
    name: 'name',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const TranscriptScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    userId: 'userId',
    content: 'content',
    duration: 'duration',
    createdAt: 'createdAt'
  };

  export type TranscriptScalarFieldEnum = (typeof TranscriptScalarFieldEnum)[keyof typeof TranscriptScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    code: 'code',
    status: 'status',
    rewardAmount: 'rewardAmount',
    rewardCurrency: 'rewardCurrency',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const RewardTransactionScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    amount: 'amount',
    status: 'status',
    sourcePaymentId: 'sourcePaymentId',
    holdEndsAt: 'holdEndsAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardTransactionScalarFieldEnum = (typeof RewardTransactionScalarFieldEnum)[keyof typeof RewardTransactionScalarFieldEnum]


  export const ToolExecutionAuditScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    userId: 'userId',
    toolName: 'toolName',
    toolInput: 'toolInput',
    toolOutput: 'toolOutput',
    status: 'status',
    errorMessage: 'errorMessage',
    executionTimeMs: 'executionTimeMs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ToolExecutionAuditScalarFieldEnum = (typeof ToolExecutionAuditScalarFieldEnum)[keyof typeof ToolExecutionAuditScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    agentId: 'agentId',
    name: 'name',
    phone: 'phone',
    email: 'email',
    summary: 'summary',
    isBooked: 'isBooked',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const GoogleAuthConfigScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    redirectUri: 'redirectUri',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoogleAuthConfigScalarFieldEnum = (typeof GoogleAuthConfigScalarFieldEnum)[keyof typeof GoogleAuthConfigScalarFieldEnum]


  export const SystemEmailConfigScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    imapServer: 'imapServer',
    imapPort: 'imapPort',
    imapSecurity: 'imapSecurity',
    smtpServer: 'smtpServer',
    smtpPort: 'smtpPort',
    smtpSecurity: 'smtpSecurity',
    pop3Server: 'pop3Server',
    pop3Port: 'pop3Port',
    pop3Security: 'pop3Security',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemEmailConfigScalarFieldEnum = (typeof SystemEmailConfigScalarFieldEnum)[keyof typeof SystemEmailConfigScalarFieldEnum]


  export const StripeConnectConfigScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    enabled: 'enabled',
    minimumPayout: 'minimumPayout',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StripeConnectConfigScalarFieldEnum = (typeof StripeConnectConfigScalarFieldEnum)[keyof typeof StripeConnectConfigScalarFieldEnum]


  export const TenantGoogleConfigScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    geminiApiKey: 'geminiApiKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantGoogleConfigScalarFieldEnum = (typeof TenantGoogleConfigScalarFieldEnum)[keyof typeof TenantGoogleConfigScalarFieldEnum]


  export const CalendarCredentialsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    calendarEmail: 'calendarEmail',
    scope: 'scope',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarCredentialsScalarFieldEnum = (typeof CalendarCredentialsScalarFieldEnum)[keyof typeof CalendarCredentialsScalarFieldEnum]


  export const GmailCredentialsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    gmailEmail: 'gmailEmail',
    scope: 'scope',
    verified: 'verified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GmailCredentialsScalarFieldEnum = (typeof GmailCredentialsScalarFieldEnum)[keyof typeof GmailCredentialsScalarFieldEnum]


  export const PlatformSettingsScalarFieldEnum: {
    id: 'id',
    lowCommission: 'lowCommission',
    medCommission: 'medCommission',
    highCommission: 'highCommission',
    commissionDurationMonths: 'commissionDurationMonths',
    defaultCommissionLevel: 'defaultCommissionLevel',
    payoutMinimum: 'payoutMinimum',
    refundHoldDays: 'refundHoldDays',
    payoutCycleDelayMonths: 'payoutCycleDelayMonths',
    transactionFeePercent: 'transactionFeePercent',
    starterLimit: 'starterLimit',
    professionalLimit: 'professionalLimit',
    enterpriseLimit: 'enterpriseLimit',
    ltdLimit: 'ltdLimit',
    aiInfraLimit: 'aiInfraLimit',
    updatedAt: 'updatedAt'
  };

  export type PlatformSettingsScalarFieldEnum = (typeof PlatformSettingsScalarFieldEnum)[keyof typeof PlatformSettingsScalarFieldEnum]


  export const AffiliateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    slug: 'slug',
    paymentInfo: 'paymentInfo',
    payoutMethod: 'payoutMethod',
    payoutEmail: 'payoutEmail',
    payoutPhone: 'payoutPhone',
    stripeAccountId: 'stripeAccountId',
    stripeAccountStatus: 'stripeAccountStatus',
    taxFormCompleted: 'taxFormCompleted',
    tax1099Uploaded: 'tax1099Uploaded',
    lastPayoutAt: 'lastPayoutAt',
    lockedCommissionRate: 'lockedCommissionRate',
    customCommissionRate: 'customCommissionRate',
    totalEarnings: 'totalEarnings',
    totalPaid: 'totalPaid',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AffiliateScalarFieldEnum = (typeof AffiliateScalarFieldEnum)[keyof typeof AffiliateScalarFieldEnum]


  export const AffiliateReferralScalarFieldEnum: {
    id: 'id',
    affiliateId: 'affiliateId',
    refereeId: 'refereeId',
    status: 'status',
    commissionAmount: 'commissionAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AffiliateReferralScalarFieldEnum = (typeof AffiliateReferralScalarFieldEnum)[keyof typeof AffiliateReferralScalarFieldEnum]


  export const AffiliatePayoutScalarFieldEnum: {
    id: 'id',
    affiliateId: 'affiliateId',
    amount: 'amount',
    feeAmount: 'feeAmount',
    netAmount: 'netAmount',
    status: 'status',
    method: 'method',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AffiliatePayoutScalarFieldEnum = (typeof AffiliatePayoutScalarFieldEnum)[keyof typeof AffiliatePayoutScalarFieldEnum]


  export const ConversationPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    credits: 'credits',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationPackageScalarFieldEnum = (typeof ConversationPackageScalarFieldEnum)[keyof typeof ConversationPackageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'CommissionLevel'
   */
  export type EnumCommissionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionLevel'>
    


  /**
   * Reference to a field of type 'CommissionLevel[]'
   */
  export type ListEnumCommissionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionLevel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AffiliateStatus'
   */
  export type EnumAffiliateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateStatus'>
    


  /**
   * Reference to a field of type 'AffiliateStatus[]'
   */
  export type ListEnumAffiliateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateStatus[]'>
    


  /**
   * Reference to a field of type 'AffiliateReferralStatus'
   */
  export type EnumAffiliateReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateReferralStatus'>
    


  /**
   * Reference to a field of type 'AffiliateReferralStatus[]'
   */
  export type ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateReferralStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutStatus'
   */
  export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


  /**
   * Reference to a field of type 'PayoutStatus[]'
   */
  export type ListEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    stripeCustomerId?: StringNullableFilter<"Tenant"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Tenant"> | string | null
    subscriptionStatus?: StringNullableFilter<"Tenant"> | string | null
    subscriptionTier?: StringFilter<"Tenant"> | string
    subscriptionEnds?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    usageLimit?: IntFilter<"Tenant"> | number
    usageCount?: IntFilter<"Tenant"> | number
    usageResetAt?: DateTimeFilter<"Tenant"> | Date | string
    billingEmail?: StringNullableFilter<"Tenant"> | string | null
    creditBalance?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    agents?: AgentListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    leads?: LeadListRelationFilter
    googleConfig?: XOR<TenantGoogleConfigNullableRelationFilter, TenantGoogleConfigWhereInput> | null
    twilioConfig?: XOR<TenantTwilioConfigNullableRelationFilter, TenantTwilioConfigWhereInput> | null
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionEnds?: SortOrderInput | SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    usageResetAt?: SortOrder
    billingEmail?: SortOrderInput | SortOrder
    creditBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    googleConfig?: TenantGoogleConfigOrderByWithRelationInput
    twilioConfig?: TenantTwilioConfigOrderByWithRelationInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    subscriptionStatus?: StringNullableFilter<"Tenant"> | string | null
    subscriptionTier?: StringFilter<"Tenant"> | string
    subscriptionEnds?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    usageLimit?: IntFilter<"Tenant"> | number
    usageCount?: IntFilter<"Tenant"> | number
    usageResetAt?: DateTimeFilter<"Tenant"> | Date | string
    billingEmail?: StringNullableFilter<"Tenant"> | string | null
    creditBalance?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    agents?: AgentListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    leads?: LeadListRelationFilter
    googleConfig?: XOR<TenantGoogleConfigNullableRelationFilter, TenantGoogleConfigWhereInput> | null
    twilioConfig?: XOR<TenantTwilioConfigNullableRelationFilter, TenantTwilioConfigWhereInput> | null
  }, "id" | "stripeCustomerId" | "stripeSubscriptionId">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionEnds?: SortOrderInput | SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    usageResetAt?: SortOrder
    billingEmail?: SortOrderInput | SortOrder
    creditBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    subscriptionStatus?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    subscriptionTier?: StringWithAggregatesFilter<"Tenant"> | string
    subscriptionEnds?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    usageLimit?: IntWithAggregatesFilter<"Tenant"> | number
    usageCount?: IntWithAggregatesFilter<"Tenant"> | number
    usageResetAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    billingEmail?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    creditBalance?: IntWithAggregatesFilter<"Tenant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type TenantTwilioConfigWhereInput = {
    AND?: TenantTwilioConfigWhereInput | TenantTwilioConfigWhereInput[]
    OR?: TenantTwilioConfigWhereInput[]
    NOT?: TenantTwilioConfigWhereInput | TenantTwilioConfigWhereInput[]
    id?: StringFilter<"TenantTwilioConfig"> | string
    tenantId?: StringFilter<"TenantTwilioConfig"> | string
    accountSid?: StringFilter<"TenantTwilioConfig"> | string
    authToken?: StringFilter<"TenantTwilioConfig"> | string
    phoneNumber?: StringFilter<"TenantTwilioConfig"> | string
    createdAt?: DateTimeFilter<"TenantTwilioConfig"> | Date | string
    updatedAt?: DateTimeFilter<"TenantTwilioConfig"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type TenantTwilioConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountSid?: SortOrder
    authToken?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantTwilioConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantTwilioConfigWhereInput | TenantTwilioConfigWhereInput[]
    OR?: TenantTwilioConfigWhereInput[]
    NOT?: TenantTwilioConfigWhereInput | TenantTwilioConfigWhereInput[]
    accountSid?: StringFilter<"TenantTwilioConfig"> | string
    authToken?: StringFilter<"TenantTwilioConfig"> | string
    phoneNumber?: StringFilter<"TenantTwilioConfig"> | string
    createdAt?: DateTimeFilter<"TenantTwilioConfig"> | Date | string
    updatedAt?: DateTimeFilter<"TenantTwilioConfig"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantTwilioConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountSid?: SortOrder
    authToken?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantTwilioConfigCountOrderByAggregateInput
    _max?: TenantTwilioConfigMaxOrderByAggregateInput
    _min?: TenantTwilioConfigMinOrderByAggregateInput
  }

  export type TenantTwilioConfigScalarWhereWithAggregatesInput = {
    AND?: TenantTwilioConfigScalarWhereWithAggregatesInput | TenantTwilioConfigScalarWhereWithAggregatesInput[]
    OR?: TenantTwilioConfigScalarWhereWithAggregatesInput[]
    NOT?: TenantTwilioConfigScalarWhereWithAggregatesInput | TenantTwilioConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantTwilioConfig"> | string
    tenantId?: StringWithAggregatesFilter<"TenantTwilioConfig"> | string
    accountSid?: StringWithAggregatesFilter<"TenantTwilioConfig"> | string
    authToken?: StringWithAggregatesFilter<"TenantTwilioConfig"> | string
    phoneNumber?: StringWithAggregatesFilter<"TenantTwilioConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenantTwilioConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantTwilioConfig"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isBlocked?: BoolFilter<"User"> | boolean
    avatar?: StringNullableFilter<"User"> | string | null
    commissionLevel?: EnumCommissionLevelFilter<"User"> | $Enums.CommissionLevel
    googleId?: StringNullableFilter<"User"> | string | null
    googleEmail?: StringNullableFilter<"User"> | string | null
    googleName?: StringNullableFilter<"User"> | string | null
    googleProfilePicture?: StringNullableFilter<"User"> | string | null
    googleAuthProvider?: StringNullableFilter<"User"> | string | null
    referralCodeUsed?: StringNullableFilter<"User"> | string | null
    referralRewardTotal?: FloatFilter<"User"> | number
    isAffiliate?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    businessName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    unit?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    tinSsn?: StringNullableFilter<"User"> | string | null
    taxFormUrl?: StringNullableFilter<"User"> | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    referralsCreated?: ReferralListRelationFilter
    affiliate?: XOR<AffiliateNullableRelationFilter, AffiliateWhereInput> | null
    rewards?: RewardTransactionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    avatar?: SortOrderInput | SortOrder
    commissionLevel?: SortOrder
    googleId?: SortOrderInput | SortOrder
    googleEmail?: SortOrderInput | SortOrder
    googleName?: SortOrderInput | SortOrder
    googleProfilePicture?: SortOrderInput | SortOrder
    googleAuthProvider?: SortOrderInput | SortOrder
    referralCodeUsed?: SortOrderInput | SortOrder
    referralRewardTotal?: SortOrder
    isAffiliate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    tinSsn?: SortOrderInput | SortOrder
    taxFormUrl?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    referralsCreated?: ReferralOrderByRelationAggregateInput
    affiliate?: AffiliateOrderByWithRelationInput
    rewards?: RewardTransactionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    googleId?: string
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isBlocked?: BoolFilter<"User"> | boolean
    avatar?: StringNullableFilter<"User"> | string | null
    commissionLevel?: EnumCommissionLevelFilter<"User"> | $Enums.CommissionLevel
    googleEmail?: StringNullableFilter<"User"> | string | null
    googleName?: StringNullableFilter<"User"> | string | null
    googleProfilePicture?: StringNullableFilter<"User"> | string | null
    googleAuthProvider?: StringNullableFilter<"User"> | string | null
    referralCodeUsed?: StringNullableFilter<"User"> | string | null
    referralRewardTotal?: FloatFilter<"User"> | number
    isAffiliate?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    businessName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    unit?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    tinSsn?: StringNullableFilter<"User"> | string | null
    taxFormUrl?: StringNullableFilter<"User"> | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    referralsCreated?: ReferralListRelationFilter
    affiliate?: XOR<AffiliateNullableRelationFilter, AffiliateWhereInput> | null
    rewards?: RewardTransactionListRelationFilter
  }, "id" | "email" | "username" | "googleId" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    avatar?: SortOrderInput | SortOrder
    commissionLevel?: SortOrder
    googleId?: SortOrderInput | SortOrder
    googleEmail?: SortOrderInput | SortOrder
    googleName?: SortOrderInput | SortOrder
    googleProfilePicture?: SortOrderInput | SortOrder
    googleAuthProvider?: SortOrderInput | SortOrder
    referralCodeUsed?: SortOrderInput | SortOrder
    referralRewardTotal?: SortOrder
    isAffiliate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    tinSsn?: SortOrderInput | SortOrder
    taxFormUrl?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isBlocked?: BoolWithAggregatesFilter<"User"> | boolean
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    commissionLevel?: EnumCommissionLevelWithAggregatesFilter<"User"> | $Enums.CommissionLevel
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleName?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleProfilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleAuthProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    referralCodeUsed?: StringNullableWithAggregatesFilter<"User"> | string | null
    referralRewardTotal?: FloatWithAggregatesFilter<"User"> | number
    isAffiliate?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    businessName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    unit?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    zip?: StringNullableWithAggregatesFilter<"User"> | string | null
    tinSsn?: StringNullableWithAggregatesFilter<"User"> | string | null
    taxFormUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    tenantId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    systemPrompt?: StringFilter<"Agent"> | string
    voiceId?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transcripts?: TranscriptListRelationFilter
    toolAudits?: ToolExecutionAuditListRelationFilter
    leads?: LeadListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    systemPrompt?: SortOrder
    voiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    transcripts?: TranscriptOrderByRelationAggregateInput
    toolAudits?: ToolExecutionAuditOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    tenantId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    systemPrompt?: StringFilter<"Agent"> | string
    voiceId?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transcripts?: TranscriptListRelationFilter
    toolAudits?: ToolExecutionAuditListRelationFilter
    leads?: LeadListRelationFilter
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    systemPrompt?: SortOrder
    voiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    tenantId?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    systemPrompt?: StringWithAggregatesFilter<"Agent"> | string
    voiceId?: StringWithAggregatesFilter<"Agent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    tenantId?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    tenantId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    tenantId?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
  }

  export type TranscriptWhereInput = {
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    id?: StringFilter<"Transcript"> | string
    agentId?: StringFilter<"Transcript"> | string
    userId?: StringNullableFilter<"Transcript"> | string | null
    content?: StringFilter<"Transcript"> | string
    duration?: IntFilter<"Transcript"> | number
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }

  export type TranscriptOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type TranscriptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    agentId?: StringFilter<"Transcript"> | string
    userId?: StringNullableFilter<"Transcript"> | string | null
    content?: StringFilter<"Transcript"> | string
    duration?: IntFilter<"Transcript"> | number
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }, "id">

  export type TranscriptOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    _count?: TranscriptCountOrderByAggregateInput
    _avg?: TranscriptAvgOrderByAggregateInput
    _max?: TranscriptMaxOrderByAggregateInput
    _min?: TranscriptMinOrderByAggregateInput
    _sum?: TranscriptSumOrderByAggregateInput
  }

  export type TranscriptScalarWhereWithAggregatesInput = {
    AND?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    OR?: TranscriptScalarWhereWithAggregatesInput[]
    NOT?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transcript"> | string
    agentId?: StringWithAggregatesFilter<"Transcript"> | string
    userId?: StringNullableWithAggregatesFilter<"Transcript"> | string | null
    content?: StringWithAggregatesFilter<"Transcript"> | string
    duration?: IntWithAggregatesFilter<"Transcript"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transcript"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringNullableFilter<"Referral"> | string | null
    code?: StringFilter<"Referral"> | string
    status?: StringFilter<"Referral"> | string
    rewardAmount?: FloatFilter<"Referral"> | number
    rewardCurrency?: StringFilter<"Referral"> | string
    expiresAt?: DateTimeFilter<"Referral"> | Date | string
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    rewardAmount?: SortOrder
    rewardCurrency?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringNullableFilter<"Referral"> | string | null
    status?: StringFilter<"Referral"> | string
    rewardAmount?: FloatFilter<"Referral"> | number
    rewardCurrency?: StringFilter<"Referral"> | string
    expiresAt?: DateTimeFilter<"Referral"> | Date | string
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    code?: SortOrder
    status?: SortOrder
    rewardAmount?: SortOrder
    rewardCurrency?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    refereeId?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    code?: StringWithAggregatesFilter<"Referral"> | string
    status?: StringWithAggregatesFilter<"Referral"> | string
    rewardAmount?: FloatWithAggregatesFilter<"Referral"> | number
    rewardCurrency?: StringWithAggregatesFilter<"Referral"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type RewardTransactionWhereInput = {
    AND?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    OR?: RewardTransactionWhereInput[]
    NOT?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    id?: StringFilter<"RewardTransaction"> | string
    referrerId?: StringFilter<"RewardTransaction"> | string
    refereeId?: StringNullableFilter<"RewardTransaction"> | string | null
    amount?: FloatFilter<"RewardTransaction"> | number
    status?: StringFilter<"RewardTransaction"> | string
    sourcePaymentId?: StringNullableFilter<"RewardTransaction"> | string | null
    holdEndsAt?: DateTimeNullableFilter<"RewardTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"RewardTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"RewardTransaction"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RewardTransactionOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    sourcePaymentId?: SortOrderInput | SortOrder
    holdEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
  }

  export type RewardTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    OR?: RewardTransactionWhereInput[]
    NOT?: RewardTransactionWhereInput | RewardTransactionWhereInput[]
    referrerId?: StringFilter<"RewardTransaction"> | string
    refereeId?: StringNullableFilter<"RewardTransaction"> | string | null
    amount?: FloatFilter<"RewardTransaction"> | number
    status?: StringFilter<"RewardTransaction"> | string
    sourcePaymentId?: StringNullableFilter<"RewardTransaction"> | string | null
    holdEndsAt?: DateTimeNullableFilter<"RewardTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"RewardTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"RewardTransaction"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RewardTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    sourcePaymentId?: SortOrderInput | SortOrder
    holdEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardTransactionCountOrderByAggregateInput
    _avg?: RewardTransactionAvgOrderByAggregateInput
    _max?: RewardTransactionMaxOrderByAggregateInput
    _min?: RewardTransactionMinOrderByAggregateInput
    _sum?: RewardTransactionSumOrderByAggregateInput
  }

  export type RewardTransactionScalarWhereWithAggregatesInput = {
    AND?: RewardTransactionScalarWhereWithAggregatesInput | RewardTransactionScalarWhereWithAggregatesInput[]
    OR?: RewardTransactionScalarWhereWithAggregatesInput[]
    NOT?: RewardTransactionScalarWhereWithAggregatesInput | RewardTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RewardTransaction"> | string
    referrerId?: StringWithAggregatesFilter<"RewardTransaction"> | string
    refereeId?: StringNullableWithAggregatesFilter<"RewardTransaction"> | string | null
    amount?: FloatWithAggregatesFilter<"RewardTransaction"> | number
    status?: StringWithAggregatesFilter<"RewardTransaction"> | string
    sourcePaymentId?: StringNullableWithAggregatesFilter<"RewardTransaction"> | string | null
    holdEndsAt?: DateTimeNullableWithAggregatesFilter<"RewardTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RewardTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RewardTransaction"> | Date | string
  }

  export type ToolExecutionAuditWhereInput = {
    AND?: ToolExecutionAuditWhereInput | ToolExecutionAuditWhereInput[]
    OR?: ToolExecutionAuditWhereInput[]
    NOT?: ToolExecutionAuditWhereInput | ToolExecutionAuditWhereInput[]
    id?: StringFilter<"ToolExecutionAudit"> | string
    agentId?: StringFilter<"ToolExecutionAudit"> | string
    userId?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    toolName?: StringFilter<"ToolExecutionAudit"> | string
    toolInput?: StringFilter<"ToolExecutionAudit"> | string
    toolOutput?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    status?: StringFilter<"ToolExecutionAudit"> | string
    errorMessage?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    executionTimeMs?: IntFilter<"ToolExecutionAudit"> | number
    createdAt?: DateTimeFilter<"ToolExecutionAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ToolExecutionAudit"> | Date | string
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }

  export type ToolExecutionAuditOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    toolName?: SortOrder
    toolInput?: SortOrder
    toolOutput?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type ToolExecutionAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ToolExecutionAuditWhereInput | ToolExecutionAuditWhereInput[]
    OR?: ToolExecutionAuditWhereInput[]
    NOT?: ToolExecutionAuditWhereInput | ToolExecutionAuditWhereInput[]
    agentId?: StringFilter<"ToolExecutionAudit"> | string
    userId?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    toolName?: StringFilter<"ToolExecutionAudit"> | string
    toolInput?: StringFilter<"ToolExecutionAudit"> | string
    toolOutput?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    status?: StringFilter<"ToolExecutionAudit"> | string
    errorMessage?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    executionTimeMs?: IntFilter<"ToolExecutionAudit"> | number
    createdAt?: DateTimeFilter<"ToolExecutionAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ToolExecutionAudit"> | Date | string
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }, "id">

  export type ToolExecutionAuditOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    toolName?: SortOrder
    toolInput?: SortOrder
    toolOutput?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ToolExecutionAuditCountOrderByAggregateInput
    _avg?: ToolExecutionAuditAvgOrderByAggregateInput
    _max?: ToolExecutionAuditMaxOrderByAggregateInput
    _min?: ToolExecutionAuditMinOrderByAggregateInput
    _sum?: ToolExecutionAuditSumOrderByAggregateInput
  }

  export type ToolExecutionAuditScalarWhereWithAggregatesInput = {
    AND?: ToolExecutionAuditScalarWhereWithAggregatesInput | ToolExecutionAuditScalarWhereWithAggregatesInput[]
    OR?: ToolExecutionAuditScalarWhereWithAggregatesInput[]
    NOT?: ToolExecutionAuditScalarWhereWithAggregatesInput | ToolExecutionAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ToolExecutionAudit"> | string
    agentId?: StringWithAggregatesFilter<"ToolExecutionAudit"> | string
    userId?: StringNullableWithAggregatesFilter<"ToolExecutionAudit"> | string | null
    toolName?: StringWithAggregatesFilter<"ToolExecutionAudit"> | string
    toolInput?: StringWithAggregatesFilter<"ToolExecutionAudit"> | string
    toolOutput?: StringNullableWithAggregatesFilter<"ToolExecutionAudit"> | string | null
    status?: StringWithAggregatesFilter<"ToolExecutionAudit"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ToolExecutionAudit"> | string | null
    executionTimeMs?: IntWithAggregatesFilter<"ToolExecutionAudit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ToolExecutionAudit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ToolExecutionAudit"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    agentId?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    summary?: StringNullableFilter<"Lead"> | string | null
    isBooked?: BoolFilter<"Lead"> | boolean
    metadata?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    isBooked?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    tenantId?: StringFilter<"Lead"> | string
    agentId?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    summary?: StringNullableFilter<"Lead"> | string | null
    isBooked?: BoolFilter<"Lead"> | boolean
    metadata?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    isBooked?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    tenantId?: StringWithAggregatesFilter<"Lead"> | string
    agentId?: StringWithAggregatesFilter<"Lead"> | string
    name?: StringWithAggregatesFilter<"Lead"> | string
    phone?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    isBooked?: BoolWithAggregatesFilter<"Lead"> | boolean
    metadata?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type GoogleAuthConfigWhereInput = {
    AND?: GoogleAuthConfigWhereInput | GoogleAuthConfigWhereInput[]
    OR?: GoogleAuthConfigWhereInput[]
    NOT?: GoogleAuthConfigWhereInput | GoogleAuthConfigWhereInput[]
    id?: StringFilter<"GoogleAuthConfig"> | string
    clientId?: StringNullableFilter<"GoogleAuthConfig"> | string | null
    clientSecret?: StringNullableFilter<"GoogleAuthConfig"> | string | null
    redirectUri?: StringNullableFilter<"GoogleAuthConfig"> | string | null
    enabled?: BoolFilter<"GoogleAuthConfig"> | boolean
    createdAt?: DateTimeFilter<"GoogleAuthConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAuthConfig"> | Date | string
  }

  export type GoogleAuthConfigOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientSecret?: SortOrderInput | SortOrder
    redirectUri?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleAuthConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoogleAuthConfigWhereInput | GoogleAuthConfigWhereInput[]
    OR?: GoogleAuthConfigWhereInput[]
    NOT?: GoogleAuthConfigWhereInput | GoogleAuthConfigWhereInput[]
    clientId?: StringNullableFilter<"GoogleAuthConfig"> | string | null
    clientSecret?: StringNullableFilter<"GoogleAuthConfig"> | string | null
    redirectUri?: StringNullableFilter<"GoogleAuthConfig"> | string | null
    enabled?: BoolFilter<"GoogleAuthConfig"> | boolean
    createdAt?: DateTimeFilter<"GoogleAuthConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAuthConfig"> | Date | string
  }, "id">

  export type GoogleAuthConfigOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientSecret?: SortOrderInput | SortOrder
    redirectUri?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoogleAuthConfigCountOrderByAggregateInput
    _max?: GoogleAuthConfigMaxOrderByAggregateInput
    _min?: GoogleAuthConfigMinOrderByAggregateInput
  }

  export type GoogleAuthConfigScalarWhereWithAggregatesInput = {
    AND?: GoogleAuthConfigScalarWhereWithAggregatesInput | GoogleAuthConfigScalarWhereWithAggregatesInput[]
    OR?: GoogleAuthConfigScalarWhereWithAggregatesInput[]
    NOT?: GoogleAuthConfigScalarWhereWithAggregatesInput | GoogleAuthConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoogleAuthConfig"> | string
    clientId?: StringNullableWithAggregatesFilter<"GoogleAuthConfig"> | string | null
    clientSecret?: StringNullableWithAggregatesFilter<"GoogleAuthConfig"> | string | null
    redirectUri?: StringNullableWithAggregatesFilter<"GoogleAuthConfig"> | string | null
    enabled?: BoolWithAggregatesFilter<"GoogleAuthConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GoogleAuthConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoogleAuthConfig"> | Date | string
  }

  export type SystemEmailConfigWhereInput = {
    AND?: SystemEmailConfigWhereInput | SystemEmailConfigWhereInput[]
    OR?: SystemEmailConfigWhereInput[]
    NOT?: SystemEmailConfigWhereInput | SystemEmailConfigWhereInput[]
    id?: StringFilter<"SystemEmailConfig"> | string
    username?: StringNullableFilter<"SystemEmailConfig"> | string | null
    password?: StringNullableFilter<"SystemEmailConfig"> | string | null
    imapServer?: StringNullableFilter<"SystemEmailConfig"> | string | null
    imapPort?: StringNullableFilter<"SystemEmailConfig"> | string | null
    imapSecurity?: StringNullableFilter<"SystemEmailConfig"> | string | null
    smtpServer?: StringNullableFilter<"SystemEmailConfig"> | string | null
    smtpPort?: StringNullableFilter<"SystemEmailConfig"> | string | null
    smtpSecurity?: StringNullableFilter<"SystemEmailConfig"> | string | null
    pop3Server?: StringNullableFilter<"SystemEmailConfig"> | string | null
    pop3Port?: StringNullableFilter<"SystemEmailConfig"> | string | null
    pop3Security?: StringNullableFilter<"SystemEmailConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemEmailConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemEmailConfig"> | Date | string
  }

  export type SystemEmailConfigOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    imapServer?: SortOrderInput | SortOrder
    imapPort?: SortOrderInput | SortOrder
    imapSecurity?: SortOrderInput | SortOrder
    smtpServer?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpSecurity?: SortOrderInput | SortOrder
    pop3Server?: SortOrderInput | SortOrder
    pop3Port?: SortOrderInput | SortOrder
    pop3Security?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemEmailConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemEmailConfigWhereInput | SystemEmailConfigWhereInput[]
    OR?: SystemEmailConfigWhereInput[]
    NOT?: SystemEmailConfigWhereInput | SystemEmailConfigWhereInput[]
    username?: StringNullableFilter<"SystemEmailConfig"> | string | null
    password?: StringNullableFilter<"SystemEmailConfig"> | string | null
    imapServer?: StringNullableFilter<"SystemEmailConfig"> | string | null
    imapPort?: StringNullableFilter<"SystemEmailConfig"> | string | null
    imapSecurity?: StringNullableFilter<"SystemEmailConfig"> | string | null
    smtpServer?: StringNullableFilter<"SystemEmailConfig"> | string | null
    smtpPort?: StringNullableFilter<"SystemEmailConfig"> | string | null
    smtpSecurity?: StringNullableFilter<"SystemEmailConfig"> | string | null
    pop3Server?: StringNullableFilter<"SystemEmailConfig"> | string | null
    pop3Port?: StringNullableFilter<"SystemEmailConfig"> | string | null
    pop3Security?: StringNullableFilter<"SystemEmailConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemEmailConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemEmailConfig"> | Date | string
  }, "id">

  export type SystemEmailConfigOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    imapServer?: SortOrderInput | SortOrder
    imapPort?: SortOrderInput | SortOrder
    imapSecurity?: SortOrderInput | SortOrder
    smtpServer?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpSecurity?: SortOrderInput | SortOrder
    pop3Server?: SortOrderInput | SortOrder
    pop3Port?: SortOrderInput | SortOrder
    pop3Security?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemEmailConfigCountOrderByAggregateInput
    _max?: SystemEmailConfigMaxOrderByAggregateInput
    _min?: SystemEmailConfigMinOrderByAggregateInput
  }

  export type SystemEmailConfigScalarWhereWithAggregatesInput = {
    AND?: SystemEmailConfigScalarWhereWithAggregatesInput | SystemEmailConfigScalarWhereWithAggregatesInput[]
    OR?: SystemEmailConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemEmailConfigScalarWhereWithAggregatesInput | SystemEmailConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemEmailConfig"> | string
    username?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    password?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    imapServer?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    imapPort?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    imapSecurity?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    smtpServer?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    smtpPort?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    smtpSecurity?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    pop3Server?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    pop3Port?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    pop3Security?: StringNullableWithAggregatesFilter<"SystemEmailConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemEmailConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemEmailConfig"> | Date | string
  }

  export type StripeConnectConfigWhereInput = {
    AND?: StripeConnectConfigWhereInput | StripeConnectConfigWhereInput[]
    OR?: StripeConnectConfigWhereInput[]
    NOT?: StripeConnectConfigWhereInput | StripeConnectConfigWhereInput[]
    id?: StringFilter<"StripeConnectConfig"> | string
    clientId?: StringNullableFilter<"StripeConnectConfig"> | string | null
    enabled?: BoolFilter<"StripeConnectConfig"> | boolean
    minimumPayout?: FloatFilter<"StripeConnectConfig"> | number
    createdAt?: DateTimeFilter<"StripeConnectConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StripeConnectConfig"> | Date | string
  }

  export type StripeConnectConfigOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    enabled?: SortOrder
    minimumPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConnectConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StripeConnectConfigWhereInput | StripeConnectConfigWhereInput[]
    OR?: StripeConnectConfigWhereInput[]
    NOT?: StripeConnectConfigWhereInput | StripeConnectConfigWhereInput[]
    clientId?: StringNullableFilter<"StripeConnectConfig"> | string | null
    enabled?: BoolFilter<"StripeConnectConfig"> | boolean
    minimumPayout?: FloatFilter<"StripeConnectConfig"> | number
    createdAt?: DateTimeFilter<"StripeConnectConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StripeConnectConfig"> | Date | string
  }, "id">

  export type StripeConnectConfigOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    enabled?: SortOrder
    minimumPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StripeConnectConfigCountOrderByAggregateInput
    _avg?: StripeConnectConfigAvgOrderByAggregateInput
    _max?: StripeConnectConfigMaxOrderByAggregateInput
    _min?: StripeConnectConfigMinOrderByAggregateInput
    _sum?: StripeConnectConfigSumOrderByAggregateInput
  }

  export type StripeConnectConfigScalarWhereWithAggregatesInput = {
    AND?: StripeConnectConfigScalarWhereWithAggregatesInput | StripeConnectConfigScalarWhereWithAggregatesInput[]
    OR?: StripeConnectConfigScalarWhereWithAggregatesInput[]
    NOT?: StripeConnectConfigScalarWhereWithAggregatesInput | StripeConnectConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeConnectConfig"> | string
    clientId?: StringNullableWithAggregatesFilter<"StripeConnectConfig"> | string | null
    enabled?: BoolWithAggregatesFilter<"StripeConnectConfig"> | boolean
    minimumPayout?: FloatWithAggregatesFilter<"StripeConnectConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StripeConnectConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StripeConnectConfig"> | Date | string
  }

  export type TenantGoogleConfigWhereInput = {
    AND?: TenantGoogleConfigWhereInput | TenantGoogleConfigWhereInput[]
    OR?: TenantGoogleConfigWhereInput[]
    NOT?: TenantGoogleConfigWhereInput | TenantGoogleConfigWhereInput[]
    id?: StringFilter<"TenantGoogleConfig"> | string
    tenantId?: StringFilter<"TenantGoogleConfig"> | string
    clientId?: StringFilter<"TenantGoogleConfig"> | string
    clientSecret?: StringFilter<"TenantGoogleConfig"> | string
    geminiApiKey?: StringNullableFilter<"TenantGoogleConfig"> | string | null
    createdAt?: DateTimeFilter<"TenantGoogleConfig"> | Date | string
    updatedAt?: DateTimeFilter<"TenantGoogleConfig"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type TenantGoogleConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    geminiApiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantGoogleConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantGoogleConfigWhereInput | TenantGoogleConfigWhereInput[]
    OR?: TenantGoogleConfigWhereInput[]
    NOT?: TenantGoogleConfigWhereInput | TenantGoogleConfigWhereInput[]
    clientId?: StringFilter<"TenantGoogleConfig"> | string
    clientSecret?: StringFilter<"TenantGoogleConfig"> | string
    geminiApiKey?: StringNullableFilter<"TenantGoogleConfig"> | string | null
    createdAt?: DateTimeFilter<"TenantGoogleConfig"> | Date | string
    updatedAt?: DateTimeFilter<"TenantGoogleConfig"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantGoogleConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    geminiApiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantGoogleConfigCountOrderByAggregateInput
    _max?: TenantGoogleConfigMaxOrderByAggregateInput
    _min?: TenantGoogleConfigMinOrderByAggregateInput
  }

  export type TenantGoogleConfigScalarWhereWithAggregatesInput = {
    AND?: TenantGoogleConfigScalarWhereWithAggregatesInput | TenantGoogleConfigScalarWhereWithAggregatesInput[]
    OR?: TenantGoogleConfigScalarWhereWithAggregatesInput[]
    NOT?: TenantGoogleConfigScalarWhereWithAggregatesInput | TenantGoogleConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantGoogleConfig"> | string
    tenantId?: StringWithAggregatesFilter<"TenantGoogleConfig"> | string
    clientId?: StringWithAggregatesFilter<"TenantGoogleConfig"> | string
    clientSecret?: StringWithAggregatesFilter<"TenantGoogleConfig"> | string
    geminiApiKey?: StringNullableWithAggregatesFilter<"TenantGoogleConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantGoogleConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantGoogleConfig"> | Date | string
  }

  export type CalendarCredentialsWhereInput = {
    AND?: CalendarCredentialsWhereInput | CalendarCredentialsWhereInput[]
    OR?: CalendarCredentialsWhereInput[]
    NOT?: CalendarCredentialsWhereInput | CalendarCredentialsWhereInput[]
    id?: StringFilter<"CalendarCredentials"> | string
    userId?: StringFilter<"CalendarCredentials"> | string
    tenantId?: StringFilter<"CalendarCredentials"> | string
    accessToken?: StringFilter<"CalendarCredentials"> | string
    refreshToken?: StringNullableFilter<"CalendarCredentials"> | string | null
    expiresAt?: DateTimeNullableFilter<"CalendarCredentials"> | Date | string | null
    calendarEmail?: StringNullableFilter<"CalendarCredentials"> | string | null
    scope?: StringNullableFilter<"CalendarCredentials"> | string | null
    createdAt?: DateTimeFilter<"CalendarCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarCredentials"> | Date | string
  }

  export type CalendarCredentialsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    calendarEmail?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarCredentialsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tenantId?: CalendarCredentialsUserIdTenantIdCompoundUniqueInput
    AND?: CalendarCredentialsWhereInput | CalendarCredentialsWhereInput[]
    OR?: CalendarCredentialsWhereInput[]
    NOT?: CalendarCredentialsWhereInput | CalendarCredentialsWhereInput[]
    userId?: StringFilter<"CalendarCredentials"> | string
    tenantId?: StringFilter<"CalendarCredentials"> | string
    accessToken?: StringFilter<"CalendarCredentials"> | string
    refreshToken?: StringNullableFilter<"CalendarCredentials"> | string | null
    expiresAt?: DateTimeNullableFilter<"CalendarCredentials"> | Date | string | null
    calendarEmail?: StringNullableFilter<"CalendarCredentials"> | string | null
    scope?: StringNullableFilter<"CalendarCredentials"> | string | null
    createdAt?: DateTimeFilter<"CalendarCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarCredentials"> | Date | string
  }, "id" | "userId_tenantId">

  export type CalendarCredentialsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    calendarEmail?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarCredentialsCountOrderByAggregateInput
    _max?: CalendarCredentialsMaxOrderByAggregateInput
    _min?: CalendarCredentialsMinOrderByAggregateInput
  }

  export type CalendarCredentialsScalarWhereWithAggregatesInput = {
    AND?: CalendarCredentialsScalarWhereWithAggregatesInput | CalendarCredentialsScalarWhereWithAggregatesInput[]
    OR?: CalendarCredentialsScalarWhereWithAggregatesInput[]
    NOT?: CalendarCredentialsScalarWhereWithAggregatesInput | CalendarCredentialsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarCredentials"> | string
    userId?: StringWithAggregatesFilter<"CalendarCredentials"> | string
    tenantId?: StringWithAggregatesFilter<"CalendarCredentials"> | string
    accessToken?: StringWithAggregatesFilter<"CalendarCredentials"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"CalendarCredentials"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CalendarCredentials"> | Date | string | null
    calendarEmail?: StringNullableWithAggregatesFilter<"CalendarCredentials"> | string | null
    scope?: StringNullableWithAggregatesFilter<"CalendarCredentials"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CalendarCredentials"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarCredentials"> | Date | string
  }

  export type GmailCredentialsWhereInput = {
    AND?: GmailCredentialsWhereInput | GmailCredentialsWhereInput[]
    OR?: GmailCredentialsWhereInput[]
    NOT?: GmailCredentialsWhereInput | GmailCredentialsWhereInput[]
    id?: StringFilter<"GmailCredentials"> | string
    userId?: StringFilter<"GmailCredentials"> | string
    tenantId?: StringFilter<"GmailCredentials"> | string
    accessToken?: StringFilter<"GmailCredentials"> | string
    refreshToken?: StringNullableFilter<"GmailCredentials"> | string | null
    expiresAt?: DateTimeNullableFilter<"GmailCredentials"> | Date | string | null
    gmailEmail?: StringNullableFilter<"GmailCredentials"> | string | null
    scope?: StringNullableFilter<"GmailCredentials"> | string | null
    verified?: BoolFilter<"GmailCredentials"> | boolean
    createdAt?: DateTimeFilter<"GmailCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"GmailCredentials"> | Date | string
  }

  export type GmailCredentialsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    gmailEmail?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailCredentialsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tenantId?: GmailCredentialsUserIdTenantIdCompoundUniqueInput
    AND?: GmailCredentialsWhereInput | GmailCredentialsWhereInput[]
    OR?: GmailCredentialsWhereInput[]
    NOT?: GmailCredentialsWhereInput | GmailCredentialsWhereInput[]
    userId?: StringFilter<"GmailCredentials"> | string
    tenantId?: StringFilter<"GmailCredentials"> | string
    accessToken?: StringFilter<"GmailCredentials"> | string
    refreshToken?: StringNullableFilter<"GmailCredentials"> | string | null
    expiresAt?: DateTimeNullableFilter<"GmailCredentials"> | Date | string | null
    gmailEmail?: StringNullableFilter<"GmailCredentials"> | string | null
    scope?: StringNullableFilter<"GmailCredentials"> | string | null
    verified?: BoolFilter<"GmailCredentials"> | boolean
    createdAt?: DateTimeFilter<"GmailCredentials"> | Date | string
    updatedAt?: DateTimeFilter<"GmailCredentials"> | Date | string
  }, "id" | "userId_tenantId">

  export type GmailCredentialsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    gmailEmail?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GmailCredentialsCountOrderByAggregateInput
    _max?: GmailCredentialsMaxOrderByAggregateInput
    _min?: GmailCredentialsMinOrderByAggregateInput
  }

  export type GmailCredentialsScalarWhereWithAggregatesInput = {
    AND?: GmailCredentialsScalarWhereWithAggregatesInput | GmailCredentialsScalarWhereWithAggregatesInput[]
    OR?: GmailCredentialsScalarWhereWithAggregatesInput[]
    NOT?: GmailCredentialsScalarWhereWithAggregatesInput | GmailCredentialsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GmailCredentials"> | string
    userId?: StringWithAggregatesFilter<"GmailCredentials"> | string
    tenantId?: StringWithAggregatesFilter<"GmailCredentials"> | string
    accessToken?: StringWithAggregatesFilter<"GmailCredentials"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"GmailCredentials"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"GmailCredentials"> | Date | string | null
    gmailEmail?: StringNullableWithAggregatesFilter<"GmailCredentials"> | string | null
    scope?: StringNullableWithAggregatesFilter<"GmailCredentials"> | string | null
    verified?: BoolWithAggregatesFilter<"GmailCredentials"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GmailCredentials"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GmailCredentials"> | Date | string
  }

  export type PlatformSettingsWhereInput = {
    AND?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    OR?: PlatformSettingsWhereInput[]
    NOT?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    id?: StringFilter<"PlatformSettings"> | string
    lowCommission?: FloatFilter<"PlatformSettings"> | number
    medCommission?: FloatFilter<"PlatformSettings"> | number
    highCommission?: FloatFilter<"PlatformSettings"> | number
    commissionDurationMonths?: IntFilter<"PlatformSettings"> | number
    defaultCommissionLevel?: EnumCommissionLevelFilter<"PlatformSettings"> | $Enums.CommissionLevel
    payoutMinimum?: FloatFilter<"PlatformSettings"> | number
    refundHoldDays?: IntFilter<"PlatformSettings"> | number
    payoutCycleDelayMonths?: IntFilter<"PlatformSettings"> | number
    transactionFeePercent?: FloatFilter<"PlatformSettings"> | number
    starterLimit?: IntFilter<"PlatformSettings"> | number
    professionalLimit?: IntFilter<"PlatformSettings"> | number
    enterpriseLimit?: IntFilter<"PlatformSettings"> | number
    ltdLimit?: IntFilter<"PlatformSettings"> | number
    aiInfraLimit?: IntFilter<"PlatformSettings"> | number
    updatedAt?: DateTimeFilter<"PlatformSettings"> | Date | string
  }

  export type PlatformSettingsOrderByWithRelationInput = {
    id?: SortOrder
    lowCommission?: SortOrder
    medCommission?: SortOrder
    highCommission?: SortOrder
    commissionDurationMonths?: SortOrder
    defaultCommissionLevel?: SortOrder
    payoutMinimum?: SortOrder
    refundHoldDays?: SortOrder
    payoutCycleDelayMonths?: SortOrder
    transactionFeePercent?: SortOrder
    starterLimit?: SortOrder
    professionalLimit?: SortOrder
    enterpriseLimit?: SortOrder
    ltdLimit?: SortOrder
    aiInfraLimit?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    OR?: PlatformSettingsWhereInput[]
    NOT?: PlatformSettingsWhereInput | PlatformSettingsWhereInput[]
    lowCommission?: FloatFilter<"PlatformSettings"> | number
    medCommission?: FloatFilter<"PlatformSettings"> | number
    highCommission?: FloatFilter<"PlatformSettings"> | number
    commissionDurationMonths?: IntFilter<"PlatformSettings"> | number
    defaultCommissionLevel?: EnumCommissionLevelFilter<"PlatformSettings"> | $Enums.CommissionLevel
    payoutMinimum?: FloatFilter<"PlatformSettings"> | number
    refundHoldDays?: IntFilter<"PlatformSettings"> | number
    payoutCycleDelayMonths?: IntFilter<"PlatformSettings"> | number
    transactionFeePercent?: FloatFilter<"PlatformSettings"> | number
    starterLimit?: IntFilter<"PlatformSettings"> | number
    professionalLimit?: IntFilter<"PlatformSettings"> | number
    enterpriseLimit?: IntFilter<"PlatformSettings"> | number
    ltdLimit?: IntFilter<"PlatformSettings"> | number
    aiInfraLimit?: IntFilter<"PlatformSettings"> | number
    updatedAt?: DateTimeFilter<"PlatformSettings"> | Date | string
  }, "id">

  export type PlatformSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    lowCommission?: SortOrder
    medCommission?: SortOrder
    highCommission?: SortOrder
    commissionDurationMonths?: SortOrder
    defaultCommissionLevel?: SortOrder
    payoutMinimum?: SortOrder
    refundHoldDays?: SortOrder
    payoutCycleDelayMonths?: SortOrder
    transactionFeePercent?: SortOrder
    starterLimit?: SortOrder
    professionalLimit?: SortOrder
    enterpriseLimit?: SortOrder
    ltdLimit?: SortOrder
    aiInfraLimit?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformSettingsCountOrderByAggregateInput
    _avg?: PlatformSettingsAvgOrderByAggregateInput
    _max?: PlatformSettingsMaxOrderByAggregateInput
    _min?: PlatformSettingsMinOrderByAggregateInput
    _sum?: PlatformSettingsSumOrderByAggregateInput
  }

  export type PlatformSettingsScalarWhereWithAggregatesInput = {
    AND?: PlatformSettingsScalarWhereWithAggregatesInput | PlatformSettingsScalarWhereWithAggregatesInput[]
    OR?: PlatformSettingsScalarWhereWithAggregatesInput[]
    NOT?: PlatformSettingsScalarWhereWithAggregatesInput | PlatformSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformSettings"> | string
    lowCommission?: FloatWithAggregatesFilter<"PlatformSettings"> | number
    medCommission?: FloatWithAggregatesFilter<"PlatformSettings"> | number
    highCommission?: FloatWithAggregatesFilter<"PlatformSettings"> | number
    commissionDurationMonths?: IntWithAggregatesFilter<"PlatformSettings"> | number
    defaultCommissionLevel?: EnumCommissionLevelWithAggregatesFilter<"PlatformSettings"> | $Enums.CommissionLevel
    payoutMinimum?: FloatWithAggregatesFilter<"PlatformSettings"> | number
    refundHoldDays?: IntWithAggregatesFilter<"PlatformSettings"> | number
    payoutCycleDelayMonths?: IntWithAggregatesFilter<"PlatformSettings"> | number
    transactionFeePercent?: FloatWithAggregatesFilter<"PlatformSettings"> | number
    starterLimit?: IntWithAggregatesFilter<"PlatformSettings"> | number
    professionalLimit?: IntWithAggregatesFilter<"PlatformSettings"> | number
    enterpriseLimit?: IntWithAggregatesFilter<"PlatformSettings"> | number
    ltdLimit?: IntWithAggregatesFilter<"PlatformSettings"> | number
    aiInfraLimit?: IntWithAggregatesFilter<"PlatformSettings"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformSettings"> | Date | string
  }

  export type AffiliateWhereInput = {
    AND?: AffiliateWhereInput | AffiliateWhereInput[]
    OR?: AffiliateWhereInput[]
    NOT?: AffiliateWhereInput | AffiliateWhereInput[]
    id?: StringFilter<"Affiliate"> | string
    userId?: StringFilter<"Affiliate"> | string
    status?: EnumAffiliateStatusFilter<"Affiliate"> | $Enums.AffiliateStatus
    slug?: StringFilter<"Affiliate"> | string
    paymentInfo?: StringNullableFilter<"Affiliate"> | string | null
    payoutMethod?: StringNullableFilter<"Affiliate"> | string | null
    payoutEmail?: StringNullableFilter<"Affiliate"> | string | null
    payoutPhone?: StringNullableFilter<"Affiliate"> | string | null
    stripeAccountId?: StringNullableFilter<"Affiliate"> | string | null
    stripeAccountStatus?: StringNullableFilter<"Affiliate"> | string | null
    taxFormCompleted?: BoolFilter<"Affiliate"> | boolean
    tax1099Uploaded?: BoolFilter<"Affiliate"> | boolean
    lastPayoutAt?: DateTimeNullableFilter<"Affiliate"> | Date | string | null
    lockedCommissionRate?: FloatNullableFilter<"Affiliate"> | number | null
    customCommissionRate?: FloatNullableFilter<"Affiliate"> | number | null
    totalEarnings?: FloatFilter<"Affiliate"> | number
    totalPaid?: FloatFilter<"Affiliate"> | number
    balance?: FloatFilter<"Affiliate"> | number
    createdAt?: DateTimeFilter<"Affiliate"> | Date | string
    updatedAt?: DateTimeFilter<"Affiliate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    referrals?: AffiliateReferralListRelationFilter
    payouts?: AffiliatePayoutListRelationFilter
  }

  export type AffiliateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    slug?: SortOrder
    paymentInfo?: SortOrderInput | SortOrder
    payoutMethod?: SortOrderInput | SortOrder
    payoutEmail?: SortOrderInput | SortOrder
    payoutPhone?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeAccountStatus?: SortOrderInput | SortOrder
    taxFormCompleted?: SortOrder
    tax1099Uploaded?: SortOrder
    lastPayoutAt?: SortOrderInput | SortOrder
    lockedCommissionRate?: SortOrderInput | SortOrder
    customCommissionRate?: SortOrderInput | SortOrder
    totalEarnings?: SortOrder
    totalPaid?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    referrals?: AffiliateReferralOrderByRelationAggregateInput
    payouts?: AffiliatePayoutOrderByRelationAggregateInput
  }

  export type AffiliateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    slug?: string
    stripeAccountId?: string
    AND?: AffiliateWhereInput | AffiliateWhereInput[]
    OR?: AffiliateWhereInput[]
    NOT?: AffiliateWhereInput | AffiliateWhereInput[]
    status?: EnumAffiliateStatusFilter<"Affiliate"> | $Enums.AffiliateStatus
    paymentInfo?: StringNullableFilter<"Affiliate"> | string | null
    payoutMethod?: StringNullableFilter<"Affiliate"> | string | null
    payoutEmail?: StringNullableFilter<"Affiliate"> | string | null
    payoutPhone?: StringNullableFilter<"Affiliate"> | string | null
    stripeAccountStatus?: StringNullableFilter<"Affiliate"> | string | null
    taxFormCompleted?: BoolFilter<"Affiliate"> | boolean
    tax1099Uploaded?: BoolFilter<"Affiliate"> | boolean
    lastPayoutAt?: DateTimeNullableFilter<"Affiliate"> | Date | string | null
    lockedCommissionRate?: FloatNullableFilter<"Affiliate"> | number | null
    customCommissionRate?: FloatNullableFilter<"Affiliate"> | number | null
    totalEarnings?: FloatFilter<"Affiliate"> | number
    totalPaid?: FloatFilter<"Affiliate"> | number
    balance?: FloatFilter<"Affiliate"> | number
    createdAt?: DateTimeFilter<"Affiliate"> | Date | string
    updatedAt?: DateTimeFilter<"Affiliate"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    referrals?: AffiliateReferralListRelationFilter
    payouts?: AffiliatePayoutListRelationFilter
  }, "id" | "userId" | "slug" | "stripeAccountId">

  export type AffiliateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    slug?: SortOrder
    paymentInfo?: SortOrderInput | SortOrder
    payoutMethod?: SortOrderInput | SortOrder
    payoutEmail?: SortOrderInput | SortOrder
    payoutPhone?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeAccountStatus?: SortOrderInput | SortOrder
    taxFormCompleted?: SortOrder
    tax1099Uploaded?: SortOrder
    lastPayoutAt?: SortOrderInput | SortOrder
    lockedCommissionRate?: SortOrderInput | SortOrder
    customCommissionRate?: SortOrderInput | SortOrder
    totalEarnings?: SortOrder
    totalPaid?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AffiliateCountOrderByAggregateInput
    _avg?: AffiliateAvgOrderByAggregateInput
    _max?: AffiliateMaxOrderByAggregateInput
    _min?: AffiliateMinOrderByAggregateInput
    _sum?: AffiliateSumOrderByAggregateInput
  }

  export type AffiliateScalarWhereWithAggregatesInput = {
    AND?: AffiliateScalarWhereWithAggregatesInput | AffiliateScalarWhereWithAggregatesInput[]
    OR?: AffiliateScalarWhereWithAggregatesInput[]
    NOT?: AffiliateScalarWhereWithAggregatesInput | AffiliateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Affiliate"> | string
    userId?: StringWithAggregatesFilter<"Affiliate"> | string
    status?: EnumAffiliateStatusWithAggregatesFilter<"Affiliate"> | $Enums.AffiliateStatus
    slug?: StringWithAggregatesFilter<"Affiliate"> | string
    paymentInfo?: StringNullableWithAggregatesFilter<"Affiliate"> | string | null
    payoutMethod?: StringNullableWithAggregatesFilter<"Affiliate"> | string | null
    payoutEmail?: StringNullableWithAggregatesFilter<"Affiliate"> | string | null
    payoutPhone?: StringNullableWithAggregatesFilter<"Affiliate"> | string | null
    stripeAccountId?: StringNullableWithAggregatesFilter<"Affiliate"> | string | null
    stripeAccountStatus?: StringNullableWithAggregatesFilter<"Affiliate"> | string | null
    taxFormCompleted?: BoolWithAggregatesFilter<"Affiliate"> | boolean
    tax1099Uploaded?: BoolWithAggregatesFilter<"Affiliate"> | boolean
    lastPayoutAt?: DateTimeNullableWithAggregatesFilter<"Affiliate"> | Date | string | null
    lockedCommissionRate?: FloatNullableWithAggregatesFilter<"Affiliate"> | number | null
    customCommissionRate?: FloatNullableWithAggregatesFilter<"Affiliate"> | number | null
    totalEarnings?: FloatWithAggregatesFilter<"Affiliate"> | number
    totalPaid?: FloatWithAggregatesFilter<"Affiliate"> | number
    balance?: FloatWithAggregatesFilter<"Affiliate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Affiliate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Affiliate"> | Date | string
  }

  export type AffiliateReferralWhereInput = {
    AND?: AffiliateReferralWhereInput | AffiliateReferralWhereInput[]
    OR?: AffiliateReferralWhereInput[]
    NOT?: AffiliateReferralWhereInput | AffiliateReferralWhereInput[]
    id?: StringFilter<"AffiliateReferral"> | string
    affiliateId?: StringFilter<"AffiliateReferral"> | string
    refereeId?: StringNullableFilter<"AffiliateReferral"> | string | null
    status?: EnumAffiliateReferralStatusFilter<"AffiliateReferral"> | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFilter<"AffiliateReferral"> | number
    createdAt?: DateTimeFilter<"AffiliateReferral"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateReferral"> | Date | string
    affiliate?: XOR<AffiliateRelationFilter, AffiliateWhereInput>
  }

  export type AffiliateReferralOrderByWithRelationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    status?: SortOrder
    commissionAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    affiliate?: AffiliateOrderByWithRelationInput
  }

  export type AffiliateReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refereeId?: string
    AND?: AffiliateReferralWhereInput | AffiliateReferralWhereInput[]
    OR?: AffiliateReferralWhereInput[]
    NOT?: AffiliateReferralWhereInput | AffiliateReferralWhereInput[]
    affiliateId?: StringFilter<"AffiliateReferral"> | string
    status?: EnumAffiliateReferralStatusFilter<"AffiliateReferral"> | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFilter<"AffiliateReferral"> | number
    createdAt?: DateTimeFilter<"AffiliateReferral"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateReferral"> | Date | string
    affiliate?: XOR<AffiliateRelationFilter, AffiliateWhereInput>
  }, "id" | "refereeId">

  export type AffiliateReferralOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    status?: SortOrder
    commissionAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AffiliateReferralCountOrderByAggregateInput
    _avg?: AffiliateReferralAvgOrderByAggregateInput
    _max?: AffiliateReferralMaxOrderByAggregateInput
    _min?: AffiliateReferralMinOrderByAggregateInput
    _sum?: AffiliateReferralSumOrderByAggregateInput
  }

  export type AffiliateReferralScalarWhereWithAggregatesInput = {
    AND?: AffiliateReferralScalarWhereWithAggregatesInput | AffiliateReferralScalarWhereWithAggregatesInput[]
    OR?: AffiliateReferralScalarWhereWithAggregatesInput[]
    NOT?: AffiliateReferralScalarWhereWithAggregatesInput | AffiliateReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AffiliateReferral"> | string
    affiliateId?: StringWithAggregatesFilter<"AffiliateReferral"> | string
    refereeId?: StringNullableWithAggregatesFilter<"AffiliateReferral"> | string | null
    status?: EnumAffiliateReferralStatusWithAggregatesFilter<"AffiliateReferral"> | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatWithAggregatesFilter<"AffiliateReferral"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AffiliateReferral"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AffiliateReferral"> | Date | string
  }

  export type AffiliatePayoutWhereInput = {
    AND?: AffiliatePayoutWhereInput | AffiliatePayoutWhereInput[]
    OR?: AffiliatePayoutWhereInput[]
    NOT?: AffiliatePayoutWhereInput | AffiliatePayoutWhereInput[]
    id?: StringFilter<"AffiliatePayout"> | string
    affiliateId?: StringFilter<"AffiliatePayout"> | string
    amount?: FloatFilter<"AffiliatePayout"> | number
    feeAmount?: FloatFilter<"AffiliatePayout"> | number
    netAmount?: FloatFilter<"AffiliatePayout"> | number
    status?: EnumPayoutStatusFilter<"AffiliatePayout"> | $Enums.PayoutStatus
    method?: StringFilter<"AffiliatePayout"> | string
    transactionId?: StringNullableFilter<"AffiliatePayout"> | string | null
    createdAt?: DateTimeFilter<"AffiliatePayout"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliatePayout"> | Date | string
    affiliate?: XOR<AffiliateRelationFilter, AffiliateWhereInput>
  }

  export type AffiliatePayoutOrderByWithRelationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    affiliate?: AffiliateOrderByWithRelationInput
  }

  export type AffiliatePayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AffiliatePayoutWhereInput | AffiliatePayoutWhereInput[]
    OR?: AffiliatePayoutWhereInput[]
    NOT?: AffiliatePayoutWhereInput | AffiliatePayoutWhereInput[]
    affiliateId?: StringFilter<"AffiliatePayout"> | string
    amount?: FloatFilter<"AffiliatePayout"> | number
    feeAmount?: FloatFilter<"AffiliatePayout"> | number
    netAmount?: FloatFilter<"AffiliatePayout"> | number
    status?: EnumPayoutStatusFilter<"AffiliatePayout"> | $Enums.PayoutStatus
    method?: StringFilter<"AffiliatePayout"> | string
    transactionId?: StringNullableFilter<"AffiliatePayout"> | string | null
    createdAt?: DateTimeFilter<"AffiliatePayout"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliatePayout"> | Date | string
    affiliate?: XOR<AffiliateRelationFilter, AffiliateWhereInput>
  }, "id">

  export type AffiliatePayoutOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AffiliatePayoutCountOrderByAggregateInput
    _avg?: AffiliatePayoutAvgOrderByAggregateInput
    _max?: AffiliatePayoutMaxOrderByAggregateInput
    _min?: AffiliatePayoutMinOrderByAggregateInput
    _sum?: AffiliatePayoutSumOrderByAggregateInput
  }

  export type AffiliatePayoutScalarWhereWithAggregatesInput = {
    AND?: AffiliatePayoutScalarWhereWithAggregatesInput | AffiliatePayoutScalarWhereWithAggregatesInput[]
    OR?: AffiliatePayoutScalarWhereWithAggregatesInput[]
    NOT?: AffiliatePayoutScalarWhereWithAggregatesInput | AffiliatePayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AffiliatePayout"> | string
    affiliateId?: StringWithAggregatesFilter<"AffiliatePayout"> | string
    amount?: FloatWithAggregatesFilter<"AffiliatePayout"> | number
    feeAmount?: FloatWithAggregatesFilter<"AffiliatePayout"> | number
    netAmount?: FloatWithAggregatesFilter<"AffiliatePayout"> | number
    status?: EnumPayoutStatusWithAggregatesFilter<"AffiliatePayout"> | $Enums.PayoutStatus
    method?: StringWithAggregatesFilter<"AffiliatePayout"> | string
    transactionId?: StringNullableWithAggregatesFilter<"AffiliatePayout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AffiliatePayout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AffiliatePayout"> | Date | string
  }

  export type ConversationPackageWhereInput = {
    AND?: ConversationPackageWhereInput | ConversationPackageWhereInput[]
    OR?: ConversationPackageWhereInput[]
    NOT?: ConversationPackageWhereInput | ConversationPackageWhereInput[]
    id?: StringFilter<"ConversationPackage"> | string
    name?: StringFilter<"ConversationPackage"> | string
    price?: FloatFilter<"ConversationPackage"> | number
    credits?: IntFilter<"ConversationPackage"> | number
    active?: BoolFilter<"ConversationPackage"> | boolean
    createdAt?: DateTimeFilter<"ConversationPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationPackage"> | Date | string
  }

  export type ConversationPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationPackageWhereInput | ConversationPackageWhereInput[]
    OR?: ConversationPackageWhereInput[]
    NOT?: ConversationPackageWhereInput | ConversationPackageWhereInput[]
    name?: StringFilter<"ConversationPackage"> | string
    price?: FloatFilter<"ConversationPackage"> | number
    credits?: IntFilter<"ConversationPackage"> | number
    active?: BoolFilter<"ConversationPackage"> | boolean
    createdAt?: DateTimeFilter<"ConversationPackage"> | Date | string
    updatedAt?: DateTimeFilter<"ConversationPackage"> | Date | string
  }, "id">

  export type ConversationPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationPackageCountOrderByAggregateInput
    _avg?: ConversationPackageAvgOrderByAggregateInput
    _max?: ConversationPackageMaxOrderByAggregateInput
    _min?: ConversationPackageMinOrderByAggregateInput
    _sum?: ConversationPackageSumOrderByAggregateInput
  }

  export type ConversationPackageScalarWhereWithAggregatesInput = {
    AND?: ConversationPackageScalarWhereWithAggregatesInput | ConversationPackageScalarWhereWithAggregatesInput[]
    OR?: ConversationPackageScalarWhereWithAggregatesInput[]
    NOT?: ConversationPackageScalarWhereWithAggregatesInput | ConversationPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationPackage"> | string
    name?: StringWithAggregatesFilter<"ConversationPackage"> | string
    price?: FloatWithAggregatesFilter<"ConversationPackage"> | number
    credits?: IntWithAggregatesFilter<"ConversationPackage"> | number
    active?: BoolWithAggregatesFilter<"ConversationPackage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ConversationPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConversationPackage"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    agents?: AgentCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    agents?: AgentUncheckedCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigUncheckedCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    agents?: AgentUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    agents?: AgentUncheckedUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUncheckedUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantTwilioConfigCreateInput = {
    id?: string
    accountSid: string
    authToken: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTwilioConfigInput
  }

  export type TenantTwilioConfigUncheckedCreateInput = {
    id?: string
    tenantId: string
    accountSid: string
    authToken: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantTwilioConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountSid?: StringFieldUpdateOperationsInput | string
    authToken?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTwilioConfigNestedInput
  }

  export type TenantTwilioConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountSid?: StringFieldUpdateOperationsInput | string
    authToken?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantTwilioConfigCreateManyInput = {
    id?: string
    tenantId: string
    accountSid: string
    authToken: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantTwilioConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountSid?: StringFieldUpdateOperationsInput | string
    authToken?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantTwilioConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountSid?: StringFieldUpdateOperationsInput | string
    authToken?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    referralsCreated?: ReferralCreateNestedManyWithoutReferrerInput
    affiliate?: AffiliateCreateNestedOneWithoutUserInput
    rewards?: RewardTransactionCreateNestedManyWithoutReferrerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    referralsCreated?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    affiliate?: AffiliateUncheckedCreateNestedOneWithoutUserInput
    rewards?: RewardTransactionUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    referralsCreated?: ReferralUpdateManyWithoutReferrerNestedInput
    affiliate?: AffiliateUpdateOneWithoutUserNestedInput
    rewards?: RewardTransactionUpdateManyWithoutReferrerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    referralsCreated?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    affiliate?: AffiliateUncheckedUpdateOneWithoutUserNestedInput
    rewards?: RewardTransactionUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentCreateInput = {
    id?: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAgentsInput
    transcripts?: TranscriptCreateNestedManyWithoutAgentInput
    toolAudits?: ToolExecutionAuditCreateNestedManyWithoutAgentInput
    leads?: LeadCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutAgentInput
    toolAudits?: ToolExecutionAuditUncheckedCreateNestedManyWithoutAgentInput
    leads?: LeadUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgentsNestedInput
    transcripts?: TranscriptUpdateManyWithoutAgentNestedInput
    toolAudits?: ToolExecutionAuditUpdateManyWithoutAgentNestedInput
    leads?: LeadUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcripts?: TranscriptUncheckedUpdateManyWithoutAgentNestedInput
    toolAudits?: ToolExecutionAuditUncheckedUpdateManyWithoutAgentNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    key: string
    name: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    tenantId: string
    key: string
    name: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    tenantId: string
    key: string
    name: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptCreateInput = {
    id?: string
    userId?: string | null
    content: string
    duration?: number
    createdAt?: Date | string
    agent: AgentCreateNestedOneWithoutTranscriptsInput
  }

  export type TranscriptUncheckedCreateInput = {
    id?: string
    agentId: string
    userId?: string | null
    content: string
    duration?: number
    createdAt?: Date | string
  }

  export type TranscriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutTranscriptsNestedInput
  }

  export type TranscriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptCreateManyInput = {
    id?: string
    agentId: string
    userId?: string | null
    content: string
    duration?: number
    createdAt?: Date | string
  }

  export type TranscriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    refereeId?: string | null
    code: string
    status?: string
    rewardAmount?: number
    rewardCurrency?: string
    expiresAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsCreatedInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerId: string
    refereeId?: string | null
    code: string
    status?: string
    rewardAmount?: number
    rewardCurrency?: string
    expiresAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rewardAmount?: FloatFieldUpdateOperationsInput | number
    rewardCurrency?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsCreatedNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rewardAmount?: FloatFieldUpdateOperationsInput | number
    rewardCurrency?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerId: string
    refereeId?: string | null
    code: string
    status?: string
    rewardAmount?: number
    rewardCurrency?: string
    expiresAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rewardAmount?: FloatFieldUpdateOperationsInput | number
    rewardCurrency?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rewardAmount?: FloatFieldUpdateOperationsInput | number
    rewardCurrency?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionCreateInput = {
    id?: string
    refereeId?: string | null
    amount: number
    status?: string
    sourcePaymentId?: string | null
    holdEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutRewardsInput
  }

  export type RewardTransactionUncheckedCreateInput = {
    id?: string
    referrerId: string
    refereeId?: string | null
    amount: number
    status?: string
    sourcePaymentId?: string | null
    holdEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sourcePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    holdEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type RewardTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sourcePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    holdEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionCreateManyInput = {
    id?: string
    referrerId: string
    refereeId?: string | null
    amount: number
    status?: string
    sourcePaymentId?: string | null
    holdEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sourcePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    holdEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sourcePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    holdEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolExecutionAuditCreateInput = {
    id?: string
    userId?: string | null
    toolName: string
    toolInput: string
    toolOutput?: string | null
    status?: string
    errorMessage?: string | null
    executionTimeMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutToolAuditsInput
  }

  export type ToolExecutionAuditUncheckedCreateInput = {
    id?: string
    agentId: string
    userId?: string | null
    toolName: string
    toolInput: string
    toolOutput?: string | null
    status?: string
    errorMessage?: string | null
    executionTimeMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ToolExecutionAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    toolInput?: StringFieldUpdateOperationsInput | string
    toolOutput?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTimeMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutToolAuditsNestedInput
  }

  export type ToolExecutionAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    toolInput?: StringFieldUpdateOperationsInput | string
    toolOutput?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTimeMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolExecutionAuditCreateManyInput = {
    id?: string
    agentId: string
    userId?: string | null
    toolName: string
    toolInput: string
    toolOutput?: string | null
    status?: string
    errorMessage?: string | null
    executionTimeMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ToolExecutionAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    toolInput?: StringFieldUpdateOperationsInput | string
    toolOutput?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTimeMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolExecutionAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    toolInput?: StringFieldUpdateOperationsInput | string
    toolOutput?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTimeMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
    agent: AgentCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    tenantId: string
    agentId: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    agent?: AgentUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyInput = {
    id?: string
    tenantId: string
    agentId: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAuthConfigCreateInput = {
    id?: string
    clientId?: string | null
    clientSecret?: string | null
    redirectUri?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleAuthConfigUncheckedCreateInput = {
    id?: string
    clientId?: string | null
    clientSecret?: string | null
    redirectUri?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleAuthConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAuthConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAuthConfigCreateManyInput = {
    id?: string
    clientId?: string | null
    clientSecret?: string | null
    redirectUri?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleAuthConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleAuthConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemEmailConfigCreateInput = {
    id?: string
    username?: string | null
    password?: string | null
    imapServer?: string | null
    imapPort?: string | null
    imapSecurity?: string | null
    smtpServer?: string | null
    smtpPort?: string | null
    smtpSecurity?: string | null
    pop3Server?: string | null
    pop3Port?: string | null
    pop3Security?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemEmailConfigUncheckedCreateInput = {
    id?: string
    username?: string | null
    password?: string | null
    imapServer?: string | null
    imapPort?: string | null
    imapSecurity?: string | null
    smtpServer?: string | null
    smtpPort?: string | null
    smtpSecurity?: string | null
    pop3Server?: string | null
    pop3Port?: string | null
    pop3Security?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemEmailConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imapServer?: NullableStringFieldUpdateOperationsInput | string | null
    imapPort?: NullableStringFieldUpdateOperationsInput | string | null
    imapSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    smtpServer?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Server?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Port?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Security?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemEmailConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imapServer?: NullableStringFieldUpdateOperationsInput | string | null
    imapPort?: NullableStringFieldUpdateOperationsInput | string | null
    imapSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    smtpServer?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Server?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Port?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Security?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemEmailConfigCreateManyInput = {
    id?: string
    username?: string | null
    password?: string | null
    imapServer?: string | null
    imapPort?: string | null
    imapSecurity?: string | null
    smtpServer?: string | null
    smtpPort?: string | null
    smtpSecurity?: string | null
    pop3Server?: string | null
    pop3Port?: string | null
    pop3Security?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemEmailConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imapServer?: NullableStringFieldUpdateOperationsInput | string | null
    imapPort?: NullableStringFieldUpdateOperationsInput | string | null
    imapSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    smtpServer?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Server?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Port?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Security?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemEmailConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    imapServer?: NullableStringFieldUpdateOperationsInput | string | null
    imapPort?: NullableStringFieldUpdateOperationsInput | string | null
    imapSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    smtpServer?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableStringFieldUpdateOperationsInput | string | null
    smtpSecurity?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Server?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Port?: NullableStringFieldUpdateOperationsInput | string | null
    pop3Security?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConnectConfigCreateInput = {
    id?: string
    clientId?: string | null
    enabled?: boolean
    minimumPayout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeConnectConfigUncheckedCreateInput = {
    id?: string
    clientId?: string | null
    enabled?: boolean
    minimumPayout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeConnectConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    minimumPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConnectConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    minimumPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConnectConfigCreateManyInput = {
    id?: string
    clientId?: string | null
    enabled?: boolean
    minimumPayout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeConnectConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    minimumPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConnectConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    minimumPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantGoogleConfigCreateInput = {
    id?: string
    clientId: string
    clientSecret: string
    geminiApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutGoogleConfigInput
  }

  export type TenantGoogleConfigUncheckedCreateInput = {
    id?: string
    tenantId: string
    clientId: string
    clientSecret: string
    geminiApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantGoogleConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutGoogleConfigNestedInput
  }

  export type TenantGoogleConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantGoogleConfigCreateManyInput = {
    id?: string
    tenantId: string
    clientId: string
    clientSecret: string
    geminiApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantGoogleConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantGoogleConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCredentialsCreateInput = {
    id?: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    calendarEmail?: string | null
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarCredentialsUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    calendarEmail?: string | null
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarCredentialsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCredentialsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCredentialsCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    calendarEmail?: string | null
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarCredentialsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCredentialsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calendarEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailCredentialsCreateInput = {
    id?: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    gmailEmail?: string | null
    scope?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailCredentialsUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    gmailEmail?: string | null
    scope?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailCredentialsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmailEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailCredentialsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmailEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailCredentialsCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    gmailEmail?: string | null
    scope?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailCredentialsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmailEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailCredentialsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmailEmail?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSettingsCreateInput = {
    id?: string
    lowCommission?: number
    medCommission?: number
    highCommission?: number
    commissionDurationMonths?: number
    defaultCommissionLevel?: $Enums.CommissionLevel
    payoutMinimum?: number
    refundHoldDays?: number
    payoutCycleDelayMonths?: number
    transactionFeePercent?: number
    starterLimit?: number
    professionalLimit?: number
    enterpriseLimit?: number
    ltdLimit?: number
    aiInfraLimit?: number
    updatedAt?: Date | string
  }

  export type PlatformSettingsUncheckedCreateInput = {
    id?: string
    lowCommission?: number
    medCommission?: number
    highCommission?: number
    commissionDurationMonths?: number
    defaultCommissionLevel?: $Enums.CommissionLevel
    payoutMinimum?: number
    refundHoldDays?: number
    payoutCycleDelayMonths?: number
    transactionFeePercent?: number
    starterLimit?: number
    professionalLimit?: number
    enterpriseLimit?: number
    ltdLimit?: number
    aiInfraLimit?: number
    updatedAt?: Date | string
  }

  export type PlatformSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lowCommission?: FloatFieldUpdateOperationsInput | number
    medCommission?: FloatFieldUpdateOperationsInput | number
    highCommission?: FloatFieldUpdateOperationsInput | number
    commissionDurationMonths?: IntFieldUpdateOperationsInput | number
    defaultCommissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    payoutMinimum?: FloatFieldUpdateOperationsInput | number
    refundHoldDays?: IntFieldUpdateOperationsInput | number
    payoutCycleDelayMonths?: IntFieldUpdateOperationsInput | number
    transactionFeePercent?: FloatFieldUpdateOperationsInput | number
    starterLimit?: IntFieldUpdateOperationsInput | number
    professionalLimit?: IntFieldUpdateOperationsInput | number
    enterpriseLimit?: IntFieldUpdateOperationsInput | number
    ltdLimit?: IntFieldUpdateOperationsInput | number
    aiInfraLimit?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lowCommission?: FloatFieldUpdateOperationsInput | number
    medCommission?: FloatFieldUpdateOperationsInput | number
    highCommission?: FloatFieldUpdateOperationsInput | number
    commissionDurationMonths?: IntFieldUpdateOperationsInput | number
    defaultCommissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    payoutMinimum?: FloatFieldUpdateOperationsInput | number
    refundHoldDays?: IntFieldUpdateOperationsInput | number
    payoutCycleDelayMonths?: IntFieldUpdateOperationsInput | number
    transactionFeePercent?: FloatFieldUpdateOperationsInput | number
    starterLimit?: IntFieldUpdateOperationsInput | number
    professionalLimit?: IntFieldUpdateOperationsInput | number
    enterpriseLimit?: IntFieldUpdateOperationsInput | number
    ltdLimit?: IntFieldUpdateOperationsInput | number
    aiInfraLimit?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSettingsCreateManyInput = {
    id?: string
    lowCommission?: number
    medCommission?: number
    highCommission?: number
    commissionDurationMonths?: number
    defaultCommissionLevel?: $Enums.CommissionLevel
    payoutMinimum?: number
    refundHoldDays?: number
    payoutCycleDelayMonths?: number
    transactionFeePercent?: number
    starterLimit?: number
    professionalLimit?: number
    enterpriseLimit?: number
    ltdLimit?: number
    aiInfraLimit?: number
    updatedAt?: Date | string
  }

  export type PlatformSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lowCommission?: FloatFieldUpdateOperationsInput | number
    medCommission?: FloatFieldUpdateOperationsInput | number
    highCommission?: FloatFieldUpdateOperationsInput | number
    commissionDurationMonths?: IntFieldUpdateOperationsInput | number
    defaultCommissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    payoutMinimum?: FloatFieldUpdateOperationsInput | number
    refundHoldDays?: IntFieldUpdateOperationsInput | number
    payoutCycleDelayMonths?: IntFieldUpdateOperationsInput | number
    transactionFeePercent?: FloatFieldUpdateOperationsInput | number
    starterLimit?: IntFieldUpdateOperationsInput | number
    professionalLimit?: IntFieldUpdateOperationsInput | number
    enterpriseLimit?: IntFieldUpdateOperationsInput | number
    ltdLimit?: IntFieldUpdateOperationsInput | number
    aiInfraLimit?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lowCommission?: FloatFieldUpdateOperationsInput | number
    medCommission?: FloatFieldUpdateOperationsInput | number
    highCommission?: FloatFieldUpdateOperationsInput | number
    commissionDurationMonths?: IntFieldUpdateOperationsInput | number
    defaultCommissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    payoutMinimum?: FloatFieldUpdateOperationsInput | number
    refundHoldDays?: IntFieldUpdateOperationsInput | number
    payoutCycleDelayMonths?: IntFieldUpdateOperationsInput | number
    transactionFeePercent?: FloatFieldUpdateOperationsInput | number
    starterLimit?: IntFieldUpdateOperationsInput | number
    professionalLimit?: IntFieldUpdateOperationsInput | number
    enterpriseLimit?: IntFieldUpdateOperationsInput | number
    ltdLimit?: IntFieldUpdateOperationsInput | number
    aiInfraLimit?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateCreateInput = {
    id?: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateInput
    referrals?: AffiliateReferralCreateNestedManyWithoutAffiliateInput
    payouts?: AffiliatePayoutCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referrals?: AffiliateReferralUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: AffiliatePayoutUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateNestedInput
    referrals?: AffiliateReferralUpdateManyWithoutAffiliateNestedInput
    payouts?: AffiliatePayoutUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: AffiliateReferralUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: AffiliatePayoutUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateReferralCreateInput = {
    id?: string
    refereeId?: string | null
    status?: $Enums.AffiliateReferralStatus
    commissionAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateCreateNestedOneWithoutReferralsInput
  }

  export type AffiliateReferralUncheckedCreateInput = {
    id?: string
    affiliateId: string
    refereeId?: string | null
    status?: $Enums.AffiliateReferralStatus
    commissionAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAffiliateReferralStatusFieldUpdateOperationsInput | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type AffiliateReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAffiliateReferralStatusFieldUpdateOperationsInput | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateReferralCreateManyInput = {
    id?: string
    affiliateId: string
    refereeId?: string | null
    status?: $Enums.AffiliateReferralStatus
    commissionAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAffiliateReferralStatusFieldUpdateOperationsInput | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAffiliateReferralStatusFieldUpdateOperationsInput | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliatePayoutCreateInput = {
    id?: string
    amount: number
    feeAmount?: number
    netAmount?: number
    status?: $Enums.PayoutStatus
    method?: string
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateCreateNestedOneWithoutPayoutsInput
  }

  export type AffiliatePayoutUncheckedCreateInput = {
    id?: string
    affiliateId: string
    amount: number
    feeAmount?: number
    netAmount?: number
    status?: $Enums.PayoutStatus
    method?: string
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliatePayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    feeAmount?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type AffiliatePayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    feeAmount?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliatePayoutCreateManyInput = {
    id?: string
    affiliateId: string
    amount: number
    feeAmount?: number
    netAmount?: number
    status?: $Enums.PayoutStatus
    method?: string
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliatePayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    feeAmount?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliatePayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    feeAmount?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationPackageCreateInput = {
    id?: string
    name: string
    price: number
    credits: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationPackageUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    credits: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationPackageCreateManyInput = {
    id?: string
    name: string
    price: number
    credits: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type TenantGoogleConfigNullableRelationFilter = {
    is?: TenantGoogleConfigWhereInput | null
    isNot?: TenantGoogleConfigWhereInput | null
  }

  export type TenantTwilioConfigNullableRelationFilter = {
    is?: TenantTwilioConfigWhereInput | null
    isNot?: TenantTwilioConfigWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionEnds?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    usageResetAt?: SortOrder
    billingEmail?: SortOrder
    creditBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    usageLimit?: SortOrder
    usageCount?: SortOrder
    creditBalance?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionEnds?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    usageResetAt?: SortOrder
    billingEmail?: SortOrder
    creditBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionEnds?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    usageResetAt?: SortOrder
    billingEmail?: SortOrder
    creditBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    usageLimit?: SortOrder
    usageCount?: SortOrder
    creditBalance?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantTwilioConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountSid?: SortOrder
    authToken?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantTwilioConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountSid?: SortOrder
    authToken?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantTwilioConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountSid?: SortOrder
    authToken?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumCommissionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionLevel | EnumCommissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionLevelFilter<$PrismaModel> | $Enums.CommissionLevel
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type AffiliateNullableRelationFilter = {
    is?: AffiliateWhereInput | null
    isNot?: AffiliateWhereInput | null
  }

  export type RewardTransactionListRelationFilter = {
    every?: RewardTransactionWhereInput
    some?: RewardTransactionWhereInput
    none?: RewardTransactionWhereInput
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    avatar?: SortOrder
    commissionLevel?: SortOrder
    googleId?: SortOrder
    googleEmail?: SortOrder
    googleName?: SortOrder
    googleProfilePicture?: SortOrder
    googleAuthProvider?: SortOrder
    referralCodeUsed?: SortOrder
    referralRewardTotal?: SortOrder
    isAffiliate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    unit?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    tinSsn?: SortOrder
    taxFormUrl?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    referralRewardTotal?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    avatar?: SortOrder
    commissionLevel?: SortOrder
    googleId?: SortOrder
    googleEmail?: SortOrder
    googleName?: SortOrder
    googleProfilePicture?: SortOrder
    googleAuthProvider?: SortOrder
    referralCodeUsed?: SortOrder
    referralRewardTotal?: SortOrder
    isAffiliate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    unit?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    tinSsn?: SortOrder
    taxFormUrl?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    isAdmin?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    avatar?: SortOrder
    commissionLevel?: SortOrder
    googleId?: SortOrder
    googleEmail?: SortOrder
    googleName?: SortOrder
    googleProfilePicture?: SortOrder
    googleAuthProvider?: SortOrder
    referralCodeUsed?: SortOrder
    referralRewardTotal?: SortOrder
    isAffiliate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    businessName?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    unit?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    tinSsn?: SortOrder
    taxFormUrl?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    referralRewardTotal?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumCommissionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionLevel | EnumCommissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionLevelWithAggregatesFilter<$PrismaModel> | $Enums.CommissionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionLevelFilter<$PrismaModel>
    _max?: NestedEnumCommissionLevelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TranscriptListRelationFilter = {
    every?: TranscriptWhereInput
    some?: TranscriptWhereInput
    none?: TranscriptWhereInput
  }

  export type ToolExecutionAuditListRelationFilter = {
    every?: ToolExecutionAuditWhereInput
    some?: ToolExecutionAuditWhereInput
    none?: ToolExecutionAuditWhereInput
  }

  export type TranscriptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ToolExecutionAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    systemPrompt?: SortOrder
    voiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    systemPrompt?: SortOrder
    voiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    systemPrompt?: SortOrder
    voiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    key?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AgentRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type TranscriptCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type TranscriptMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    rewardAmount?: SortOrder
    rewardCurrency?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    rewardAmount?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    rewardAmount?: SortOrder
    rewardCurrency?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    rewardAmount?: SortOrder
    rewardCurrency?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    rewardAmount?: SortOrder
  }

  export type RewardTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    sourcePaymentId?: SortOrder
    holdEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RewardTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    sourcePaymentId?: SortOrder
    holdEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    sourcePaymentId?: SortOrder
    holdEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ToolExecutionAuditCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    toolName?: SortOrder
    toolInput?: SortOrder
    toolOutput?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ToolExecutionAuditAvgOrderByAggregateInput = {
    executionTimeMs?: SortOrder
  }

  export type ToolExecutionAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    toolName?: SortOrder
    toolInput?: SortOrder
    toolOutput?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ToolExecutionAuditMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    userId?: SortOrder
    toolName?: SortOrder
    toolInput?: SortOrder
    toolOutput?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    executionTimeMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ToolExecutionAuditSumOrderByAggregateInput = {
    executionTimeMs?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    summary?: SortOrder
    isBooked?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    summary?: SortOrder
    isBooked?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    agentId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    summary?: SortOrder
    isBooked?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleAuthConfigCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUri?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleAuthConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUri?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleAuthConfigMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUri?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemEmailConfigCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    imapServer?: SortOrder
    imapPort?: SortOrder
    imapSecurity?: SortOrder
    smtpServer?: SortOrder
    smtpPort?: SortOrder
    smtpSecurity?: SortOrder
    pop3Server?: SortOrder
    pop3Port?: SortOrder
    pop3Security?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemEmailConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    imapServer?: SortOrder
    imapPort?: SortOrder
    imapSecurity?: SortOrder
    smtpServer?: SortOrder
    smtpPort?: SortOrder
    smtpSecurity?: SortOrder
    pop3Server?: SortOrder
    pop3Port?: SortOrder
    pop3Security?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemEmailConfigMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    imapServer?: SortOrder
    imapPort?: SortOrder
    imapSecurity?: SortOrder
    smtpServer?: SortOrder
    smtpPort?: SortOrder
    smtpSecurity?: SortOrder
    pop3Server?: SortOrder
    pop3Port?: SortOrder
    pop3Security?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConnectConfigCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    enabled?: SortOrder
    minimumPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConnectConfigAvgOrderByAggregateInput = {
    minimumPayout?: SortOrder
  }

  export type StripeConnectConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    enabled?: SortOrder
    minimumPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConnectConfigMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    enabled?: SortOrder
    minimumPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConnectConfigSumOrderByAggregateInput = {
    minimumPayout?: SortOrder
  }

  export type TenantGoogleConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    geminiApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantGoogleConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    geminiApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantGoogleConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    geminiApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarCredentialsUserIdTenantIdCompoundUniqueInput = {
    userId: string
    tenantId: string
  }

  export type CalendarCredentialsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    calendarEmail?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarCredentialsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    calendarEmail?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarCredentialsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    calendarEmail?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailCredentialsUserIdTenantIdCompoundUniqueInput = {
    userId: string
    tenantId: string
  }

  export type GmailCredentialsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    gmailEmail?: SortOrder
    scope?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailCredentialsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    gmailEmail?: SortOrder
    scope?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailCredentialsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    gmailEmail?: SortOrder
    scope?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    lowCommission?: SortOrder
    medCommission?: SortOrder
    highCommission?: SortOrder
    commissionDurationMonths?: SortOrder
    defaultCommissionLevel?: SortOrder
    payoutMinimum?: SortOrder
    refundHoldDays?: SortOrder
    payoutCycleDelayMonths?: SortOrder
    transactionFeePercent?: SortOrder
    starterLimit?: SortOrder
    professionalLimit?: SortOrder
    enterpriseLimit?: SortOrder
    ltdLimit?: SortOrder
    aiInfraLimit?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsAvgOrderByAggregateInput = {
    lowCommission?: SortOrder
    medCommission?: SortOrder
    highCommission?: SortOrder
    commissionDurationMonths?: SortOrder
    payoutMinimum?: SortOrder
    refundHoldDays?: SortOrder
    payoutCycleDelayMonths?: SortOrder
    transactionFeePercent?: SortOrder
    starterLimit?: SortOrder
    professionalLimit?: SortOrder
    enterpriseLimit?: SortOrder
    ltdLimit?: SortOrder
    aiInfraLimit?: SortOrder
  }

  export type PlatformSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    lowCommission?: SortOrder
    medCommission?: SortOrder
    highCommission?: SortOrder
    commissionDurationMonths?: SortOrder
    defaultCommissionLevel?: SortOrder
    payoutMinimum?: SortOrder
    refundHoldDays?: SortOrder
    payoutCycleDelayMonths?: SortOrder
    transactionFeePercent?: SortOrder
    starterLimit?: SortOrder
    professionalLimit?: SortOrder
    enterpriseLimit?: SortOrder
    ltdLimit?: SortOrder
    aiInfraLimit?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    lowCommission?: SortOrder
    medCommission?: SortOrder
    highCommission?: SortOrder
    commissionDurationMonths?: SortOrder
    defaultCommissionLevel?: SortOrder
    payoutMinimum?: SortOrder
    refundHoldDays?: SortOrder
    payoutCycleDelayMonths?: SortOrder
    transactionFeePercent?: SortOrder
    starterLimit?: SortOrder
    professionalLimit?: SortOrder
    enterpriseLimit?: SortOrder
    ltdLimit?: SortOrder
    aiInfraLimit?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSettingsSumOrderByAggregateInput = {
    lowCommission?: SortOrder
    medCommission?: SortOrder
    highCommission?: SortOrder
    commissionDurationMonths?: SortOrder
    payoutMinimum?: SortOrder
    refundHoldDays?: SortOrder
    payoutCycleDelayMonths?: SortOrder
    transactionFeePercent?: SortOrder
    starterLimit?: SortOrder
    professionalLimit?: SortOrder
    enterpriseLimit?: SortOrder
    ltdLimit?: SortOrder
    aiInfraLimit?: SortOrder
  }

  export type EnumAffiliateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatus | EnumAffiliateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusFilter<$PrismaModel> | $Enums.AffiliateStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AffiliateReferralListRelationFilter = {
    every?: AffiliateReferralWhereInput
    some?: AffiliateReferralWhereInput
    none?: AffiliateReferralWhereInput
  }

  export type AffiliatePayoutListRelationFilter = {
    every?: AffiliatePayoutWhereInput
    some?: AffiliatePayoutWhereInput
    none?: AffiliatePayoutWhereInput
  }

  export type AffiliateReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliatePayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    slug?: SortOrder
    paymentInfo?: SortOrder
    payoutMethod?: SortOrder
    payoutEmail?: SortOrder
    payoutPhone?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
    taxFormCompleted?: SortOrder
    tax1099Uploaded?: SortOrder
    lastPayoutAt?: SortOrder
    lockedCommissionRate?: SortOrder
    customCommissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalPaid?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateAvgOrderByAggregateInput = {
    lockedCommissionRate?: SortOrder
    customCommissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalPaid?: SortOrder
    balance?: SortOrder
  }

  export type AffiliateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    slug?: SortOrder
    paymentInfo?: SortOrder
    payoutMethod?: SortOrder
    payoutEmail?: SortOrder
    payoutPhone?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
    taxFormCompleted?: SortOrder
    tax1099Uploaded?: SortOrder
    lastPayoutAt?: SortOrder
    lockedCommissionRate?: SortOrder
    customCommissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalPaid?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    slug?: SortOrder
    paymentInfo?: SortOrder
    payoutMethod?: SortOrder
    payoutEmail?: SortOrder
    payoutPhone?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
    taxFormCompleted?: SortOrder
    tax1099Uploaded?: SortOrder
    lastPayoutAt?: SortOrder
    lockedCommissionRate?: SortOrder
    customCommissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalPaid?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateSumOrderByAggregateInput = {
    lockedCommissionRate?: SortOrder
    customCommissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalPaid?: SortOrder
    balance?: SortOrder
  }

  export type EnumAffiliateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatus | EnumAffiliateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateStatusFilter<$PrismaModel>
    _max?: NestedEnumAffiliateStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumAffiliateReferralStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateReferralStatus | EnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateReferralStatusFilter<$PrismaModel> | $Enums.AffiliateReferralStatus
  }

  export type AffiliateRelationFilter = {
    is?: AffiliateWhereInput
    isNot?: AffiliateWhereInput
  }

  export type AffiliateReferralCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    refereeId?: SortOrder
    status?: SortOrder
    commissionAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateReferralAvgOrderByAggregateInput = {
    commissionAmount?: SortOrder
  }

  export type AffiliateReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    refereeId?: SortOrder
    status?: SortOrder
    commissionAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateReferralMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    refereeId?: SortOrder
    status?: SortOrder
    commissionAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateReferralSumOrderByAggregateInput = {
    commissionAmount?: SortOrder
  }

  export type EnumAffiliateReferralStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateReferralStatus | EnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateReferralStatusWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateReferralStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateReferralStatusFilter<$PrismaModel>
    _max?: NestedEnumAffiliateReferralStatusFilter<$PrismaModel>
  }

  export type EnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type AffiliatePayoutCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliatePayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type AffiliatePayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliatePayoutMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliatePayoutSumOrderByAggregateInput = {
    amount?: SortOrder
    feeAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type EnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type ConversationPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationPackageAvgOrderByAggregateInput = {
    price?: SortOrder
    credits?: SortOrder
  }

  export type ConversationPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationPackageSumOrderByAggregateInput = {
    price?: SortOrder
    credits?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutTenantInput = {
    create?: XOR<AgentCreateWithoutTenantInput, AgentUncheckedCreateWithoutTenantInput> | AgentCreateWithoutTenantInput[] | AgentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTenantInput | AgentCreateOrConnectWithoutTenantInput[]
    createMany?: AgentCreateManyTenantInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutTenantInput = {
    create?: XOR<ApiKeyCreateWithoutTenantInput, ApiKeyUncheckedCreateWithoutTenantInput> | ApiKeyCreateWithoutTenantInput[] | ApiKeyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTenantInput | ApiKeyCreateOrConnectWithoutTenantInput[]
    createMany?: ApiKeyCreateManyTenantInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type TenantGoogleConfigCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantGoogleConfigCreateWithoutTenantInput, TenantGoogleConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantGoogleConfigCreateOrConnectWithoutTenantInput
    connect?: TenantGoogleConfigWhereUniqueInput
  }

  export type TenantTwilioConfigCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantTwilioConfigCreateWithoutTenantInput, TenantTwilioConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantTwilioConfigCreateOrConnectWithoutTenantInput
    connect?: TenantTwilioConfigWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AgentCreateWithoutTenantInput, AgentUncheckedCreateWithoutTenantInput> | AgentCreateWithoutTenantInput[] | AgentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTenantInput | AgentCreateOrConnectWithoutTenantInput[]
    createMany?: AgentCreateManyTenantInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ApiKeyCreateWithoutTenantInput, ApiKeyUncheckedCreateWithoutTenantInput> | ApiKeyCreateWithoutTenantInput[] | ApiKeyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTenantInput | ApiKeyCreateOrConnectWithoutTenantInput[]
    createMany?: ApiKeyCreateManyTenantInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type TenantGoogleConfigUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantGoogleConfigCreateWithoutTenantInput, TenantGoogleConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantGoogleConfigCreateOrConnectWithoutTenantInput
    connect?: TenantGoogleConfigWhereUniqueInput
  }

  export type TenantTwilioConfigUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantTwilioConfigCreateWithoutTenantInput, TenantTwilioConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantTwilioConfigCreateOrConnectWithoutTenantInput
    connect?: TenantTwilioConfigWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AgentCreateWithoutTenantInput, AgentUncheckedCreateWithoutTenantInput> | AgentCreateWithoutTenantInput[] | AgentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTenantInput | AgentCreateOrConnectWithoutTenantInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutTenantInput | AgentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AgentCreateManyTenantInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutTenantInput | AgentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutTenantInput | AgentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ApiKeyCreateWithoutTenantInput, ApiKeyUncheckedCreateWithoutTenantInput> | ApiKeyCreateWithoutTenantInput[] | ApiKeyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTenantInput | ApiKeyCreateOrConnectWithoutTenantInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutTenantInput | ApiKeyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ApiKeyCreateManyTenantInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutTenantInput | ApiKeyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutTenantInput | ApiKeyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type TenantGoogleConfigUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantGoogleConfigCreateWithoutTenantInput, TenantGoogleConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantGoogleConfigCreateOrConnectWithoutTenantInput
    upsert?: TenantGoogleConfigUpsertWithoutTenantInput
    disconnect?: TenantGoogleConfigWhereInput | boolean
    delete?: TenantGoogleConfigWhereInput | boolean
    connect?: TenantGoogleConfigWhereUniqueInput
    update?: XOR<XOR<TenantGoogleConfigUpdateToOneWithWhereWithoutTenantInput, TenantGoogleConfigUpdateWithoutTenantInput>, TenantGoogleConfigUncheckedUpdateWithoutTenantInput>
  }

  export type TenantTwilioConfigUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantTwilioConfigCreateWithoutTenantInput, TenantTwilioConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantTwilioConfigCreateOrConnectWithoutTenantInput
    upsert?: TenantTwilioConfigUpsertWithoutTenantInput
    disconnect?: TenantTwilioConfigWhereInput | boolean
    delete?: TenantTwilioConfigWhereInput | boolean
    connect?: TenantTwilioConfigWhereUniqueInput
    update?: XOR<XOR<TenantTwilioConfigUpdateToOneWithWhereWithoutTenantInput, TenantTwilioConfigUpdateWithoutTenantInput>, TenantTwilioConfigUncheckedUpdateWithoutTenantInput>
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AgentCreateWithoutTenantInput, AgentUncheckedCreateWithoutTenantInput> | AgentCreateWithoutTenantInput[] | AgentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTenantInput | AgentCreateOrConnectWithoutTenantInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutTenantInput | AgentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AgentCreateManyTenantInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutTenantInput | AgentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutTenantInput | AgentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ApiKeyCreateWithoutTenantInput, ApiKeyUncheckedCreateWithoutTenantInput> | ApiKeyCreateWithoutTenantInput[] | ApiKeyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutTenantInput | ApiKeyCreateOrConnectWithoutTenantInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutTenantInput | ApiKeyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ApiKeyCreateManyTenantInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutTenantInput | ApiKeyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutTenantInput | ApiKeyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type TenantGoogleConfigUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantGoogleConfigCreateWithoutTenantInput, TenantGoogleConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantGoogleConfigCreateOrConnectWithoutTenantInput
    upsert?: TenantGoogleConfigUpsertWithoutTenantInput
    disconnect?: TenantGoogleConfigWhereInput | boolean
    delete?: TenantGoogleConfigWhereInput | boolean
    connect?: TenantGoogleConfigWhereUniqueInput
    update?: XOR<XOR<TenantGoogleConfigUpdateToOneWithWhereWithoutTenantInput, TenantGoogleConfigUpdateWithoutTenantInput>, TenantGoogleConfigUncheckedUpdateWithoutTenantInput>
  }

  export type TenantTwilioConfigUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantTwilioConfigCreateWithoutTenantInput, TenantTwilioConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantTwilioConfigCreateOrConnectWithoutTenantInput
    upsert?: TenantTwilioConfigUpsertWithoutTenantInput
    disconnect?: TenantTwilioConfigWhereInput | boolean
    delete?: TenantTwilioConfigWhereInput | boolean
    connect?: TenantTwilioConfigWhereUniqueInput
    update?: XOR<XOR<TenantTwilioConfigUpdateToOneWithWhereWithoutTenantInput, TenantTwilioConfigUpdateWithoutTenantInput>, TenantTwilioConfigUncheckedUpdateWithoutTenantInput>
  }

  export type TenantCreateNestedOneWithoutTwilioConfigInput = {
    create?: XOR<TenantCreateWithoutTwilioConfigInput, TenantUncheckedCreateWithoutTwilioConfigInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTwilioConfigInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutTwilioConfigNestedInput = {
    create?: XOR<TenantCreateWithoutTwilioConfigInput, TenantUncheckedCreateWithoutTwilioConfigInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTwilioConfigInput
    upsert?: TenantUpsertWithoutTwilioConfigInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTwilioConfigInput, TenantUpdateWithoutTwilioConfigInput>, TenantUncheckedUpdateWithoutTwilioConfigInput>
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type AffiliateCreateNestedOneWithoutUserInput = {
    create?: XOR<AffiliateCreateWithoutUserInput, AffiliateUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutUserInput
    connect?: AffiliateWhereUniqueInput
  }

  export type RewardTransactionCreateNestedManyWithoutReferrerInput = {
    create?: XOR<RewardTransactionCreateWithoutReferrerInput, RewardTransactionUncheckedCreateWithoutReferrerInput> | RewardTransactionCreateWithoutReferrerInput[] | RewardTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutReferrerInput | RewardTransactionCreateOrConnectWithoutReferrerInput[]
    createMany?: RewardTransactionCreateManyReferrerInputEnvelope
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type AffiliateUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AffiliateCreateWithoutUserInput, AffiliateUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutUserInput
    connect?: AffiliateWhereUniqueInput
  }

  export type RewardTransactionUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<RewardTransactionCreateWithoutReferrerInput, RewardTransactionUncheckedCreateWithoutReferrerInput> | RewardTransactionCreateWithoutReferrerInput[] | RewardTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutReferrerInput | RewardTransactionCreateOrConnectWithoutReferrerInput[]
    createMany?: RewardTransactionCreateManyReferrerInputEnvelope
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumCommissionLevelFieldUpdateOperationsInput = {
    set?: $Enums.CommissionLevel
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type AffiliateUpdateOneWithoutUserNestedInput = {
    create?: XOR<AffiliateCreateWithoutUserInput, AffiliateUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutUserInput
    upsert?: AffiliateUpsertWithoutUserInput
    disconnect?: AffiliateWhereInput | boolean
    delete?: AffiliateWhereInput | boolean
    connect?: AffiliateWhereUniqueInput
    update?: XOR<XOR<AffiliateUpdateToOneWithWhereWithoutUserInput, AffiliateUpdateWithoutUserInput>, AffiliateUncheckedUpdateWithoutUserInput>
  }

  export type RewardTransactionUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<RewardTransactionCreateWithoutReferrerInput, RewardTransactionUncheckedCreateWithoutReferrerInput> | RewardTransactionCreateWithoutReferrerInput[] | RewardTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutReferrerInput | RewardTransactionCreateOrConnectWithoutReferrerInput[]
    upsert?: RewardTransactionUpsertWithWhereUniqueWithoutReferrerInput | RewardTransactionUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: RewardTransactionCreateManyReferrerInputEnvelope
    set?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    disconnect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    delete?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    update?: RewardTransactionUpdateWithWhereUniqueWithoutReferrerInput | RewardTransactionUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: RewardTransactionUpdateManyWithWhereWithoutReferrerInput | RewardTransactionUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type AffiliateUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AffiliateCreateWithoutUserInput, AffiliateUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutUserInput
    upsert?: AffiliateUpsertWithoutUserInput
    disconnect?: AffiliateWhereInput | boolean
    delete?: AffiliateWhereInput | boolean
    connect?: AffiliateWhereUniqueInput
    update?: XOR<XOR<AffiliateUpdateToOneWithWhereWithoutUserInput, AffiliateUpdateWithoutUserInput>, AffiliateUncheckedUpdateWithoutUserInput>
  }

  export type RewardTransactionUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<RewardTransactionCreateWithoutReferrerInput, RewardTransactionUncheckedCreateWithoutReferrerInput> | RewardTransactionCreateWithoutReferrerInput[] | RewardTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: RewardTransactionCreateOrConnectWithoutReferrerInput | RewardTransactionCreateOrConnectWithoutReferrerInput[]
    upsert?: RewardTransactionUpsertWithWhereUniqueWithoutReferrerInput | RewardTransactionUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: RewardTransactionCreateManyReferrerInputEnvelope
    set?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    disconnect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    delete?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    connect?: RewardTransactionWhereUniqueInput | RewardTransactionWhereUniqueInput[]
    update?: RewardTransactionUpdateWithWhereUniqueWithoutReferrerInput | RewardTransactionUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: RewardTransactionUpdateManyWithWhereWithoutReferrerInput | RewardTransactionUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutAgentsInput = {
    create?: XOR<TenantCreateWithoutAgentsInput, TenantUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAgentsInput
    connect?: TenantWhereUniqueInput
  }

  export type TranscriptCreateNestedManyWithoutAgentInput = {
    create?: XOR<TranscriptCreateWithoutAgentInput, TranscriptUncheckedCreateWithoutAgentInput> | TranscriptCreateWithoutAgentInput[] | TranscriptUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAgentInput | TranscriptCreateOrConnectWithoutAgentInput[]
    createMany?: TranscriptCreateManyAgentInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type ToolExecutionAuditCreateNestedManyWithoutAgentInput = {
    create?: XOR<ToolExecutionAuditCreateWithoutAgentInput, ToolExecutionAuditUncheckedCreateWithoutAgentInput> | ToolExecutionAuditCreateWithoutAgentInput[] | ToolExecutionAuditUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ToolExecutionAuditCreateOrConnectWithoutAgentInput | ToolExecutionAuditCreateOrConnectWithoutAgentInput[]
    createMany?: ToolExecutionAuditCreateManyAgentInputEnvelope
    connect?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutAgentInput = {
    create?: XOR<LeadCreateWithoutAgentInput, LeadUncheckedCreateWithoutAgentInput> | LeadCreateWithoutAgentInput[] | LeadUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAgentInput | LeadCreateOrConnectWithoutAgentInput[]
    createMany?: LeadCreateManyAgentInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type TranscriptUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<TranscriptCreateWithoutAgentInput, TranscriptUncheckedCreateWithoutAgentInput> | TranscriptCreateWithoutAgentInput[] | TranscriptUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAgentInput | TranscriptCreateOrConnectWithoutAgentInput[]
    createMany?: TranscriptCreateManyAgentInputEnvelope
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
  }

  export type ToolExecutionAuditUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ToolExecutionAuditCreateWithoutAgentInput, ToolExecutionAuditUncheckedCreateWithoutAgentInput> | ToolExecutionAuditCreateWithoutAgentInput[] | ToolExecutionAuditUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ToolExecutionAuditCreateOrConnectWithoutAgentInput | ToolExecutionAuditCreateOrConnectWithoutAgentInput[]
    createMany?: ToolExecutionAuditCreateManyAgentInputEnvelope
    connect?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<LeadCreateWithoutAgentInput, LeadUncheckedCreateWithoutAgentInput> | LeadCreateWithoutAgentInput[] | LeadUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAgentInput | LeadCreateOrConnectWithoutAgentInput[]
    createMany?: LeadCreateManyAgentInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<TenantCreateWithoutAgentsInput, TenantUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAgentsInput
    upsert?: TenantUpsertWithoutAgentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAgentsInput, TenantUpdateWithoutAgentsInput>, TenantUncheckedUpdateWithoutAgentsInput>
  }

  export type TranscriptUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TranscriptCreateWithoutAgentInput, TranscriptUncheckedCreateWithoutAgentInput> | TranscriptCreateWithoutAgentInput[] | TranscriptUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAgentInput | TranscriptCreateOrConnectWithoutAgentInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutAgentInput | TranscriptUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TranscriptCreateManyAgentInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutAgentInput | TranscriptUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutAgentInput | TranscriptUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type ToolExecutionAuditUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ToolExecutionAuditCreateWithoutAgentInput, ToolExecutionAuditUncheckedCreateWithoutAgentInput> | ToolExecutionAuditCreateWithoutAgentInput[] | ToolExecutionAuditUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ToolExecutionAuditCreateOrConnectWithoutAgentInput | ToolExecutionAuditCreateOrConnectWithoutAgentInput[]
    upsert?: ToolExecutionAuditUpsertWithWhereUniqueWithoutAgentInput | ToolExecutionAuditUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ToolExecutionAuditCreateManyAgentInputEnvelope
    set?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    disconnect?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    delete?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    connect?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    update?: ToolExecutionAuditUpdateWithWhereUniqueWithoutAgentInput | ToolExecutionAuditUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ToolExecutionAuditUpdateManyWithWhereWithoutAgentInput | ToolExecutionAuditUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ToolExecutionAuditScalarWhereInput | ToolExecutionAuditScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutAgentNestedInput = {
    create?: XOR<LeadCreateWithoutAgentInput, LeadUncheckedCreateWithoutAgentInput> | LeadCreateWithoutAgentInput[] | LeadUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAgentInput | LeadCreateOrConnectWithoutAgentInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAgentInput | LeadUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: LeadCreateManyAgentInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAgentInput | LeadUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAgentInput | LeadUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type TranscriptUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<TranscriptCreateWithoutAgentInput, TranscriptUncheckedCreateWithoutAgentInput> | TranscriptCreateWithoutAgentInput[] | TranscriptUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: TranscriptCreateOrConnectWithoutAgentInput | TranscriptCreateOrConnectWithoutAgentInput[]
    upsert?: TranscriptUpsertWithWhereUniqueWithoutAgentInput | TranscriptUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: TranscriptCreateManyAgentInputEnvelope
    set?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    disconnect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    delete?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    connect?: TranscriptWhereUniqueInput | TranscriptWhereUniqueInput[]
    update?: TranscriptUpdateWithWhereUniqueWithoutAgentInput | TranscriptUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: TranscriptUpdateManyWithWhereWithoutAgentInput | TranscriptUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
  }

  export type ToolExecutionAuditUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ToolExecutionAuditCreateWithoutAgentInput, ToolExecutionAuditUncheckedCreateWithoutAgentInput> | ToolExecutionAuditCreateWithoutAgentInput[] | ToolExecutionAuditUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ToolExecutionAuditCreateOrConnectWithoutAgentInput | ToolExecutionAuditCreateOrConnectWithoutAgentInput[]
    upsert?: ToolExecutionAuditUpsertWithWhereUniqueWithoutAgentInput | ToolExecutionAuditUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ToolExecutionAuditCreateManyAgentInputEnvelope
    set?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    disconnect?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    delete?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    connect?: ToolExecutionAuditWhereUniqueInput | ToolExecutionAuditWhereUniqueInput[]
    update?: ToolExecutionAuditUpdateWithWhereUniqueWithoutAgentInput | ToolExecutionAuditUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ToolExecutionAuditUpdateManyWithWhereWithoutAgentInput | ToolExecutionAuditUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ToolExecutionAuditScalarWhereInput | ToolExecutionAuditScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<LeadCreateWithoutAgentInput, LeadUncheckedCreateWithoutAgentInput> | LeadCreateWithoutAgentInput[] | LeadUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAgentInput | LeadCreateOrConnectWithoutAgentInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAgentInput | LeadUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: LeadCreateManyAgentInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAgentInput | LeadUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAgentInput | LeadUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<TenantCreateWithoutApiKeysInput, TenantUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: TenantCreateOrConnectWithoutApiKeysInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<TenantCreateWithoutApiKeysInput, TenantUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: TenantCreateOrConnectWithoutApiKeysInput
    upsert?: TenantUpsertWithoutApiKeysInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutApiKeysInput, TenantUpdateWithoutApiKeysInput>, TenantUncheckedUpdateWithoutApiKeysInput>
  }

  export type AgentCreateNestedOneWithoutTranscriptsInput = {
    create?: XOR<AgentCreateWithoutTranscriptsInput, AgentUncheckedCreateWithoutTranscriptsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTranscriptsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutTranscriptsNestedInput = {
    create?: XOR<AgentCreateWithoutTranscriptsInput, AgentUncheckedCreateWithoutTranscriptsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTranscriptsInput
    upsert?: AgentUpsertWithoutTranscriptsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTranscriptsInput, AgentUpdateWithoutTranscriptsInput>, AgentUncheckedUpdateWithoutTranscriptsInput>
  }

  export type UserCreateNestedOneWithoutReferralsCreatedInput = {
    create?: XOR<UserCreateWithoutReferralsCreatedInput, UserUncheckedCreateWithoutReferralsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferralsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutReferralsCreatedInput, UserUncheckedCreateWithoutReferralsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsCreatedInput
    upsert?: UserUpsertWithoutReferralsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsCreatedInput, UserUpdateWithoutReferralsCreatedInput>, UserUncheckedUpdateWithoutReferralsCreatedInput>
  }

  export type UserCreateNestedOneWithoutRewardsInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    upsert?: UserUpsertWithoutRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardsInput, UserUpdateWithoutRewardsInput>, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type AgentCreateNestedOneWithoutToolAuditsInput = {
    create?: XOR<AgentCreateWithoutToolAuditsInput, AgentUncheckedCreateWithoutToolAuditsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutToolAuditsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutToolAuditsNestedInput = {
    create?: XOR<AgentCreateWithoutToolAuditsInput, AgentUncheckedCreateWithoutToolAuditsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutToolAuditsInput
    upsert?: AgentUpsertWithoutToolAuditsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutToolAuditsInput, AgentUpdateWithoutToolAuditsInput>, AgentUncheckedUpdateWithoutToolAuditsInput>
  }

  export type TenantCreateNestedOneWithoutLeadsInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    connect?: TenantWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutLeadsInput = {
    create?: XOR<AgentCreateWithoutLeadsInput, AgentUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutLeadsInput
    connect?: AgentWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    upsert?: TenantUpsertWithoutLeadsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeadsInput, TenantUpdateWithoutLeadsInput>, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type AgentUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<AgentCreateWithoutLeadsInput, AgentUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutLeadsInput
    upsert?: AgentUpsertWithoutLeadsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutLeadsInput, AgentUpdateWithoutLeadsInput>, AgentUncheckedUpdateWithoutLeadsInput>
  }

  export type TenantCreateNestedOneWithoutGoogleConfigInput = {
    create?: XOR<TenantCreateWithoutGoogleConfigInput, TenantUncheckedCreateWithoutGoogleConfigInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGoogleConfigInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutGoogleConfigNestedInput = {
    create?: XOR<TenantCreateWithoutGoogleConfigInput, TenantUncheckedCreateWithoutGoogleConfigInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGoogleConfigInput
    upsert?: TenantUpsertWithoutGoogleConfigInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutGoogleConfigInput, TenantUpdateWithoutGoogleConfigInput>, TenantUncheckedUpdateWithoutGoogleConfigInput>
  }

  export type UserCreateNestedOneWithoutAffiliateInput = {
    create?: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput>
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateInput
    connect?: UserWhereUniqueInput
  }

  export type AffiliateReferralCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<AffiliateReferralCreateWithoutAffiliateInput, AffiliateReferralUncheckedCreateWithoutAffiliateInput> | AffiliateReferralCreateWithoutAffiliateInput[] | AffiliateReferralUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateReferralCreateOrConnectWithoutAffiliateInput | AffiliateReferralCreateOrConnectWithoutAffiliateInput[]
    createMany?: AffiliateReferralCreateManyAffiliateInputEnvelope
    connect?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
  }

  export type AffiliatePayoutCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<AffiliatePayoutCreateWithoutAffiliateInput, AffiliatePayoutUncheckedCreateWithoutAffiliateInput> | AffiliatePayoutCreateWithoutAffiliateInput[] | AffiliatePayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliatePayoutCreateOrConnectWithoutAffiliateInput | AffiliatePayoutCreateOrConnectWithoutAffiliateInput[]
    createMany?: AffiliatePayoutCreateManyAffiliateInputEnvelope
    connect?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
  }

  export type AffiliateReferralUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<AffiliateReferralCreateWithoutAffiliateInput, AffiliateReferralUncheckedCreateWithoutAffiliateInput> | AffiliateReferralCreateWithoutAffiliateInput[] | AffiliateReferralUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateReferralCreateOrConnectWithoutAffiliateInput | AffiliateReferralCreateOrConnectWithoutAffiliateInput[]
    createMany?: AffiliateReferralCreateManyAffiliateInputEnvelope
    connect?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
  }

  export type AffiliatePayoutUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<AffiliatePayoutCreateWithoutAffiliateInput, AffiliatePayoutUncheckedCreateWithoutAffiliateInput> | AffiliatePayoutCreateWithoutAffiliateInput[] | AffiliatePayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliatePayoutCreateOrConnectWithoutAffiliateInput | AffiliatePayoutCreateOrConnectWithoutAffiliateInput[]
    createMany?: AffiliatePayoutCreateManyAffiliateInputEnvelope
    connect?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
  }

  export type EnumAffiliateStatusFieldUpdateOperationsInput = {
    set?: $Enums.AffiliateStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAffiliateNestedInput = {
    create?: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput>
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateInput
    upsert?: UserUpsertWithoutAffiliateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAffiliateInput, UserUpdateWithoutAffiliateInput>, UserUncheckedUpdateWithoutAffiliateInput>
  }

  export type AffiliateReferralUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<AffiliateReferralCreateWithoutAffiliateInput, AffiliateReferralUncheckedCreateWithoutAffiliateInput> | AffiliateReferralCreateWithoutAffiliateInput[] | AffiliateReferralUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateReferralCreateOrConnectWithoutAffiliateInput | AffiliateReferralCreateOrConnectWithoutAffiliateInput[]
    upsert?: AffiliateReferralUpsertWithWhereUniqueWithoutAffiliateInput | AffiliateReferralUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: AffiliateReferralCreateManyAffiliateInputEnvelope
    set?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    disconnect?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    delete?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    connect?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    update?: AffiliateReferralUpdateWithWhereUniqueWithoutAffiliateInput | AffiliateReferralUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: AffiliateReferralUpdateManyWithWhereWithoutAffiliateInput | AffiliateReferralUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: AffiliateReferralScalarWhereInput | AffiliateReferralScalarWhereInput[]
  }

  export type AffiliatePayoutUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<AffiliatePayoutCreateWithoutAffiliateInput, AffiliatePayoutUncheckedCreateWithoutAffiliateInput> | AffiliatePayoutCreateWithoutAffiliateInput[] | AffiliatePayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliatePayoutCreateOrConnectWithoutAffiliateInput | AffiliatePayoutCreateOrConnectWithoutAffiliateInput[]
    upsert?: AffiliatePayoutUpsertWithWhereUniqueWithoutAffiliateInput | AffiliatePayoutUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: AffiliatePayoutCreateManyAffiliateInputEnvelope
    set?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    disconnect?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    delete?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    connect?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    update?: AffiliatePayoutUpdateWithWhereUniqueWithoutAffiliateInput | AffiliatePayoutUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: AffiliatePayoutUpdateManyWithWhereWithoutAffiliateInput | AffiliatePayoutUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: AffiliatePayoutScalarWhereInput | AffiliatePayoutScalarWhereInput[]
  }

  export type AffiliateReferralUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<AffiliateReferralCreateWithoutAffiliateInput, AffiliateReferralUncheckedCreateWithoutAffiliateInput> | AffiliateReferralCreateWithoutAffiliateInput[] | AffiliateReferralUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateReferralCreateOrConnectWithoutAffiliateInput | AffiliateReferralCreateOrConnectWithoutAffiliateInput[]
    upsert?: AffiliateReferralUpsertWithWhereUniqueWithoutAffiliateInput | AffiliateReferralUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: AffiliateReferralCreateManyAffiliateInputEnvelope
    set?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    disconnect?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    delete?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    connect?: AffiliateReferralWhereUniqueInput | AffiliateReferralWhereUniqueInput[]
    update?: AffiliateReferralUpdateWithWhereUniqueWithoutAffiliateInput | AffiliateReferralUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: AffiliateReferralUpdateManyWithWhereWithoutAffiliateInput | AffiliateReferralUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: AffiliateReferralScalarWhereInput | AffiliateReferralScalarWhereInput[]
  }

  export type AffiliatePayoutUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<AffiliatePayoutCreateWithoutAffiliateInput, AffiliatePayoutUncheckedCreateWithoutAffiliateInput> | AffiliatePayoutCreateWithoutAffiliateInput[] | AffiliatePayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliatePayoutCreateOrConnectWithoutAffiliateInput | AffiliatePayoutCreateOrConnectWithoutAffiliateInput[]
    upsert?: AffiliatePayoutUpsertWithWhereUniqueWithoutAffiliateInput | AffiliatePayoutUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: AffiliatePayoutCreateManyAffiliateInputEnvelope
    set?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    disconnect?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    delete?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    connect?: AffiliatePayoutWhereUniqueInput | AffiliatePayoutWhereUniqueInput[]
    update?: AffiliatePayoutUpdateWithWhereUniqueWithoutAffiliateInput | AffiliatePayoutUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: AffiliatePayoutUpdateManyWithWhereWithoutAffiliateInput | AffiliatePayoutUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: AffiliatePayoutScalarWhereInput | AffiliatePayoutScalarWhereInput[]
  }

  export type AffiliateCreateNestedOneWithoutReferralsInput = {
    create?: XOR<AffiliateCreateWithoutReferralsInput, AffiliateUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutReferralsInput
    connect?: AffiliateWhereUniqueInput
  }

  export type EnumAffiliateReferralStatusFieldUpdateOperationsInput = {
    set?: $Enums.AffiliateReferralStatus
  }

  export type AffiliateUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<AffiliateCreateWithoutReferralsInput, AffiliateUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutReferralsInput
    upsert?: AffiliateUpsertWithoutReferralsInput
    connect?: AffiliateWhereUniqueInput
    update?: XOR<XOR<AffiliateUpdateToOneWithWhereWithoutReferralsInput, AffiliateUpdateWithoutReferralsInput>, AffiliateUncheckedUpdateWithoutReferralsInput>
  }

  export type AffiliateCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<AffiliateCreateWithoutPayoutsInput, AffiliateUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutPayoutsInput
    connect?: AffiliateWhereUniqueInput
  }

  export type EnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayoutStatus
  }

  export type AffiliateUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<AffiliateCreateWithoutPayoutsInput, AffiliateUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutPayoutsInput
    upsert?: AffiliateUpsertWithoutPayoutsInput
    connect?: AffiliateWhereUniqueInput
    update?: XOR<XOR<AffiliateUpdateToOneWithWhereWithoutPayoutsInput, AffiliateUpdateWithoutPayoutsInput>, AffiliateUncheckedUpdateWithoutPayoutsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumCommissionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionLevel | EnumCommissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionLevelFilter<$PrismaModel> | $Enums.CommissionLevel
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumCommissionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionLevel | EnumCommissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionLevel[] | ListEnumCommissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionLevelWithAggregatesFilter<$PrismaModel> | $Enums.CommissionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionLevelFilter<$PrismaModel>
    _max?: NestedEnumCommissionLevelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAffiliateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatus | EnumAffiliateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusFilter<$PrismaModel> | $Enums.AffiliateStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAffiliateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatus | EnumAffiliateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatus[] | ListEnumAffiliateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateStatusFilter<$PrismaModel>
    _max?: NestedEnumAffiliateStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAffiliateReferralStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateReferralStatus | EnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateReferralStatusFilter<$PrismaModel> | $Enums.AffiliateReferralStatus
  }

  export type NestedEnumAffiliateReferralStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateReferralStatus | EnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateReferralStatus[] | ListEnumAffiliateReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateReferralStatusWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateReferralStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateReferralStatusFilter<$PrismaModel>
    _max?: NestedEnumAffiliateReferralStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    referralsCreated?: ReferralCreateNestedManyWithoutReferrerInput
    affiliate?: AffiliateCreateNestedOneWithoutUserInput
    rewards?: RewardTransactionCreateNestedManyWithoutReferrerInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    referralsCreated?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    affiliate?: AffiliateUncheckedCreateNestedOneWithoutUserInput
    rewards?: RewardTransactionUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutTenantInput = {
    id?: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transcripts?: TranscriptCreateNestedManyWithoutAgentInput
    toolAudits?: ToolExecutionAuditCreateNestedManyWithoutAgentInput
    leads?: LeadCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutAgentInput
    toolAudits?: ToolExecutionAuditUncheckedCreateNestedManyWithoutAgentInput
    leads?: LeadUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTenantInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTenantInput, AgentUncheckedCreateWithoutTenantInput>
  }

  export type AgentCreateManyTenantInputEnvelope = {
    data: AgentCreateManyTenantInput | AgentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutTenantInput = {
    id?: string
    key: string
    name: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ApiKeyUncheckedCreateWithoutTenantInput = {
    id?: string
    key: string
    name: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ApiKeyCreateOrConnectWithoutTenantInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutTenantInput, ApiKeyUncheckedCreateWithoutTenantInput>
  }

  export type ApiKeyCreateManyTenantInputEnvelope = {
    data: ApiKeyCreateManyTenantInput | ApiKeyCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutTenantInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutTenantInput = {
    id?: string
    agentId: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateOrConnectWithoutTenantInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadCreateManyTenantInputEnvelope = {
    data: LeadCreateManyTenantInput | LeadCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantGoogleConfigCreateWithoutTenantInput = {
    id?: string
    clientId: string
    clientSecret: string
    geminiApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantGoogleConfigUncheckedCreateWithoutTenantInput = {
    id?: string
    clientId: string
    clientSecret: string
    geminiApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantGoogleConfigCreateOrConnectWithoutTenantInput = {
    where: TenantGoogleConfigWhereUniqueInput
    create: XOR<TenantGoogleConfigCreateWithoutTenantInput, TenantGoogleConfigUncheckedCreateWithoutTenantInput>
  }

  export type TenantTwilioConfigCreateWithoutTenantInput = {
    id?: string
    accountSid: string
    authToken: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantTwilioConfigUncheckedCreateWithoutTenantInput = {
    id?: string
    accountSid: string
    authToken: string
    phoneNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantTwilioConfigCreateOrConnectWithoutTenantInput = {
    where: TenantTwilioConfigWhereUniqueInput
    create: XOR<TenantTwilioConfigCreateWithoutTenantInput, TenantTwilioConfigUncheckedCreateWithoutTenantInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isBlocked?: BoolFilter<"User"> | boolean
    avatar?: StringNullableFilter<"User"> | string | null
    commissionLevel?: EnumCommissionLevelFilter<"User"> | $Enums.CommissionLevel
    googleId?: StringNullableFilter<"User"> | string | null
    googleEmail?: StringNullableFilter<"User"> | string | null
    googleName?: StringNullableFilter<"User"> | string | null
    googleProfilePicture?: StringNullableFilter<"User"> | string | null
    googleAuthProvider?: StringNullableFilter<"User"> | string | null
    referralCodeUsed?: StringNullableFilter<"User"> | string | null
    referralRewardTotal?: FloatFilter<"User"> | number
    isAffiliate?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    businessName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    unit?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    tinSsn?: StringNullableFilter<"User"> | string | null
    taxFormUrl?: StringNullableFilter<"User"> | string | null
  }

  export type AgentUpsertWithWhereUniqueWithoutTenantInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutTenantInput, AgentUncheckedUpdateWithoutTenantInput>
    create: XOR<AgentCreateWithoutTenantInput, AgentUncheckedCreateWithoutTenantInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutTenantInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutTenantInput, AgentUncheckedUpdateWithoutTenantInput>
  }

  export type AgentUpdateManyWithWhereWithoutTenantInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutTenantInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    tenantId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    systemPrompt?: StringFilter<"Agent"> | string
    voiceId?: StringFilter<"Agent"> | string
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutTenantInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutTenantInput, ApiKeyUncheckedUpdateWithoutTenantInput>
    create: XOR<ApiKeyCreateWithoutTenantInput, ApiKeyUncheckedCreateWithoutTenantInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutTenantInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutTenantInput, ApiKeyUncheckedUpdateWithoutTenantInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutTenantInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutTenantInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    tenantId?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
  }

  export type LeadUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
  }

  export type LeadUpdateManyWithWhereWithoutTenantInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutTenantInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    agentId?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    summary?: StringNullableFilter<"Lead"> | string | null
    isBooked?: BoolFilter<"Lead"> | boolean
    metadata?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type TenantGoogleConfigUpsertWithoutTenantInput = {
    update: XOR<TenantGoogleConfigUpdateWithoutTenantInput, TenantGoogleConfigUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantGoogleConfigCreateWithoutTenantInput, TenantGoogleConfigUncheckedCreateWithoutTenantInput>
    where?: TenantGoogleConfigWhereInput
  }

  export type TenantGoogleConfigUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantGoogleConfigWhereInput
    data: XOR<TenantGoogleConfigUpdateWithoutTenantInput, TenantGoogleConfigUncheckedUpdateWithoutTenantInput>
  }

  export type TenantGoogleConfigUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantGoogleConfigUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    geminiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantTwilioConfigUpsertWithoutTenantInput = {
    update: XOR<TenantTwilioConfigUpdateWithoutTenantInput, TenantTwilioConfigUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantTwilioConfigCreateWithoutTenantInput, TenantTwilioConfigUncheckedCreateWithoutTenantInput>
    where?: TenantTwilioConfigWhereInput
  }

  export type TenantTwilioConfigUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantTwilioConfigWhereInput
    data: XOR<TenantTwilioConfigUpdateWithoutTenantInput, TenantTwilioConfigUncheckedUpdateWithoutTenantInput>
  }

  export type TenantTwilioConfigUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountSid?: StringFieldUpdateOperationsInput | string
    authToken?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantTwilioConfigUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountSid?: StringFieldUpdateOperationsInput | string
    authToken?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutTwilioConfigInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    agents?: AgentCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTwilioConfigInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    agents?: AgentUncheckedCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTwilioConfigInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTwilioConfigInput, TenantUncheckedCreateWithoutTwilioConfigInput>
  }

  export type TenantUpsertWithoutTwilioConfigInput = {
    update: XOR<TenantUpdateWithoutTwilioConfigInput, TenantUncheckedUpdateWithoutTwilioConfigInput>
    create: XOR<TenantCreateWithoutTwilioConfigInput, TenantUncheckedCreateWithoutTwilioConfigInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTwilioConfigInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTwilioConfigInput, TenantUncheckedUpdateWithoutTwilioConfigInput>
  }

  export type TenantUpdateWithoutTwilioConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    agents?: AgentUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTwilioConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    agents?: AgentUncheckedUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigUncheckedCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    refereeId?: string | null
    code: string
    status?: string
    rewardAmount?: number
    rewardCurrency?: string
    expiresAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    refereeId?: string | null
    code: string
    status?: string
    rewardAmount?: number
    rewardCurrency?: string
    expiresAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referrals?: AffiliateReferralCreateNestedManyWithoutAffiliateInput
    payouts?: AffiliatePayoutCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referrals?: AffiliateReferralUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: AffiliatePayoutUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateCreateOrConnectWithoutUserInput = {
    where: AffiliateWhereUniqueInput
    create: XOR<AffiliateCreateWithoutUserInput, AffiliateUncheckedCreateWithoutUserInput>
  }

  export type RewardTransactionCreateWithoutReferrerInput = {
    id?: string
    refereeId?: string | null
    amount: number
    status?: string
    sourcePaymentId?: string | null
    holdEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardTransactionUncheckedCreateWithoutReferrerInput = {
    id?: string
    refereeId?: string | null
    amount: number
    status?: string
    sourcePaymentId?: string | null
    holdEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardTransactionCreateOrConnectWithoutReferrerInput = {
    where: RewardTransactionWhereUniqueInput
    create: XOR<RewardTransactionCreateWithoutReferrerInput, RewardTransactionUncheckedCreateWithoutReferrerInput>
  }

  export type RewardTransactionCreateManyReferrerInputEnvelope = {
    data: RewardTransactionCreateManyReferrerInput | RewardTransactionCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUncheckedUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringNullableFilter<"Referral"> | string | null
    code?: StringFilter<"Referral"> | string
    status?: StringFilter<"Referral"> | string
    rewardAmount?: FloatFilter<"Referral"> | number
    rewardCurrency?: StringFilter<"Referral"> | string
    expiresAt?: DateTimeFilter<"Referral"> | Date | string
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type AffiliateUpsertWithoutUserInput = {
    update: XOR<AffiliateUpdateWithoutUserInput, AffiliateUncheckedUpdateWithoutUserInput>
    create: XOR<AffiliateCreateWithoutUserInput, AffiliateUncheckedCreateWithoutUserInput>
    where?: AffiliateWhereInput
  }

  export type AffiliateUpdateToOneWithWhereWithoutUserInput = {
    where?: AffiliateWhereInput
    data: XOR<AffiliateUpdateWithoutUserInput, AffiliateUncheckedUpdateWithoutUserInput>
  }

  export type AffiliateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: AffiliateReferralUpdateManyWithoutAffiliateNestedInput
    payouts?: AffiliatePayoutUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: AffiliateReferralUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: AffiliatePayoutUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type RewardTransactionUpsertWithWhereUniqueWithoutReferrerInput = {
    where: RewardTransactionWhereUniqueInput
    update: XOR<RewardTransactionUpdateWithoutReferrerInput, RewardTransactionUncheckedUpdateWithoutReferrerInput>
    create: XOR<RewardTransactionCreateWithoutReferrerInput, RewardTransactionUncheckedCreateWithoutReferrerInput>
  }

  export type RewardTransactionUpdateWithWhereUniqueWithoutReferrerInput = {
    where: RewardTransactionWhereUniqueInput
    data: XOR<RewardTransactionUpdateWithoutReferrerInput, RewardTransactionUncheckedUpdateWithoutReferrerInput>
  }

  export type RewardTransactionUpdateManyWithWhereWithoutReferrerInput = {
    where: RewardTransactionScalarWhereInput
    data: XOR<RewardTransactionUpdateManyMutationInput, RewardTransactionUncheckedUpdateManyWithoutReferrerInput>
  }

  export type RewardTransactionScalarWhereInput = {
    AND?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
    OR?: RewardTransactionScalarWhereInput[]
    NOT?: RewardTransactionScalarWhereInput | RewardTransactionScalarWhereInput[]
    id?: StringFilter<"RewardTransaction"> | string
    referrerId?: StringFilter<"RewardTransaction"> | string
    refereeId?: StringNullableFilter<"RewardTransaction"> | string | null
    amount?: FloatFilter<"RewardTransaction"> | number
    status?: StringFilter<"RewardTransaction"> | string
    sourcePaymentId?: StringNullableFilter<"RewardTransaction"> | string | null
    holdEndsAt?: DateTimeNullableFilter<"RewardTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"RewardTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"RewardTransaction"> | Date | string
  }

  export type TenantCreateWithoutAgentsInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAgentsInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigUncheckedCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAgentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAgentsInput, TenantUncheckedCreateWithoutAgentsInput>
  }

  export type TranscriptCreateWithoutAgentInput = {
    id?: string
    userId?: string | null
    content: string
    duration?: number
    createdAt?: Date | string
  }

  export type TranscriptUncheckedCreateWithoutAgentInput = {
    id?: string
    userId?: string | null
    content: string
    duration?: number
    createdAt?: Date | string
  }

  export type TranscriptCreateOrConnectWithoutAgentInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutAgentInput, TranscriptUncheckedCreateWithoutAgentInput>
  }

  export type TranscriptCreateManyAgentInputEnvelope = {
    data: TranscriptCreateManyAgentInput | TranscriptCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ToolExecutionAuditCreateWithoutAgentInput = {
    id?: string
    userId?: string | null
    toolName: string
    toolInput: string
    toolOutput?: string | null
    status?: string
    errorMessage?: string | null
    executionTimeMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ToolExecutionAuditUncheckedCreateWithoutAgentInput = {
    id?: string
    userId?: string | null
    toolName: string
    toolInput: string
    toolOutput?: string | null
    status?: string
    errorMessage?: string | null
    executionTimeMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ToolExecutionAuditCreateOrConnectWithoutAgentInput = {
    where: ToolExecutionAuditWhereUniqueInput
    create: XOR<ToolExecutionAuditCreateWithoutAgentInput, ToolExecutionAuditUncheckedCreateWithoutAgentInput>
  }

  export type ToolExecutionAuditCreateManyAgentInputEnvelope = {
    data: ToolExecutionAuditCreateManyAgentInput | ToolExecutionAuditCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutAgentInput = {
    id?: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutAgentInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateOrConnectWithoutAgentInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutAgentInput, LeadUncheckedCreateWithoutAgentInput>
  }

  export type LeadCreateManyAgentInputEnvelope = {
    data: LeadCreateManyAgentInput | LeadCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAgentsInput = {
    update: XOR<TenantUpdateWithoutAgentsInput, TenantUncheckedUpdateWithoutAgentsInput>
    create: XOR<TenantCreateWithoutAgentsInput, TenantUncheckedCreateWithoutAgentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAgentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAgentsInput, TenantUncheckedUpdateWithoutAgentsInput>
  }

  export type TenantUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUncheckedUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type TranscriptUpsertWithWhereUniqueWithoutAgentInput = {
    where: TranscriptWhereUniqueInput
    update: XOR<TranscriptUpdateWithoutAgentInput, TranscriptUncheckedUpdateWithoutAgentInput>
    create: XOR<TranscriptCreateWithoutAgentInput, TranscriptUncheckedCreateWithoutAgentInput>
  }

  export type TranscriptUpdateWithWhereUniqueWithoutAgentInput = {
    where: TranscriptWhereUniqueInput
    data: XOR<TranscriptUpdateWithoutAgentInput, TranscriptUncheckedUpdateWithoutAgentInput>
  }

  export type TranscriptUpdateManyWithWhereWithoutAgentInput = {
    where: TranscriptScalarWhereInput
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyWithoutAgentInput>
  }

  export type TranscriptScalarWhereInput = {
    AND?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    OR?: TranscriptScalarWhereInput[]
    NOT?: TranscriptScalarWhereInput | TranscriptScalarWhereInput[]
    id?: StringFilter<"Transcript"> | string
    agentId?: StringFilter<"Transcript"> | string
    userId?: StringNullableFilter<"Transcript"> | string | null
    content?: StringFilter<"Transcript"> | string
    duration?: IntFilter<"Transcript"> | number
    createdAt?: DateTimeFilter<"Transcript"> | Date | string
  }

  export type ToolExecutionAuditUpsertWithWhereUniqueWithoutAgentInput = {
    where: ToolExecutionAuditWhereUniqueInput
    update: XOR<ToolExecutionAuditUpdateWithoutAgentInput, ToolExecutionAuditUncheckedUpdateWithoutAgentInput>
    create: XOR<ToolExecutionAuditCreateWithoutAgentInput, ToolExecutionAuditUncheckedCreateWithoutAgentInput>
  }

  export type ToolExecutionAuditUpdateWithWhereUniqueWithoutAgentInput = {
    where: ToolExecutionAuditWhereUniqueInput
    data: XOR<ToolExecutionAuditUpdateWithoutAgentInput, ToolExecutionAuditUncheckedUpdateWithoutAgentInput>
  }

  export type ToolExecutionAuditUpdateManyWithWhereWithoutAgentInput = {
    where: ToolExecutionAuditScalarWhereInput
    data: XOR<ToolExecutionAuditUpdateManyMutationInput, ToolExecutionAuditUncheckedUpdateManyWithoutAgentInput>
  }

  export type ToolExecutionAuditScalarWhereInput = {
    AND?: ToolExecutionAuditScalarWhereInput | ToolExecutionAuditScalarWhereInput[]
    OR?: ToolExecutionAuditScalarWhereInput[]
    NOT?: ToolExecutionAuditScalarWhereInput | ToolExecutionAuditScalarWhereInput[]
    id?: StringFilter<"ToolExecutionAudit"> | string
    agentId?: StringFilter<"ToolExecutionAudit"> | string
    userId?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    toolName?: StringFilter<"ToolExecutionAudit"> | string
    toolInput?: StringFilter<"ToolExecutionAudit"> | string
    toolOutput?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    status?: StringFilter<"ToolExecutionAudit"> | string
    errorMessage?: StringNullableFilter<"ToolExecutionAudit"> | string | null
    executionTimeMs?: IntFilter<"ToolExecutionAudit"> | number
    createdAt?: DateTimeFilter<"ToolExecutionAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ToolExecutionAudit"> | Date | string
  }

  export type LeadUpsertWithWhereUniqueWithoutAgentInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutAgentInput, LeadUncheckedUpdateWithoutAgentInput>
    create: XOR<LeadCreateWithoutAgentInput, LeadUncheckedCreateWithoutAgentInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutAgentInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutAgentInput, LeadUncheckedUpdateWithoutAgentInput>
  }

  export type LeadUpdateManyWithWhereWithoutAgentInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutAgentInput>
  }

  export type TenantCreateWithoutApiKeysInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    agents?: AgentCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutApiKeysInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    agents?: AgentUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigUncheckedCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutApiKeysInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutApiKeysInput, TenantUncheckedCreateWithoutApiKeysInput>
  }

  export type TenantUpsertWithoutApiKeysInput = {
    update: XOR<TenantUpdateWithoutApiKeysInput, TenantUncheckedUpdateWithoutApiKeysInput>
    create: XOR<TenantCreateWithoutApiKeysInput, TenantUncheckedCreateWithoutApiKeysInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutApiKeysInput, TenantUncheckedUpdateWithoutApiKeysInput>
  }

  export type TenantUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    agents?: AgentUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    agents?: AgentUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUncheckedUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type AgentCreateWithoutTranscriptsInput = {
    id?: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAgentsInput
    toolAudits?: ToolExecutionAuditCreateNestedManyWithoutAgentInput
    leads?: LeadCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTranscriptsInput = {
    id?: string
    tenantId: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    toolAudits?: ToolExecutionAuditUncheckedCreateNestedManyWithoutAgentInput
    leads?: LeadUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTranscriptsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTranscriptsInput, AgentUncheckedCreateWithoutTranscriptsInput>
  }

  export type AgentUpsertWithoutTranscriptsInput = {
    update: XOR<AgentUpdateWithoutTranscriptsInput, AgentUncheckedUpdateWithoutTranscriptsInput>
    create: XOR<AgentCreateWithoutTranscriptsInput, AgentUncheckedCreateWithoutTranscriptsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTranscriptsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTranscriptsInput, AgentUncheckedUpdateWithoutTranscriptsInput>
  }

  export type AgentUpdateWithoutTranscriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgentsNestedInput
    toolAudits?: ToolExecutionAuditUpdateManyWithoutAgentNestedInput
    leads?: LeadUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTranscriptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toolAudits?: ToolExecutionAuditUncheckedUpdateManyWithoutAgentNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutReferralsCreatedInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    affiliate?: AffiliateCreateNestedOneWithoutUserInput
    rewards?: RewardTransactionCreateNestedManyWithoutReferrerInput
  }

  export type UserUncheckedCreateWithoutReferralsCreatedInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    affiliate?: AffiliateUncheckedCreateNestedOneWithoutUserInput
    rewards?: RewardTransactionUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type UserCreateOrConnectWithoutReferralsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsCreatedInput, UserUncheckedCreateWithoutReferralsCreatedInput>
  }

  export type UserUpsertWithoutReferralsCreatedInput = {
    update: XOR<UserUpdateWithoutReferralsCreatedInput, UserUncheckedUpdateWithoutReferralsCreatedInput>
    create: XOR<UserCreateWithoutReferralsCreatedInput, UserUncheckedCreateWithoutReferralsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsCreatedInput, UserUncheckedUpdateWithoutReferralsCreatedInput>
  }

  export type UserUpdateWithoutReferralsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    affiliate?: AffiliateUpdateOneWithoutUserNestedInput
    rewards?: RewardTransactionUpdateManyWithoutReferrerNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: AffiliateUncheckedUpdateOneWithoutUserNestedInput
    rewards?: RewardTransactionUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type UserCreateWithoutRewardsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    referralsCreated?: ReferralCreateNestedManyWithoutReferrerInput
    affiliate?: AffiliateCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRewardsInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    referralsCreated?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    affiliate?: AffiliateUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
  }

  export type UserUpsertWithoutRewardsInput = {
    update: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type UserUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    referralsCreated?: ReferralUpdateManyWithoutReferrerNestedInput
    affiliate?: AffiliateUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    referralsCreated?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    affiliate?: AffiliateUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AgentCreateWithoutToolAuditsInput = {
    id?: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAgentsInput
    transcripts?: TranscriptCreateNestedManyWithoutAgentInput
    leads?: LeadCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutToolAuditsInput = {
    id?: string
    tenantId: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutAgentInput
    leads?: LeadUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutToolAuditsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutToolAuditsInput, AgentUncheckedCreateWithoutToolAuditsInput>
  }

  export type AgentUpsertWithoutToolAuditsInput = {
    update: XOR<AgentUpdateWithoutToolAuditsInput, AgentUncheckedUpdateWithoutToolAuditsInput>
    create: XOR<AgentCreateWithoutToolAuditsInput, AgentUncheckedCreateWithoutToolAuditsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutToolAuditsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutToolAuditsInput, AgentUncheckedUpdateWithoutToolAuditsInput>
  }

  export type AgentUpdateWithoutToolAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgentsNestedInput
    transcripts?: TranscriptUpdateManyWithoutAgentNestedInput
    leads?: LeadUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutToolAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcripts?: TranscriptUncheckedUpdateManyWithoutAgentNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type TenantCreateWithoutLeadsInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    agents?: AgentCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    agents?: AgentUncheckedCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTenantInput
    googleConfig?: TenantGoogleConfigUncheckedCreateNestedOneWithoutTenantInput
    twilioConfig?: TenantTwilioConfigUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLeadsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
  }

  export type AgentCreateWithoutLeadsInput = {
    id?: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAgentsInput
    transcripts?: TranscriptCreateNestedManyWithoutAgentInput
    toolAudits?: ToolExecutionAuditCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutLeadsInput = {
    id?: string
    tenantId: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transcripts?: TranscriptUncheckedCreateNestedManyWithoutAgentInput
    toolAudits?: ToolExecutionAuditUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutLeadsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutLeadsInput, AgentUncheckedCreateWithoutLeadsInput>
  }

  export type TenantUpsertWithoutLeadsInput = {
    update: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeadsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type TenantUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    agents?: AgentUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    agents?: AgentUncheckedUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTenantNestedInput
    googleConfig?: TenantGoogleConfigUncheckedUpdateOneWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type AgentUpsertWithoutLeadsInput = {
    update: XOR<AgentUpdateWithoutLeadsInput, AgentUncheckedUpdateWithoutLeadsInput>
    create: XOR<AgentCreateWithoutLeadsInput, AgentUncheckedCreateWithoutLeadsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutLeadsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutLeadsInput, AgentUncheckedUpdateWithoutLeadsInput>
  }

  export type AgentUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgentsNestedInput
    transcripts?: TranscriptUpdateManyWithoutAgentNestedInput
    toolAudits?: ToolExecutionAuditUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcripts?: TranscriptUncheckedUpdateManyWithoutAgentNestedInput
    toolAudits?: ToolExecutionAuditUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type TenantCreateWithoutGoogleConfigInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    agents?: AgentCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    twilioConfig?: TenantTwilioConfigCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutGoogleConfigInput = {
    id?: string
    name: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    subscriptionStatus?: string | null
    subscriptionTier?: string
    subscriptionEnds?: Date | string | null
    usageLimit?: number
    usageCount?: number
    usageResetAt?: Date | string
    billingEmail?: string | null
    creditBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    agents?: AgentUncheckedCreateNestedManyWithoutTenantInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    twilioConfig?: TenantTwilioConfigUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutGoogleConfigInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutGoogleConfigInput, TenantUncheckedCreateWithoutGoogleConfigInput>
  }

  export type TenantUpsertWithoutGoogleConfigInput = {
    update: XOR<TenantUpdateWithoutGoogleConfigInput, TenantUncheckedUpdateWithoutGoogleConfigInput>
    create: XOR<TenantCreateWithoutGoogleConfigInput, TenantUncheckedCreateWithoutGoogleConfigInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutGoogleConfigInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutGoogleConfigInput, TenantUncheckedUpdateWithoutGoogleConfigInput>
  }

  export type TenantUpdateWithoutGoogleConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    agents?: AgentUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutGoogleConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: IntFieldUpdateOperationsInput | number
    usageCount?: IntFieldUpdateOperationsInput | number
    usageResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    creditBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    agents?: AgentUncheckedUpdateManyWithoutTenantNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    twilioConfig?: TenantTwilioConfigUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type UserCreateWithoutAffiliateInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    referralsCreated?: ReferralCreateNestedManyWithoutReferrerInput
    rewards?: RewardTransactionCreateNestedManyWithoutReferrerInput
  }

  export type UserUncheckedCreateWithoutAffiliateInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
    referralsCreated?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    rewards?: RewardTransactionUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type UserCreateOrConnectWithoutAffiliateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput>
  }

  export type AffiliateReferralCreateWithoutAffiliateInput = {
    id?: string
    refereeId?: string | null
    status?: $Enums.AffiliateReferralStatus
    commissionAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateReferralUncheckedCreateWithoutAffiliateInput = {
    id?: string
    refereeId?: string | null
    status?: $Enums.AffiliateReferralStatus
    commissionAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateReferralCreateOrConnectWithoutAffiliateInput = {
    where: AffiliateReferralWhereUniqueInput
    create: XOR<AffiliateReferralCreateWithoutAffiliateInput, AffiliateReferralUncheckedCreateWithoutAffiliateInput>
  }

  export type AffiliateReferralCreateManyAffiliateInputEnvelope = {
    data: AffiliateReferralCreateManyAffiliateInput | AffiliateReferralCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type AffiliatePayoutCreateWithoutAffiliateInput = {
    id?: string
    amount: number
    feeAmount?: number
    netAmount?: number
    status?: $Enums.PayoutStatus
    method?: string
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliatePayoutUncheckedCreateWithoutAffiliateInput = {
    id?: string
    amount: number
    feeAmount?: number
    netAmount?: number
    status?: $Enums.PayoutStatus
    method?: string
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliatePayoutCreateOrConnectWithoutAffiliateInput = {
    where: AffiliatePayoutWhereUniqueInput
    create: XOR<AffiliatePayoutCreateWithoutAffiliateInput, AffiliatePayoutUncheckedCreateWithoutAffiliateInput>
  }

  export type AffiliatePayoutCreateManyAffiliateInputEnvelope = {
    data: AffiliatePayoutCreateManyAffiliateInput | AffiliatePayoutCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAffiliateInput = {
    update: XOR<UserUpdateWithoutAffiliateInput, UserUncheckedUpdateWithoutAffiliateInput>
    create: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAffiliateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAffiliateInput, UserUncheckedUpdateWithoutAffiliateInput>
  }

  export type UserUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    referralsCreated?: ReferralUpdateManyWithoutReferrerNestedInput
    rewards?: RewardTransactionUpdateManyWithoutReferrerNestedInput
  }

  export type UserUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    referralsCreated?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    rewards?: RewardTransactionUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type AffiliateReferralUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: AffiliateReferralWhereUniqueInput
    update: XOR<AffiliateReferralUpdateWithoutAffiliateInput, AffiliateReferralUncheckedUpdateWithoutAffiliateInput>
    create: XOR<AffiliateReferralCreateWithoutAffiliateInput, AffiliateReferralUncheckedCreateWithoutAffiliateInput>
  }

  export type AffiliateReferralUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: AffiliateReferralWhereUniqueInput
    data: XOR<AffiliateReferralUpdateWithoutAffiliateInput, AffiliateReferralUncheckedUpdateWithoutAffiliateInput>
  }

  export type AffiliateReferralUpdateManyWithWhereWithoutAffiliateInput = {
    where: AffiliateReferralScalarWhereInput
    data: XOR<AffiliateReferralUpdateManyMutationInput, AffiliateReferralUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type AffiliateReferralScalarWhereInput = {
    AND?: AffiliateReferralScalarWhereInput | AffiliateReferralScalarWhereInput[]
    OR?: AffiliateReferralScalarWhereInput[]
    NOT?: AffiliateReferralScalarWhereInput | AffiliateReferralScalarWhereInput[]
    id?: StringFilter<"AffiliateReferral"> | string
    affiliateId?: StringFilter<"AffiliateReferral"> | string
    refereeId?: StringNullableFilter<"AffiliateReferral"> | string | null
    status?: EnumAffiliateReferralStatusFilter<"AffiliateReferral"> | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFilter<"AffiliateReferral"> | number
    createdAt?: DateTimeFilter<"AffiliateReferral"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateReferral"> | Date | string
  }

  export type AffiliatePayoutUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: AffiliatePayoutWhereUniqueInput
    update: XOR<AffiliatePayoutUpdateWithoutAffiliateInput, AffiliatePayoutUncheckedUpdateWithoutAffiliateInput>
    create: XOR<AffiliatePayoutCreateWithoutAffiliateInput, AffiliatePayoutUncheckedCreateWithoutAffiliateInput>
  }

  export type AffiliatePayoutUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: AffiliatePayoutWhereUniqueInput
    data: XOR<AffiliatePayoutUpdateWithoutAffiliateInput, AffiliatePayoutUncheckedUpdateWithoutAffiliateInput>
  }

  export type AffiliatePayoutUpdateManyWithWhereWithoutAffiliateInput = {
    where: AffiliatePayoutScalarWhereInput
    data: XOR<AffiliatePayoutUpdateManyMutationInput, AffiliatePayoutUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type AffiliatePayoutScalarWhereInput = {
    AND?: AffiliatePayoutScalarWhereInput | AffiliatePayoutScalarWhereInput[]
    OR?: AffiliatePayoutScalarWhereInput[]
    NOT?: AffiliatePayoutScalarWhereInput | AffiliatePayoutScalarWhereInput[]
    id?: StringFilter<"AffiliatePayout"> | string
    affiliateId?: StringFilter<"AffiliatePayout"> | string
    amount?: FloatFilter<"AffiliatePayout"> | number
    feeAmount?: FloatFilter<"AffiliatePayout"> | number
    netAmount?: FloatFilter<"AffiliatePayout"> | number
    status?: EnumPayoutStatusFilter<"AffiliatePayout"> | $Enums.PayoutStatus
    method?: StringFilter<"AffiliatePayout"> | string
    transactionId?: StringNullableFilter<"AffiliatePayout"> | string | null
    createdAt?: DateTimeFilter<"AffiliatePayout"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliatePayout"> | Date | string
  }

  export type AffiliateCreateWithoutReferralsInput = {
    id?: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateInput
    payouts?: AffiliatePayoutCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateUncheckedCreateWithoutReferralsInput = {
    id?: string
    userId: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payouts?: AffiliatePayoutUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateCreateOrConnectWithoutReferralsInput = {
    where: AffiliateWhereUniqueInput
    create: XOR<AffiliateCreateWithoutReferralsInput, AffiliateUncheckedCreateWithoutReferralsInput>
  }

  export type AffiliateUpsertWithoutReferralsInput = {
    update: XOR<AffiliateUpdateWithoutReferralsInput, AffiliateUncheckedUpdateWithoutReferralsInput>
    create: XOR<AffiliateCreateWithoutReferralsInput, AffiliateUncheckedCreateWithoutReferralsInput>
    where?: AffiliateWhereInput
  }

  export type AffiliateUpdateToOneWithWhereWithoutReferralsInput = {
    where?: AffiliateWhereInput
    data: XOR<AffiliateUpdateWithoutReferralsInput, AffiliateUncheckedUpdateWithoutReferralsInput>
  }

  export type AffiliateUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateNestedInput
    payouts?: AffiliatePayoutUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: AffiliatePayoutUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateCreateWithoutPayoutsInput = {
    id?: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateInput
    referrals?: AffiliateReferralCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateUncheckedCreateWithoutPayoutsInput = {
    id?: string
    userId: string
    status?: $Enums.AffiliateStatus
    slug: string
    paymentInfo?: string | null
    payoutMethod?: string | null
    payoutEmail?: string | null
    payoutPhone?: string | null
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    taxFormCompleted?: boolean
    tax1099Uploaded?: boolean
    lastPayoutAt?: Date | string | null
    lockedCommissionRate?: number | null
    customCommissionRate?: number | null
    totalEarnings?: number
    totalPaid?: number
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    referrals?: AffiliateReferralUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateCreateOrConnectWithoutPayoutsInput = {
    where: AffiliateWhereUniqueInput
    create: XOR<AffiliateCreateWithoutPayoutsInput, AffiliateUncheckedCreateWithoutPayoutsInput>
  }

  export type AffiliateUpsertWithoutPayoutsInput = {
    update: XOR<AffiliateUpdateWithoutPayoutsInput, AffiliateUncheckedUpdateWithoutPayoutsInput>
    create: XOR<AffiliateCreateWithoutPayoutsInput, AffiliateUncheckedCreateWithoutPayoutsInput>
    where?: AffiliateWhereInput
  }

  export type AffiliateUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: AffiliateWhereInput
    data: XOR<AffiliateUpdateWithoutPayoutsInput, AffiliateUncheckedUpdateWithoutPayoutsInput>
  }

  export type AffiliateUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateNestedInput
    referrals?: AffiliateReferralUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusFieldUpdateOperationsInput | $Enums.AffiliateStatus
    slug?: StringFieldUpdateOperationsInput | string
    paymentInfo?: NullableStringFieldUpdateOperationsInput | string | null
    payoutMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payoutEmail?: NullableStringFieldUpdateOperationsInput | string | null
    payoutPhone?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormCompleted?: BoolFieldUpdateOperationsInput | boolean
    tax1099Uploaded?: BoolFieldUpdateOperationsInput | boolean
    lastPayoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customCommissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: AffiliateReferralUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    passwordHash?: string | null
    isAdmin?: boolean
    role?: $Enums.UserRole
    isBlocked?: boolean
    avatar?: string | null
    commissionLevel?: $Enums.CommissionLevel
    googleId?: string | null
    googleEmail?: string | null
    googleName?: string | null
    googleProfilePicture?: string | null
    googleAuthProvider?: string | null
    referralCodeUsed?: string | null
    referralRewardTotal?: number
    isAffiliate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string | null
    lastName?: string | null
    businessName?: string | null
    phone?: string | null
    address?: string | null
    unit?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    tinSsn?: string | null
    taxFormUrl?: string | null
  }

  export type AgentCreateManyTenantInput = {
    id?: string
    name: string
    systemPrompt: string
    voiceId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyTenantInput = {
    id?: string
    key: string
    name: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type LeadCreateManyTenantInput = {
    id?: string
    agentId: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    referralsCreated?: ReferralUpdateManyWithoutReferrerNestedInput
    affiliate?: AffiliateUpdateOneWithoutUserNestedInput
    rewards?: RewardTransactionUpdateManyWithoutReferrerNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
    referralsCreated?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    affiliate?: AffiliateUncheckedUpdateOneWithoutUserNestedInput
    rewards?: RewardTransactionUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    commissionLevel?: EnumCommissionLevelFieldUpdateOperationsInput | $Enums.CommissionLevel
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleName?: NullableStringFieldUpdateOperationsInput | string | null
    googleProfilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    referralCodeUsed?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewardTotal?: FloatFieldUpdateOperationsInput | number
    isAffiliate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    tinSsn?: NullableStringFieldUpdateOperationsInput | string | null
    taxFormUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcripts?: TranscriptUpdateManyWithoutAgentNestedInput
    toolAudits?: ToolExecutionAuditUpdateManyWithoutAgentNestedInput
    leads?: LeadUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcripts?: TranscriptUncheckedUpdateManyWithoutAgentNestedInput
    toolAudits?: ToolExecutionAuditUncheckedUpdateManyWithoutAgentNestedInput
    leads?: LeadUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    systemPrompt?: StringFieldUpdateOperationsInput | string
    voiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeadUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    refereeId?: string | null
    code: string
    status?: string
    rewardAmount?: number
    rewardCurrency?: string
    expiresAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardTransactionCreateManyReferrerInput = {
    id?: string
    refereeId?: string | null
    amount: number
    status?: string
    sourcePaymentId?: string | null
    holdEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rewardAmount?: FloatFieldUpdateOperationsInput | number
    rewardCurrency?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rewardAmount?: FloatFieldUpdateOperationsInput | number
    rewardCurrency?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rewardAmount?: FloatFieldUpdateOperationsInput | number
    rewardCurrency?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sourcePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    holdEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sourcePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    holdEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardTransactionUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sourcePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    holdEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptCreateManyAgentInput = {
    id?: string
    userId?: string | null
    content: string
    duration?: number
    createdAt?: Date | string
  }

  export type ToolExecutionAuditCreateManyAgentInput = {
    id?: string
    userId?: string | null
    toolName: string
    toolInput: string
    toolOutput?: string | null
    status?: string
    errorMessage?: string | null
    executionTimeMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyAgentInput = {
    id?: string
    tenantId: string
    name: string
    phone: string
    email?: string | null
    summary?: string | null
    isBooked?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranscriptUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolExecutionAuditUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    toolInput?: StringFieldUpdateOperationsInput | string
    toolOutput?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTimeMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolExecutionAuditUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    toolInput?: StringFieldUpdateOperationsInput | string
    toolOutput?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTimeMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolExecutionAuditUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    toolInput?: StringFieldUpdateOperationsInput | string
    toolOutput?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    executionTimeMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isBooked?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateReferralCreateManyAffiliateInput = {
    id?: string
    refereeId?: string | null
    status?: $Enums.AffiliateReferralStatus
    commissionAmount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliatePayoutCreateManyAffiliateInput = {
    id?: string
    amount: number
    feeAmount?: number
    netAmount?: number
    status?: $Enums.PayoutStatus
    method?: string
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateReferralUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAffiliateReferralStatusFieldUpdateOperationsInput | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateReferralUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAffiliateReferralStatusFieldUpdateOperationsInput | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateReferralUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAffiliateReferralStatusFieldUpdateOperationsInput | $Enums.AffiliateReferralStatus
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliatePayoutUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    feeAmount?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliatePayoutUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    feeAmount?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliatePayoutUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    feeAmount?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    method?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgentCountOutputTypeDefaultArgs instead
     */
    export type AgentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateCountOutputTypeDefaultArgs instead
     */
    export type AffiliateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantTwilioConfigDefaultArgs instead
     */
    export type TenantTwilioConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantTwilioConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgentDefaultArgs instead
     */
    export type AgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranscriptDefaultArgs instead
     */
    export type TranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranscriptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralDefaultArgs instead
     */
    export type ReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RewardTransactionDefaultArgs instead
     */
    export type RewardTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RewardTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToolExecutionAuditDefaultArgs instead
     */
    export type ToolExecutionAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToolExecutionAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoogleAuthConfigDefaultArgs instead
     */
    export type GoogleAuthConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoogleAuthConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemEmailConfigDefaultArgs instead
     */
    export type SystemEmailConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemEmailConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StripeConnectConfigDefaultArgs instead
     */
    export type StripeConnectConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StripeConnectConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantGoogleConfigDefaultArgs instead
     */
    export type TenantGoogleConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantGoogleConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarCredentialsDefaultArgs instead
     */
    export type CalendarCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarCredentialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GmailCredentialsDefaultArgs instead
     */
    export type GmailCredentialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GmailCredentialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlatformSettingsDefaultArgs instead
     */
    export type PlatformSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlatformSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateDefaultArgs instead
     */
    export type AffiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateReferralDefaultArgs instead
     */
    export type AffiliateReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateReferralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliatePayoutDefaultArgs instead
     */
    export type AffiliatePayoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliatePayoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationPackageDefaultArgs instead
     */
    export type ConversationPackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationPackageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}